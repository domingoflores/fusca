// --- DO NOT EDIT ---
// --- MACHINE-GENERATED BY buildScript.bat ---
// --- DO NOT EDIT ---

var gsAppletVersion	= "1.1";
var gsAppletBuildTime	= "10" + "10" + "05" + "11" + "33" + "A";
var gsJavaScriptBuildTime = "12:05P PT Mon 5/2/11"
	
// --- defines.js ------------------------------------------------------------- 	
	
/** 
 *	Global constants for the NetSuite/M5 integration. 
 */ 
 
var	gnStartTime				= nowSec() 
 
if ( typeof( overrideDefines ) != "function" ) 
	overrideDefines = function ( i ) {} 
 
 
/** 
 *	Build control. 
 */ 
 
var	gnDebug					= 0				// Debug level (0: none; >0: increasing verbosity; overridden by "debug=" URL parameter) 
var	gbShowDebugDialogs		= true			// Show (else suppress) debug dialogs? 
var	gbCanInjectCode			= true			// Allow JavaScript injection via the "code" URL parameter (overridden in initConstants)? 
var	gnAutoUpdateCallLogs	= 0				// Auto-update the call log(s) after each call? (-1 = log tab; 0 = none; 1 = that call's tab only; 2 = all tabs) 
var	gbShowForceStateControl	= false			// Show force-state pulldown? 
var	gbShowAsyncButtons		= false			// Show buttons for faking async events? 
var	gbFakePhoneEvents		= false			// Fake events from the phone system? 
var	gbMaintainLog			= true			// Maintain a progress log (ignored if gnDebug = 0)? 
var	gbShowErrorHooked		= true			// See errors in hooked functions? 
var	gbPromptForPanelPos		= false			// Prompt for call panel position? 
var	gbHideNavBar			= true			// Hide NetSuite nav bar? 
 
var gnLines					=  6			// Number of phone lines 
var	gnCalls					=  6			// Max. number of outstanding calls 
var	gnMsecUpdateDurations	= 1000			// How often to update call duration and hold duration (msec.) 
var	gnMsecDisplayCallInfo	=  500			// How often to redisplay details of the current call (msec.) 
var	gnMsecBlinkTabs			=  250			// How often to update blinking tabs (msec.) 
/* Overridden by gnBounceUpdateHz in util.js 
var	gnMsecBounceTabs		=   17			// How often to update bouncing tabs (msec.) // TODO: Not used 
// */ 
var	gnPulldownWidth			=  160			// Width to force NetSuite's "Enter first few letters then tab" pulldowns to (pix.)		 
 
// Allow URL parameters to override this batch of constants 
overrideDefines( 1 ) 
 
 
/** 
 *	NetSuite IDs. 
 */ 
 
var	gsNetSuiteRecordPrefix	= "customrecord"			// Custom record ID prefix 
var	gsNetSuiteListPrefix	= "customlist"				// Custom list ID prefix 
var	gsNetSuiteScriptPrefix	= "customscript"			// Script file ID prefix 
var	gsNetSuiteEntityPrefix	= "custentity"				// Entity ID prefix 
var	gsNetSuiteEventPrefix	= "custevent"				// Event ID prefix 
var gsNetSuiteObjNamePrefix	= "custpagem5_"				// Prefix for the names of all our NetSuite objects (must begin with 
														//  "custpage", per NetSuite specifications) 
var	gsNetSuiteRecordFieldPrefix 
							= "custrecord"				// Record field prefix 
var	gsNetSuiteParamPrefix	= "m5connect_"				// URL parameter name prefix 
 
														// Record type representing users who are authorized for this Suitelet 
var	gsNetSuiteUserType		= gsNetSuiteRecordPrefix + "cti_users" 
 
var	gasPhoneInfo			=							// The M5 phone and its user 
		{ _			: null 
		, userID	: gsNetSuiteRecordFieldPrefix + "cti_employee"			// User ID 
		, enabled	: gsNetSuiteRecordFieldPrefix + "cti_phone_enabled"		// Is M5 phone enabled? 
		, phone		: gsNetSuiteRecordFieldPrefix + "cti_phone_number"		// M5 phone number 
		, password	: gsNetSuiteRecordFieldPrefix + "cti_phone_password"	// M5 phone password 
		} 
 
 
/** 
 *	M5 IDs. 
 */ 
 
var	gsM5WebSvcsURL			= "https://hostedconnect.m5net.com/bobl/bobl" 
 
 
/** 
 *	Window geometry. 
 */ 
 
var ganPanelDim   	= [ 280, 390 ]	// Call panel dimensions (client area) 
var ganPanelMargin	= [  10,  10 ]	// Call panel margin (space between window and screen edge) 
var	ganPanelDebugHeight	=	 139	// Height of debug gadgets at top of call panel in debug mode 
 
var ganDialerDim   	= [ 355, 150 ]	// Dialer dimensions (client area) 
var ganDialerMargin	= [ 300, 100 ]	// Dialer margin (space between window and screen edge) 
 
var	gnMinRecScreenWidth	=   1280	// Minimum recommended screen width 
 
 
/** 
 *	Miscellaneous. 
 */ 
 
   	                  		                       		// What this document is (must define function init_*(), where * is gsDocType) 
var	gsDocType				= ( typeof( document    ) == "undefined" ) ? "builder"	// Suitelet builder for call panel or dialer 
							: ( typeof( gbIsHarness ) != "undefined" ) ? "harness"	// Test harness 
							: ( typeof( gbIsDialer  ) != "undefined" ) ? "dialer"	// Dialer Suitelet 
							:											 "panel"	// Call panel Suitelet 
														// Browser family  
var	gsBrowserFamily			= ( gsDocType != "panel" )									? "?"	// ?  = None or unknown 
							: ( navigator.appName.indexOf( "Internet Explorer" ) >= 0 ) ? "IE"	// IE = Internet Explorer 
							: ( navigator.appVersion.indexOf( "Chrome" ) >= 0 )			? "GC"	// GC = Google Chrome 
							:															  "FF"	// FF = Firefox 
		// TODO: Can't use "<br>" for some reason; causes an error in logme() at innerHTML = join(...) 
var	gsLogNewline			= ( gsBrowserFamily == "IE" ) ? " -- " : "\n" 
var	gsAppletFile			= "JSjava.jar"		// TODO: unsigned 
var	gsAppletPath			= "applet/" 
//	var	gsAppletFile			= "JSjava.jar"	// signed 
var	gsAppletPackage			= "M5a" 
var	gsAppletRootClass		= "JSjava" 
var	gnDialerAutoCloseSec	= 20						// Seconds before dialer auto-closes 
var	gsAssetsBaseURL			= "https://user.m5net.com/m5connect/"	// "https://alumnus.alumni.caltech.edu/~dzobel/m5/assets/" 
var	gsAppletURL				= gsAssetsBaseURL + gsAppletFile 
var	gsLogoLoadingURL		= gsAssetsBaseURL + "M5_0.gif" 
var	gsLogoLoadedURL			= gsAssetsBaseURL + "M5_1.gif" 
	    // TODO: Using -1 for dimensions causes a slight hiccup when swapping images out and in; need to maintain width and height even when image is absent 
		// TODO: There is a hiccup anyway, just because the image placeholder shows momentarily, but at least the screen doesn't jump  
var	ganLogoDims				= [ 225, 40, 4 ]		// Dimensions of the above images (in pixels): width, height, padding below (-1 = use default) 
var	gsNetSuiteUrlParameters	= "deploy,script"		// URL parameters defined by NetSuite that we might ever be interested in (all others must be given with our custom prefix) 
 
 
/** 
 *	Suitelet (form) structures. 
 */ 
 
	// TODO: UNUSED 
										// Prefix of the ID of the Java VM hosting the applet 
var	gsAppletPrefix	= ( gsDocType		  == "builder"  ) ? "?"			// We don't embed the applet in the form builder 
					: ( navigator.appName == "Netscape" ) ? "embed"		// Netscape/Firefox/Chrome 
					:										"object"	// Internet Explorer 
 
 
 
/** 
 *	Definitions of fields for each phone call. 
 */ 
                   	   	// TODO: Have a separate field for internal reference, rather than using the label as the reference in panel.js 
                   	    // TODO: Scale the different types so that their widths are in comparable units 
                   	    // TODO: This should really list all the properties of a phone call, including the ones that are not presented onscreen 
var	gasCallField	= 
								// Editable? 
	// Label			|  W x H | E | Type 
   	[ null 
   	, "State			| 10	 | n | text" 
	, "Number			| 12	 | y | text" 
	, "Matches			| 32	 | y | select -" 
	, "Speaking To		| 24	 | y | select contact" 
	, "Title			| 28	 | n | text" 
	, "					|  1	 | n | button" 
	, "					|  1	 | n | button" 
	, "Call Details		|  1	 | n | label" 
	, "Subject			| 26	 | y | text" 
	, "Comments			| 24 x 4 | y | textarea" 
//	, "Company			| 40	 | y | select customer"		// TODO: This needs to cover customers, partners, vendors, etc. 
//	, "Contact			| 22	 | y | select contact" 
//	, "Support Case		| 24	 | y | select supportcase" 
//	, "Transaction		| 20	 | y | select transaction" 
	, "Priority			| 12	 | y | select -" 
	, "Result			| 22	 | y | select " + gsNetSuiteListPrefix + "cti_call_result" 
	, "Duration			| 10	 | n | text" 
	, "Disposition		| 10	 | n | select " + gsNetSuiteListPrefix + "cti_call_disposition" 
	, "Direction		| 10	 | n | select " + gsNetSuiteListPrefix + "cti_call_direction" 
	] 
 
 
/** 
 *	Properties of a phone call. 
 * 
 *	Each of these properties has a default value, to which we set it when we are 
 *	entering the Idle state.  It may also have a (different) "initial" value, to 
 *	which we set it when a call is starting, if the user has not already set it to 
 *	a different value. 
 * 
 *	Any property not listed here also has a default and an initial value, which are 
 *	both the same (either the empty string for non-numeric properties, zero for 
 *	numeric properties, or an empty pulldown for "select"-type properties). 
 */ 
 
	// dhzdhz Some of these can probably be deleted or merged into gasCallField 
var	gasCallProperty	= 
 
	// Name				| Default	| Initial value on call 
	[ null 
	, "direction		|			|" 
	, "disposition		|			|" 
	, "duration			| 0			| 0" 
	, "priority			| MEDIUM	| MEDIUM"	// TODO: Use goCallPriorityIndex.medium 
	, "result			|			|" 
	, "secCallStart		| 0			| 0" 
	, "secCallTotal		| 0			| 0" 
	, "secHoldTotal		| 0			| 0" 
	, "status			| COMPLETE	| COMPLETE"	// TODO: Use goCallStatusIndex.complete		// Will always be Completed, since the call (or at least an attempt) actually took place 
	, "subject			|			| {Call on} m/d/yy {at} h:nn aa"	// TODO 
	] 
 
 
/** 
 *	Mapping between the call info structure and the fields of a phonecall record. 
 * 
 *	A missing value in the right-hand column indicates "same as left-hand column." 
 */ 
 
var	gsMappingCallInfoToPhonecallRecord = "" 
		// Call info structure	| Field of phonecall record 
		+ ",comments			| message" 
		+ ",company" 
		+ ",contact" 
		+ ",disposition			|" + gsNetSuiteEventPrefix + "cti_call_disposition" 
		+ ",duration			|" + gsNetSuiteEventPrefix + "cti_call_duration" 
		+ ",matches				|" + gsNetSuiteEventPrefix + "cti_call_matches" 
		+ ",priority" 
		+ ",result				|" + gsNetSuiteEventPrefix + "cti_call_result" 
		+ ",secHoldTotal		|" + gsNetSuiteEventPrefix + "cti_hold_duration" 
		+ ",speaking_to			|" + gsNetSuiteEventPrefix + "cti_call_speaking_to" 
		+ ",subject				| title" 
		+ ",support_case		| supportcase" 
		+ ",transaction" 
 
 
/** 
 *	Attributes of a read-only form field. 
 */ 
 
var gaReadOnlyAttribute = 
	[ null 
	, "inline" 
	, "disabled" 
	, "readonly" 
	] 
 
 
/** 
 *	Call log. 
 */ 
 
var gnLogRows		=  10	// Number of rows in log (0 = unlimited) 
var gaLogCols		=		// Columns 
	//  Column 
	[ null 
	, "Spoke to" 
	, "Subject" 
	, "Date"	// and time 
	] 
var	gsLogLinkBra 	= '<a target="phonecall:{ID}" href="/app/crm/calendar/call.nl?id={ID}">' 
var	gsLogLinkKet	= "</a>" 
var	gsLogSearchID	= "customsearchcti_call_log"	// 61 
 
 
/** 
 *	Style sheet rules.  Note the slight differences between 
 *	the regular CSS format and our format here:  e.g., comma 
 *	instead of semicolon, and quotes around each value. 
 */ 
 
var	gaoStyleSheetRule =  
	[ null 
 
	// Classes defined by NetSuite 
 
	  // dhzdhz Is this the right notation?  Should it be font-weight instead of fontWeight?  Is it browser-dependent? 
	  // TODO: _X means "ignore"; probably just comment these out 
	,	{ _X : ".smalltextnolink" 
		, fontWeight		: "bold" 
		} 
 
	// Our own classes 
 
	,	{ _X : ".actionButton" 
		, color				: "#101" 
		, backgroundColor	: "#BCD" 
		, fontWeight		: "bold" 
	    , fontSize			: "12pt" 
	    , marginLeft		: 110 
	    , borderWidth		: 3 
	    , borderColor		: "#54B #303 #101 #328" 
		} 
	,	{ _ : ".actionButton" 
	    , marginRight		: 10 
		} 
	,	{ _ : ".actionButtonFirst" 
		, marginLeft		: 60 
		} 
	,	{ _ : ".debugInfo" 
		, color				: "#808" 
		, fontSize			: "6pt" 
		, readOnly			: true	// TODO: does this do anything? 
		} 
	,	{ _ : ".debugLog" 
		, color				: "#090" 
		, fontSize			: "6pt" 
		, readOnly			: true	// TODO: does this do anything? 
		} 
	,	{ _ : ".dialerButton" 
		, color				: "#101" 
		, backgroundColor	: "#BCD" 
		, fontWeight		: "bold" 
	    , fontSize			: "12pt" 
	    , marginLeft		: 90 
	    , borderWidth		: 3 
	    , borderColor		: "#54B #303 #101 #328" 
	    , maxWidth			: "100px"	//? 
	    , whiteSpace		: "normal" 
		} 
	,	{ _ : ".suitelet" 
		, backgroundColor	: "#FFF"	// #069 
		} 
	,	{ _ : ".suiteletInactive" 
		, backgroundColor	: "#FFF"	// #CCC 
		} 
 
	// Definitions for specific tags 
 
	,	{ _ : "object" 
		, visiblity			: "hidden" 
		} 
	] 
 
 
/** 
 *	Initial values for the call info structure. 
 */ 
// TODO: Use shorthand (set to null ) 
// TODO: Some of these can be handled by gaoCallProperty 
	 
var	goCallInfoInit	= 
	{ _		: null 
	, Start	:		// Set when entering "Start" state 
		{ _					: null 
		, state				: null 
		, statePrev			: null 
		, tab				: "" 
		} 
	, Idle	:		// Set when entering "Idle" state 
		{ _					: null 
		, timer				: 0		// TODO: Roll into secCall* 
		, secCallStart		: 0		// Start time of current call (msec) 
		, secCallEnd		: 0		// End time of current call (msec) 
		, secHoldStart		: 0		// Start of the current hold block (msec) 
		, secHoldCurrent	: 0		// Length of the current hold block (msec) 
		, secHoldTotal		: 0		// Total time we've had this call on hold so far (msec) 
		, number			: "" 
		, digits			: "" 
		, callID			: "" 
		, line				: "?" 
		, bOffHook			: "false" 
		, recID				: null 
		, rPhoneCall		: null 
		, matchesIndex		: null			// TODO: unused 
		, matchesText		: ""			// TODO: unused 
		, contactIndex		: null 
		, contactText		: "" 
		, companyIndex		: null 
		, companyText		: "" 
		, subject			: "" 
		, comments			: "" 
		, bOnCall			: "false" 
		, bOnHold			: "false" 
		} 
	} 
 
 
/** 
 *	Tab colors.  Each entry is an array of one or more color pairs 
 *	(specified as "[foreground]:[background]", where each color 
 *	consists of three RGB digits).  A missing color indicates "use 
 *	the item's original color."  Each tab cycles (at the blink rate) 
 *	through the colors corresponding to its current state. 
 */ 
 
var	goasTabColor	= 
	{ _			: [ ""						] 
	, "None"	: [ ""						] 
	, "Red"		: [ ":E46"					] 
	, "Orange"	: [ ":FDA"					] 
	, "Green"	: [ ":2C4"					] 
	, "Blue"	: [ ":6BF"					] 
	, "Blink"	: [ "000:FF8",	"009:CC6"	] 
	, "Bounce"	: [ "828:8D8",	"000:DA0"	] 
	} 
 
 
/** 
 *	How a tab bounces when a call is ringing in. 
 */ 
 
var	goRingBounce	= 
	{ _				: null 
	, nAmplitude	: 4		// Max. deflection (in pixels) up (and down) from the default position 
	, nHz			: 8		// Bounce frequency 
	} 
 
 
var	goTriggerAction	= 
	{ _				: null 
	, A_He_answers	: "m5EventHeAnswers" 
	, A_He_hangs_up	: "m5EventHeHangsUp" 
	, A_He_ignores	: "m5EventHeIgnores" 
	, A_He_rings	: "m5EventHeRings" 
	, A_He_s_busy	: "m5EventHesBusy" 
	, A_I_answer	: "phoneActionIAnswer" 
	, A_I_hang_up	: "phoneActionIHangUp" 
	, A_I_ignore	: "phoneActionIIgnore" 
	, A_I_ring		: "phoneActionIRing" 
	, A_I_m_busy	: "phoneActionImBusy" 
	, B_Answer		: "m5CmdAnswer" 
	, B_Commit		: "clkdCommit" 
	, B_Dial_Out	: "clkdDialOut" 
	, B_End			: "m5CmdEnd" 
	, B_Hold		: "m5CmdHold" 
	, B_Ignore		: "m5CmdIgnore" 
	, B_Resume		: "m5CmdResume" 
	, M_CONNECTED	: "" 
	, M_DELETED		: "" 
	, M_HOLDING		: "" 
	, M_PENDING		: "" 
	, M_RINGING		: "" 
	} 
 
 
/** 
 *	Custom lists. 
 *	TODO: Read these from NetSuite instead of hard-wiring them. 
 */ 
 
var	gaoCustomList = 
	[ null 
	,	// TODO: Does priority exist as a list in NetSuite?  Anyway, it's not a custom list 
		{ _	: "priority" 
		, "LOW"		: "Low" 
		, "MEDIUM"	: "Medium" 
		, "HIGH"	: "High" 
		} 
	,		// TODO: Someday, read correctly from NetSuite 
		{ _	: gsNetSuiteListPrefix + "cti_call_disposition" 
		, "1"		: "Ready" 
		, "2"		: "Incomplete" 
		, "3"		: "Complete" 
		, "4"		: "Missed" 
		, "5"		: "Ignored" 
		, "6"		: "Answered" 
		} 
	,		// TODO: Someday, read correctly from NetSuite 
		{ _	: gsNetSuiteListPrefix + "cti_call_direction" 
		, "1"		: "Incoming" 
		, "2"		: "Outgoing" 
		} 
	] 
 
 
/** 
 *	All known flags in the finite state machine. 
 * 
 *		I = incoming call 
 *		O = outgoing call 
 *		T = run call timer		// dhzdhz unused 
 *		R = reset call timer	// dhzdhz unused 
 *		H = phone is off hook 
 *		# = desirability for autocommit (higher = more desirable) 
 */ 
 
var	gsAllKnownFlags	= "IOTRH1234567" 
 
/** 
 *	The finite state machine, as an array of strings. 
 * 
 *	If a received trigger is undefined for the current state: 
 *		A or B -> error 
 *		M or X -> ignored 
 * 
 *	Special characters in the "change state to" column: 
 *		^	ditto 
 *		-	do not change state 
 *		#	only perform this state change if gbFakePhoneEvents is true 
 * 
 *	CAUTION:  All changes to state names (even if only capitalization) must be reflected 
 *	in the "change state to" column, as well as in gofStateTransition. 
 */ 
 
var gasStateMachine	= 
	// State name	 | Flags   | Tab	| Dispositn	| On trigger... 	| ...change state to... 
	[ null 
	, "Start		 | .....6 | None	| Ready		| X	X				| Idle" 
	, "Idle			 | ...R.7 | None	| Ready		| B Dial Out		| -" 
	,											   "| M RINGING			| Ringing In" 
	,							   				   "| A I ring			| ^" 
	,								   			   "| M PENDING			| Ringing Out"	// Can only happen if we dial directly from the M5 phone 
	,											   "| A He rings		| ^"			//  " 
	,											   "| M CONNECTED		| On Call"		// Can only happen if a call is already in progress when we start up 
	,								   			   "| A He answers		| ^"			//  " 
	,											   "| M HOLDING			| Hold"			//  " 
	,								   			   "| A I press Hold	| ^"			//  " 
	,											   "| A Autocommit		| -" 
	, "Dialing		 | .O..H2 | Orange | Incomplete	| B End				| Incomplete" 
	,											   "| M DELETED			| ^" 
	,								   			   "| A I hang up		| ^" 
	,											   "| M PENDING			| Ringing Out" 
	,								   			   "| A He rings		| ^" 
	,											   "| A He's busy		| Busy" 
	,											   "| A Autocommit		| Store" 
	, "Ringing Out	 | .O.RH2 | Orange | Incomplete	| B End				| Incomplete" 
	,											   "| M DELETED			| ^" 
	,											   "| A I hang up		| ^" 
	,											   "| M CONNECTED		| On Call" 
	,								   			   "| A He answers		| ^" 
	,											   "| A He ignores		| No Answer" 
	,											   "| A He's busy		| Busy" 
	,											   "| A Autocommit		| Store" 
	, "Ringing In	 | I..RH2 | Bounce | Incomplete	| B Answer			| On Call#" 
	,											   "| M CONNECTED		| On Call" 
	,											   "| A I answer		| ^" 
	,											   "| B Ignore			| Ignored" 
	,											   "| M DELETED			| Missed" 
	,											   "| A He hangs up		| ^" 
	,											   "| A I'm busy		| Busy" 
	,											   "| A Autocommit		| Store" 
	, "On Call		 | IOT.H1 | Green  | Complete	| B Hold			| Going on Hold" 
	,											   "| M HOLDING			| Hold" 
	,								   			   "| A I press Hold	| ^" 
	,											   "| B End				| Commit" 
	,											   "| M DELETED			| ^" 
	,											   "| A I hang up		| ^" 
	,											   "| A He hangs up		| ^" 
	,											   "| A Autocommit		| Store" 
	, "Going on Hold | IOT.H1 | Blink  | Complete	| M HOLDING			| Hold" 
	,											   "| X X				| ^#" 
	,								   			   "| A I press Resume	| Resuming" 
	,											   "| B 				| -" 
	,											   "| B End				| Commit" 
	,											   "| M DELETED			| ^" 
	,											   "| A I hang up		| ^" 
	,											   "| A He hangs up		| ^" 
	,											   "| A Autocommit		| Store" 
	, "Hold			 | IOT.H1 | Blink  | Complete	| B Resume			| Resuming" 
	,								   			   "| A I press Resume	| ^" 
	,											   "| M CONNECTED		| On Call" 
	,											   "| B End				| Commit" 
	,											   "| M DELETED			| ^" 
	,											   "| A I hang up		| ^" 
	,											   "| A He hangs up		| ^" 
	,											   "| A Autocommit		| Store" 
	, "Resuming		 | IOT.H1 | Blink  | Complete	| M CONNECTED		| On Call" 
	,											   "| X X				| ^#" 
	,								   			   "| A I press Resume	| ^" 
	,											   "| B 				| -" 
	,											   "| B End				| Commit" 
	,											   "| M DELETED			| ^" 
	,											   "| A I hang up		| ^" 
	,											   "| A He hangs up		| ^" 
	,											   "| A Autocommit		| Store" 
	, "Incomplete	 | .O...4 | Red	   | Incomplete	| B Commit			| Store" 
	,											   "| A Autocommit		| ^" 
	, "Busy			 | IO...4 | Red	   | Incomplete	| B Commit			| Store"	// TODO: Should H flag be set? 
	,											   "| A Autocommit		| ^" 
	, "No Answer	 | .O...4 | Red	   | Incomplete	| B Commit			| Store" 
	,											   "| A Autocommit		| ^" 
	, "Ignored		 | I....4 | Red	   | Ignored	| B Commit			| Store" 
	,											   "| A Autocommit		| ^" 
	, "Missed		 | I....5 | Red	   | Missed		| B Commit			| Store" 
	,											   "| A Autocommit		| ^" 
	, "Commit		 | IO...3 | Blue   | {unchg}	| B Commit			| Store" 
	,											   "| A Autocommit		| ^" 
	, "Store		 | .....6 | None   | {unchg}	| X X				| Idle" 
	] 
 
// Allow URL parameters to override this batch of constants 
overrideDefines( 2 ) 
	
// --- globals.js ------------------------------------------------------------- 	
	
/** // globals.js
 *	Global variables for the NetSuite/M5 integration. // globals.js
 */ // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	User-facing strings. // globals.js
 */ // globals.js
 // globals.js
var	goText			= [] // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Call whose tab is currently being displayed. // globals.js
 */ // globals.js
 // globals.js
var	giCurrentCall	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	The fields that appear on each tab of the form. // globals.js
 */ // globals.js
 // globals.js
var	gaoCallField	= null	// Indexed on compressed field name // globals.js
var	ganCallField	= null	// Indexed on order of appearance on tab (1-based) // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Properties of a phone call. // globals.js
 */ // globals.js
 // globals.js
var	gaoCallProperty	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Mappings between structures. // globals.js
 */ // globals.js
 // globals.js
var	goMapping		= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	The finite state machine, as an array of objects. // globals.js
 */ // globals.js
 // globals.js
var gaoStateMachine	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	First state for a call to be in.  // globals.js
 */ // globals.js
 // globals.js
var	gsInitialState	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Per-call information (1-based): // globals.js
 *		state			Current state // globals.js
 *		statePrev		Previous state // globals.js
 *		timer			Timer: // globals.js
 *							< 0		Running; value is negative of time at which timer was started // globals.js
 *							= 0		Not running; waiting to be started // globals.js
 *							> 0		Not running; value is most recent duration // globals.js
 *		disposition		Disposition of current call, if any // globals.js
 *	TODO update this // globals.js
 *		callID			ID of current call, if any // globals.js
 */ // globals.js
 // globals.js
var	gaoCall			= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Timers for periodic activities. // globals.js
 */ // globals.js
 // globals.js
var	gooDisplayTimer	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Call direction. // globals.js
 */ // globals.js
 // globals.js
var	goCallDirection			= null // globals.js
var	goCallDirectionIndex	= null // globals.js
var	gsCallDirectionTest		= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Call disposition. // globals.js
 */ // globals.js
 // globals.js
var	goCallDisposition	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Call result. // globals.js
 */ // globals.js
 // globals.js
var	goCallResult	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	Priority. // globals.js
 */ // globals.js
 // globals.js
var	goPriority			= null // globals.js
var	goCallPriorityIndex	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	NetSuite script ID (numeric). // globals.js
 */ // globals.js
 // globals.js
var	gnNetSuiteScriptID	= null // globals.js
 // globals.js
 // globals.js
/** // globals.js
 *	NetSuite deployment ID (numeric). // globals.js
 */ // globals.js
 // globals.js
var	gnNetSuiteDeploymentID	= null // globals.js
	
// --- strings_EN_us.js ------------------------------------------------------------- 	
	
/** // strings_EN_us.js
 *	String constants for EN_us. // strings_EN_us.js
 */ // strings_EN_us.js
 // strings_EN_us.js
 // strings_EN_us.js
/** // strings_EN_us.js
 *	User-facing text. // strings_EN_us.js
 */ // strings_EN_us.js
 // strings_EN_us.js
// TODO: Still need to extract some of the strings in callInfo.js, defines.js, panel.js, and preprocess.js // strings_EN_us.js
 // strings_EN_us.js
goText[ "EN_us" ] = // strings_EN_us.js
	{ _				: null // strings_EN_us.js
 // strings_EN_us.js
		// Call panel title // strings_EN_us.js
	, callPanelTitle		: "ShoreTel Sky Connect for NetSuite" // strings_EN_us.js
 // strings_EN_us.js
		// Call panel window's internal name, if launched via window.open(); // strings_EN_us.js
		//  spaces will be converted to underscores for IE 8 compatibility // strings_EN_us.js
	, callPanelWindowName	: "ShoreTel Sky Connect for NetSuite call panel" // strings_EN_us.js
 // strings_EN_us.js
		// Footer: contact your sysadmin // strings_EN_us.js
	, contactSysAdmin		: "Please contact your system administrator." // strings_EN_us.js
 // strings_EN_us.js
		// Dialer button // strings_EN_us.js
	, dialerButton			: "Open call&nbsp;panel" // strings_EN_us.js
 // strings_EN_us.js
		// Dialer dialing // strings_EN_us.js
	, dialerDialing			: "Dialing %t from %f..." // strings_EN_us.js
 // strings_EN_us.js
		// Dialer title // strings_EN_us.js
	, dialerTitle			: "Dialing %t" // strings_EN_us.js
 // strings_EN_us.js
		// Dialer unable to dial // strings_EN_us.js
	, dialerUnableToDial	: "Unable to dial %t" // strings_EN_us.js
 // strings_EN_us.js
		// Force state // strings_EN_us.js
	, forceState			: "Force state" // strings_EN_us.js
 // strings_EN_us.js
		// Ignored // strings_EN_us.js
	, ignored				: "Ignored" // strings_EN_us.js
 // strings_EN_us.js
		// Error in injected code // strings_EN_us.js
	, injectedCodeError		: "Error in injected code" // strings_EN_us.js
 // strings_EN_us.js
		// JavaScript file mismatch // strings_EN_us.js
	, jsMismatch			: "WARNING: JavaScript file version mismatch." // strings_EN_us.js
								+ "\n\n" // strings_EN_us.js
								+ "Press Ctrl-F5 or flush your browser cache." // strings_EN_us.js
								+ "\n\n" // strings_EN_us.js
								+ "This error will not occur after rollout." // strings_EN_us.js
 // strings_EN_us.js
		// Log column headers // strings_EN_us.js
	, logColumnDate			: "Date" // strings_EN_us.js
	, logColumnSpokeTo		: "Spoke to" // strings_EN_us.js
	, logColumnSubject		: "Subject" // strings_EN_us.js
 // strings_EN_us.js
		// Log tab name // strings_EN_us.js
	, logTab				: "Log" // strings_EN_us.js
 // strings_EN_us.js
		// Log title // strings_EN_us.js
	, logTitle				: "My call log" // strings_EN_us.js
 // strings_EN_us.js
		// M5 error header (for one error or multiple errors) // strings_EN_us.js
	, m5ErrorHeaderSing		: "ShoreTel Sky Connect for NetSuite received this error message from the phone system:" // strings_EN_us.js
	, m5ErrorHeaderPlur		: "ShoreTel Sky Connect for NetSuite received these error messages from the phone system:" // strings_EN_us.js
 // strings_EN_us.js
		// Missed // strings_EN_us.js
	, missed				: "Missed" // strings_EN_us.js
 // strings_EN_us.js
		// "Move window" prompt // strings_EN_us.js
	, movePrompt			: "Move to which corner? ([ul], ur, ll, lr)" // strings_EN_us.js
 // strings_EN_us.js
		// This phone number is unknown // strings_EN_us.js
	, noMatches				: "(No matches)"		// TODO: "Unknown number" // strings_EN_us.js
 // strings_EN_us.js
		// Phone disabled // strings_EN_us.js
	, phoneDisabled			: "Your CTI phone is disabled." // strings_EN_us.js
 // strings_EN_us.js
		// Popup dialog standard header // strings_EN_us.js
	, popupStdHeader		: "ShoreTel Sky Connect for NetSuite" // strings_EN_us.js
 // strings_EN_us.js
		// Popup dialog standard footer // strings_EN_us.js
	, popupStdFooter		: "Please contact M5 Support for assistance." // strings_EN_us.js
 // strings_EN_us.js
		// Screen too narrow // strings_EN_us.js
	, screenTooNarrow		: "For optimal use, the ShoreTel Sky Connect for NetSuite Phone Panel\nis designed to work with a screen width of " + gnMinRecScreenWidth + " pixels or greater." // strings_EN_us.js
 // strings_EN_us.js
		// Choose a contact // strings_EN_us.js
	, selectContact			: "-- Select contact --" // strings_EN_us.js
 // strings_EN_us.js
		// Unknown user // strings_EN_us.js
	, userUnknown			: "Current user not found in the list of CTI users." // strings_EN_us.js
 // strings_EN_us.js
	} // strings_EN_us.js
	
// --- strings.js ------------------------------------------------------------- 	
	
/** // strings.js
 *	Choose a language for user-facing strings. // strings.js
 */ // strings.js
 // strings.js
goText = goText[ "EN_us" ] // strings.js
	
// --- preprocess.js ------------------------------------------------------------- 	
	
/** // preprocess.js
 *	Utilities for the NetSuite/M5 integration, used by both the call panel // preprocess.js
 *	Suitelet and the form builder. // preprocess.js
 */ // preprocess.js
 // preprocess.js
 // preprocess.js
function // preprocess.js
initConstants( // preprocess.js
	) // preprocess.js
{ // preprocess.js
	// Certain constants depend on other constants // preprocess.js
	if ( gnDebug == 0 ) // preprocess.js
		gbMaintainLog = false // preprocess.js
/*	// Allow in all builds // preprocess.js
	if ( !isOneOf( gsBuildType, "dt" )) // preprocess.js
		gbCanInjectCode = false // preprocess.js
// */ // preprocess.js
 // preprocess.js
	// Look up custom lists // preprocess.js
	goCallDirection		= getCustomList( gsNetSuiteListPrefix + "cti_call_direction"   ) // preprocess.js
	goCallDisposition	= getCustomList( gsNetSuiteListPrefix + "cti_call_disposition" ) // preprocess.js
	goCallResult		= getCustomList( gsNetSuiteListPrefix + "cti_call_result"      )	// TODO: THIS IS UNUSED // preprocess.js
	goPriority			= getCustomList( "priority" ) // preprocess.js
 // preprocess.js
	// Create some useful global constants from these lists // preprocess.js
	goCallDirectionIndex = translateList( goCallDirection.byValue, "rx:I,tx:O"			   ) // preprocess.js
	goCallPriorityIndex  = translateList(      goPriority.byValue, "low:L,medium:M,high:H" ) // preprocess.js
 // preprocess.js
	var	s	= ";" + goCallDirectionIndex.rx + ";" // preprocess.js
	gsCallDirectionTest = s + goCallDirectionIndex.tx + s // preprocess.js
 // preprocess.js
	// Convert the state machine table from strings to objects // preprocess.js
	parseStateMachine( gasStateMachine ) // preprocess.js
 // preprocess.js
	// Convert the call fields info table from strings to objects // preprocess.js
	parseCallFields( gasCallField ) // preprocess.js
 // preprocess.js
	// Convert the call properties info table from strings to objects // preprocess.js
	parseCallProperties( gasCallProperty ) // preprocess.js
 // preprocess.js
	// Set up a mapping between the call info structure and the fields of a phonecall record // preprocess.js
	parseMapping( gsMappingCallInfoToPhonecallRecord, "CallInfo", "PhonecallRecord" ) // preprocess.js
} // preprocess.js
 // preprocess.js
 // preprocess.js
/** // preprocess.js
 *	Translate a list of key/value pairs by creating a new object with arbitrary // preprocess.js
 *	keys.  The values in this new table are the keys of the values in the other // preprocess.js
 *	table. // preprocess.js
 * // preprocess.js
 *	The translation mapping consists of a collection of pairs, of the form "key:pat". // preprocess.js
 *	For each such pair, an element named "key" will be created in the new table, // preprocess.js
 *	and its value will be the key (index) of the first element in the other table // preprocess.js
 *	whose value begins with "pat" (case-blind). // preprocess.js
 * // preprocess.js
 *	Example: // preprocess.js
 *		old table = { a1 : "Don", b2 : "Edgar", c3 : "Fred" } // preprocess.js
 *		translation mapping:  "x:D,y:Edg,z:fr" // preprocess.js
 *		new table = { x : "a1", y : "b2", z : "c3" } // preprocess.js
 * // preprocess.js
 * @param oTable // preprocess.js
 * @param sXlation // preprocess.js
 * @return // preprocess.js
 */ // preprocess.js
 // preprocess.js
function // preprocess.js
translateList( // preprocess.js
	oTable,		// Object containing key/value pairs // preprocess.js
	sXlation )	// Translation mapping, in the form "key1:pat1,key2:pat2,key3:pat3,..." // preprocess.js
{ // preprocess.js
	var	oXlated	= {} // preprocess.js
 // preprocess.js
	var	a	= sXlation.split( "," ) // preprocess.js
	for ( var i in a ) { // preprocess.js
		var	b	= a[ i ].split( ":" ) // preprocess.js
		for ( var e in oTable ) { // preprocess.js
			if ( e.toUpperCase().indexOf( b[ 1 ].toUpperCase() ) == 0 ) { // preprocess.js
				oXlated[ b[ 0 ]] = oTable[ e ] // preprocess.js
				break // preprocess.js
			} // preprocess.js
		} // preprocess.js
	} // preprocess.js
 // preprocess.js
	return ( oXlated ) // preprocess.js
} // preprocess.js
 // preprocess.js
 // preprocess.js
/** // preprocess.js
 *	Look up a custom list (or a hard-wired list). // preprocess.js
 * // preprocess.js
 *	Add an entry with the ID 0 and null as its value, // preprocess.js
 *	which can optionally be used as a null or default selection. // preprocess.js
 * // preprocess.js
 * @param sName // preprocess.js
 * @return // preprocess.js
 */ // preprocess.js
 // preprocess.js
function // preprocess.js
getCustomList( // preprocess.js
	sName ) // preprocess.js
{ // preprocess.js
	var	oList	= // preprocess.js
		{ _			: null // preprocess.js
		, byID		: {} // preprocess.js
		, byValue	: {} // preprocess.js
		} // preprocess.js
 // preprocess.js
	// Look up the hard-wired values for this type // preprocess.js
	var	oCustomList	= null // preprocess.js
	for ( var iList in gaoCustomList ) { // preprocess.js
		oCustomList	= gaoCustomList[ iList ] // preprocess.js
		if ( oCustomList == null ) // preprocess.js
			continue // preprocess.js
		if ( oCustomList._ != sName ) // preprocess.js
			continue // preprocess.js
		for ( var sID in oCustomList ) { // preprocess.js
			if ( sID == "_" ) // preprocess.js
				continue // preprocess.js
			var	sValue	= oCustomList[ sID ] // preprocess.js
			oList.byID[    sID    ] = sValue // preprocess.js
			oList.byValue[ sValue ] = sID // preprocess.js
		} // preprocess.js
 // preprocess.js
		return ( oList ) // preprocess.js
	} // preprocess.js
 // preprocess.js
	// If there isn't a hard-wired list by this name // preprocess.js
 // preprocess.js
	// Look up this type as a custom list in NetSuite // preprocess.js
	var	aoCustomList	= null // preprocess.js
/* // preprocess.js
	logme( 1, "ready? " + sName) // preprocess.js
	var	sColumns	= "valueId".split( "," ) // preprocess.js
	var	columns	= [] // preprocess.js
	for ( var ii in sColumns ) // preprocess.js
		columns.push( new nlobjSearchColumn( sColumns[ ii ])) // preprocess.js
	var	oFilter	= new nlobjSearchFilter( "id", null, "is", sName )  // preprocess.js
// */ // preprocess.js
	try { // preprocess.js
		aoCustomList = nlapiSearchRecord( sName )//, null, null, columns ) // preprocess.js
	} catch ( e ) {} // var xx = ""; for ( var q in e ) xx += "\n" + q + ": " + e[ q ]; popUpDebug( "nlapiSearchRecord(" + sName + ") gave " + xx )} // preprocess.js
//	logme( 1, "looking for " + sName + "; got " + aoCustomList) // preprocess.js
	if ( aoCustomList != null ) { // preprocess.js
		for ( var iChoice in aoCustomList ) { // preprocess.js
/* // preprocess.js
			var xx = "List: " + aoCustomList[ iChoice ] // preprocess.js
			for ( var q in aoCustomList[ iChoice ]) // preprocess.js
				xx += "\n " + q + ": {" + aoCustomList[ iChoice ][ q ] +"}" // preprocess.js
// */ // preprocess.js
			var	sID		= aoCustomList[ iChoice ].getId() // preprocess.js
			var	sValue	= aoCustomList[ iChoice ].getId()	// ??!! // preprocess.js
//			logme( 1, xx ) // preprocess.js
			oList.byID[    sID    ] = sValue // preprocess.js
			oList.byValue[ sValue ] = sID // preprocess.js
//			logme( 1, "I map " + sID + " to " + sValue + "!" ) // preprocess.js
		} // preprocess.js
	} // preprocess.js
/* // preprocess.js
	var orr = nlapiLoadRecord( sName, 1 ) // preprocess.js
	var ww = '' // preprocess.js
	for ( var g in orr ) // preprocess.js
		ww += "\n" + g + ": {"+ orr[ g ] +"}" // preprocess.js
	logme( 1, ww) // preprocess.js
// */ // preprocess.js
	return ( oList ) // preprocess.js
} // preprocess.js
 // preprocess.js
 // preprocess.js
function // preprocess.js
parseCallFields( // preprocess.js
	asCallField ) // preprocess.js
{ // preprocess.js
	gaoCallField = [] // preprocess.js
	ganCallField = [ null ]		// This array is 1-based, so put a space filler in slot 0 // preprocess.js
 // preprocess.js
	var	aoFieldFns	= [ null, null ] // preprocess.js
 // preprocess.js
	if ( gsDocType == "panel" ) // preprocess.js
		aoFieldFns = // preprocess.js
			[ { get	: nlapiGetFieldText // preprocess.js
			  , set	: nlapiSetFieldText // preprocess.js
			  } // preprocess.js
			, { get	: nlapiGetFieldValue // preprocess.js
			  , set	: nlapiSetFieldValue // preprocess.js
			  } // preprocess.js
			] // preprocess.js
 // preprocess.js
	var	iButton	= 0 // preprocess.js
	var	n		= asCallField.length // preprocess.js
	for ( var iField = 0; ++iField < n; ) { // preprocess.js
		var a			= ( asCallField[ iField ] + "|" ).split( "|" ) // preprocess.js
		var	sLabel		= trim( a[ 0 ]) // preprocess.js
		var	sDims		= trim( a[ 1 ]) // preprocess.js
		var sEditable	= trim( a[ 2 ]) // preprocess.js
		var	sType		= trim( a[ 3 ]) // preprocess.js
 // preprocess.js
		a = splitEnsure( sType.replace( /  */, " " ), " ", 2 ) // preprocess.js
		sType = a[ 0 ].toLowerCase() // preprocess.js
		var	bIsSelect	= ( sType == "select" ) // preprocess.js
		var	sSource		= a[ 1 ] // preprocess.js
		if ( !bIsSelect || sSource == "-" || sSource == "" ) // preprocess.js
			sSource = null // preprocess.js
 // preprocess.js
		a = ( sDims + "x1" ).replace( / /g, "" ).split( "x" ) // preprocess.js
		var	nWidth		= a[ 0 ] // preprocess.js
		var	nHeight		= a[ 1 ] // preprocess.js
		// For some reason, textarea's are built with one row too many // preprocess.js
		if ( sType == "textarea" && nHeight > 1 ) // preprocess.js
			--nHeight // preprocess.js
 // preprocess.js
		var	bIsEditable	= ( sEditable == "y" ) // preprocess.js
 // preprocess.js
		var	sKey		= sLabel // preprocess.js
		if ( sType == "button" ) // preprocess.js
			sKey = "_" + ++iButton // preprocess.js
/*		// Append a colon to each label // preprocess.js
		else if ( sType != "label" ) // preprocess.js
			sLabel += ":" // preprocess.js
// */ // preprocess.js
 // preprocess.js
		sKey = sKey.replace( / /g, "" ).toLowerCase()	// TODO: Would be nicer to camel-case it // preprocess.js
 // preprocess.js
		var	nWidthMultiplier	= // preprocess.js
			  ( bIsSelect )			  ?  5 // preprocess.js
			: ( sType == "textarea" ) ?  2 // preprocess.js
			:							 1 // preprocess.js
 // preprocess.js
		gaoCallField[ sKey ] = // preprocess.js
			{ _					: null // preprocess.js
			, label				: sLabel // preprocess.js
			, nWidth			: nWidth * nWidthMultiplier // preprocess.js
			, nHeight			: nHeight // preprocess.js
			, bEditable			: bIsEditable // preprocess.js
			, type				: sType // preprocess.js
			, source			: sSource // preprocess.js
			, fScreenControl	: aoFieldFns[ 1 ]	 // dhzdhz ( bIsSelect ) ? 1 : 0 ] // preprocess.js
			} // preprocess.js
 // preprocess.js
		// Keep track of the order in which fields are defined // preprocess.js
		ganCallField.push( sKey ) // preprocess.js
	} // preprocess.js
} // preprocess.js
 // preprocess.js
 // preprocess.js
function // preprocess.js
parseCallProperties( // preprocess.js
	asCallProperty ) // preprocess.js
{ // preprocess.js
	gaoCallProperty = [] // preprocess.js
 // preprocess.js
	var	n		= asCallProperty.length // preprocess.js
	for ( var iProperty = 0; ++iProperty < n; ) { // preprocess.js
		var a			= ( asCallProperty[ iProperty ] + "||" ).split( "|" ) // preprocess.js
		var	sKey		=  trim( a[ 0 ]) // preprocess.js
		var vDefault	=  trim( a[ 1 ]) // preprocess.js
		var vInitOnCall	=  trim( a[ 2 ]) // preprocess.js
 // preprocess.js
		gaoCallProperty[ sKey ] = // preprocess.js
			{ _					: null // preprocess.js
			, vDefaultValue		: vDefault // preprocess.js
			, vInitOnCall		: vDefault // preprocess.js
			} // preprocess.js
	} // preprocess.js
} // preprocess.js
 // preprocess.js
 // preprocess.js
/** // preprocess.js
 *	Parse the state machine string table into a table of objects. // preprocess.js
 * // preprocess.js
 *	@return	object[string] // preprocess.js
 *		State machine as an object table, indexed by state name // preprocess.js
 * // preprocess.js
 *	@param	string[int]		asStateMachine // preprocess.js
 *		State machine as a string table // preprocess.js
 */ // preprocess.js
 // preprocess.js
function // preprocess.js
parseStateMachine( // preprocess.js
	asStateMachine ) // preprocess.js
{ // preprocess.js
	gaoStateMachine	= [] // preprocess.js
 // preprocess.js
	var	sState			= "" // preprocess.js
	var	sFlags			= "" // preprocess.js
	var	sTab			= "" // preprocess.js
	var	sCallDisp		= "" // preprocess.js
	var	sNextState		= "" // preprocess.js
	var	n				= asStateMachine.length // preprocess.js
	for ( var i = 0; ++i < n; ) { // preprocess.js
		var	s = trim( asStateMachine[ i ]) // preprocess.js
		// If the first four fields are missing, it means "repeat the previous state" // preprocess.js
		if ( s.charAt( 0 ) == "|" ) // preprocess.js
			s = "|||" + s // preprocess.js
		var	a = s.split( "|" ) // preprocess.js
		// Ignore malformed states // preprocess.js
		if ( a.length != 6 ) // preprocess.js
			continue // preprocess.js
 // preprocess.js
		// If this is a new state, create a new entry in the state table // preprocess.js
		if ( s.charAt( 0 ) != "|" ) { // preprocess.js
			sState		= trim( a[ 0 ]) // preprocess.js
			sFlags		= trim( a[ 1 ]).toUpperCase() // preprocess.js
			sTab		= trim( a[ 2 ]) // preprocess.js
			sCallDisp	= trim( a[ 3 ]) // preprocess.js
			oFlags		= {} // preprocess.js
			for ( var j = gsAllKnownFlags.length; j--; ) // preprocess.js
				oFlags[ "_" + gsAllKnownFlags.charAt( j )] = "" // preprocess.js
			for ( var j = sFlags.length; j--; ) { // preprocess.js
				var	s = trim( sFlags.charAt( j )) // preprocess.js
				if ( s != "" && s != "." ) // preprocess.js
					oFlags[ "_" + s ] = s // preprocess.js
			} // preprocess.js
			var	nAutocommitLevel // preprocess.js
			for ( nAutocommitLevel = 0; ; ++nAutocommitLevel ) // preprocess.js
				if ( typeof( oFlags[ "_" + nAutocommitLevel ]) != "undefined" ) // preprocess.js
					break // preprocess.js
			gaoStateMachine[ sState ] = // preprocess.js
				{ _					: null // preprocess.js
				, io				: oFlags._I + oFlags._O // preprocess.js
				, timed				: left(( oFlags._T != "" ), 1 ) // preprocess.js
				, timerReset		: left(( oFlags._R != "" ), 1 ) // preprocess.js
				, autocommitLevel	: nAutocommitLevel // preprocess.js
				, bOffHook			: left(( oFlags._H != "" ), 1 )		// TODO: Why is this a string instead of a bool? // preprocess.js
				, tab				: sTab // preprocess.js
				, disposition		: sCallDisp // preprocess.js
				, buttons			: [] // preprocess.js
				, A					: [] // preprocess.js
				, B					: [] // preprocess.js
				, M					: []				    // preprocess.js
				, X					: []				    // preprocess.js
				} // preprocess.js
		} // preprocess.js
 // preprocess.js
		var	sTrigger	= trim( a[ 4 ]) // preprocess.js
		var	sNext		= trim( a[ 5 ]) // preprocess.js
 // preprocess.js
		var	bOnlyIfFaking	= ( right( sNext, 1 ) == "#" ) // preprocess.js
		if ( bOnlyIfFaking ) // preprocess.js
			sNext = left( sNext, sNext.length - 1 ) // preprocess.js
		if ( sNext != "^" ) // preprocess.js
			sNextState = sNext // preprocess.js
		var	sType		= sTrigger.charAt( 0 )	// A[synchronous event]; B[utton press]; M[5 event] // preprocess.js
		sTrigger = sTrigger.substr( 2 ) // preprocess.js
		if ( sType == "B" ) // preprocess.js
			gaoStateMachine[ sState ].buttons.push( sTrigger ) // preprocess.js
		gaoStateMachine[ sState ][ sType ][ sTrigger ] = // preprocess.js
			{ _				: null // preprocess.js
			, state			: ( !bOnlyIfFaking || gbFakePhoneEvents ) ? sNextState : "-" // preprocess.js
			} // preprocess.js
	} // preprocess.js
 // preprocess.js
	// The first state mentioned in the state machine is the de facto initial state // preprocess.js
	for ( gsInitialState in gaoStateMachine ) // preprocess.js
		break // preprocess.js
 // preprocess.js
	// TODO: For debugging, might want to run through all transitions and confirm that they go to a real state // preprocess.js
	// TODO: For debugging, catch when a transition or a state has multiple definitions // preprocess.js
} // preprocess.js
 // preprocess.js
 // preprocess.js
function // preprocess.js
parseMapping( // preprocess.js
	sMapping, // preprocess.js
	sFrom, // preprocess.js
	sTo ) // preprocess.js
{ // preprocess.js
	if ( goMapping == null ) // preprocess.js
		goMapping = {} // preprocess.js
 // preprocess.js
	var	sFore		= sFrom + "To" + sTo // preprocess.js
	var	sBack		= sTo   + "To" + sFrom // preprocess.js
	goMapping[ sFore ] = {} // preprocess.js
	goMapping[ sBack ] = {} // preprocess.js
	var	oFore		= goMapping[ sFore ] // preprocess.js
	var	oBack		= goMapping[ sBack ] // preprocess.js
	var	aMapping	= sMapping.split( "," ) // preprocess.js
	for ( var i in aMapping ) { // preprocess.js
		var	s	= aMapping[ i ] // preprocess.js
		var	a	= ( s + "|" + s ).split( "|" ) // preprocess.js
		var	t	= trim( a[ 0 ]) // preprocess.js
		var	u	= trim( a[ 1 ]) // preprocess.js
		oFore[ t ] = u // preprocess.js
		oBack[ u ] = t // preprocess.js
	} // preprocess.js
} // preprocess.js
	
// --- panelBuilder.js ------------------------------------------------------------- 	
	
/** // panelBuilder.js
 *	Utilities for the NetSuite/M5 integration, used only by // panelBuilder.js
 *	the form builder (not the call panel Suitelet nor the // panelBuilder.js
 *	dialer Suitelet). // panelBuilder.js
 */ // panelBuilder.js
 // panelBuilder.js
/** // panelBuilder.js
 *	Create the NetSuite call panel. // panelBuilder.js
 *	@return	void // panelBuilder.js
 * // panelBuilder.js
 *	@param	nlobjRequest	request // panelBuilder.js
 *		HTML request // panelBuilder.js
 *	@param	nlobjResponse	response // panelBuilder.js
 *		HTML response // panelBuilder.js
 */ // panelBuilder.js
 // panelBuilder.js
function // panelBuilder.js
layOutPanel( // panelBuilder.js
	request, // panelBuilder.js
	response ) // panelBuilder.js
{ // panelBuilder.js
	// Initialize constants // panelBuilder.js
	initConstants() // panelBuilder.js
 // panelBuilder.js
	// URL parameters that matter to us (parameters that are not defined by NetSuite must have our custom prefix) // panelBuilder.js
	var	oParams = lookForUrlParameters( "bcode,debug,dial,pcode,script" ) // panelBuilder.js
 // panelBuilder.js
	// If the URL contains a "dial" parameter, then we're actually building the dialer, not the call panel // panelBuilder.js
	if ( oParams.dial != "" ) { // panelBuilder.js
		layOutDialer( request, response ) // panelBuilder.js
		return // panelBuilder.js
	} // panelBuilder.js
 // panelBuilder.js
	// If the URL contains a "debug" parameter, interpret it and prepare to hand it off to the panel  // panelBuilder.js
	if ( oParams.debug != "" ) { // panelBuilder.js
		gnDebug = oParams.debug // panelBuilder.js
		if ( gnDebug > 0 ) // panelBuilder.js
			gbMaintainLog = true // panelBuilder.js
	} // panelBuilder.js
 // panelBuilder.js
	// The "bcode" URL parameter allows us to execute code in the panel builder // panelBuilder.js
	//  (not the call panel), letting us do things like overriding constants // panelBuilder.js
 // panelBuilder.js
	// Attempt to execute the statement (within curly braces, to limit scope) // panelBuilder.js
	if ( gbCanInjectCode ) { // panelBuilder.js
		try { eval( oParams.bcode ) } catch ( e ) {} // panelBuilder.js
	} // panelBuilder.js
	 // panelBuilder.js
	// Which version (dev, test, release candidate) is this? // panelBuilder.js
	gnNetSuiteScriptID = oParams.script // panelBuilder.js
 // panelBuilder.js
	// Create code that will run in the panel and override certain constants // panelBuilder.js
	//  with our values of those same constants // panelBuilder.js
 // panelBuilder.js
	var	oasFnOverrideDefines	= // panelBuilder.js
		{ _		: null // panelBuilder.js
		, bra	: // panelBuilder.js
			[ null // panelBuilder.js
			, "function" // panelBuilder.js
			, "overrideDefines(" // panelBuilder.js
			, "		iStage )" // panelBuilder.js
			, "{" // panelBuilder.js
			] // panelBuilder.js
		, body	: [] // panelBuilder.js
		, ket	: // panelBuilder.js
			[ null // panelBuilder.js
			, "}" // panelBuilder.js
			] // panelBuilder.js
		} // panelBuilder.js
 // panelBuilder.js
	for ( var sOverride in // panelBuilder.js
			{ _					: null  // panelBuilder.js
			, gnDebug_1			: null // panelBuilder.js
			, gbMaintainLog_1	: null // panelBuilder.js
			}) { // panelBuilder.js
		var	a	= sOverride.split( "_" ) // panelBuilder.js
		var	sQ	= ""	// TODO: ( eval( "typeof(" + a[ 0 ] + ")" ) == "string" ) ? '"' : "" // panelBuilder.js
 // panelBuilder.js
		if ( a[ 0 ] != "" ) // panelBuilder.js
			oasFnOverrideDefines.body.push( "if ( iStage == " + a[ 1 ] + " ) " + a[ 0 ] + " = " + sQ + eval( a[ 0 ]) + sQ ) // panelBuilder.js
	} // panelBuilder.js
 // panelBuilder.js
	// The "pcode" URL parameter allows us to execute code in the call panel, // panelBuilder.js
	//  letting us do things like overriding constants // panelBuilder.js
 // panelBuilder.js
	var	oasFnInjectCode			= // panelBuilder.js
	{ _		: null // panelBuilder.js
	, bra	: // panelBuilder.js
		[ null // panelBuilder.js
		, "function" // panelBuilder.js
		, "injectCode(" // panelBuilder.js
		, "		)" // panelBuilder.js
		, "{" // panelBuilder.js
		, "		try {" // panelBuilder.js
		] // panelBuilder.js
	, body	: [] // panelBuilder.js
	, ket	: // panelBuilder.js
		[ null // panelBuilder.js
		, "		}" // panelBuilder.js
		, "		catch ( e ) {" // panelBuilder.js
		, "			popUpMessage( '" + goText.injectedCodeError + ": ' + e )" // panelBuilder.js
		, "		}" // panelBuilder.js
		, "}" // panelBuilder.js
		] // panelBuilder.js
	} // panelBuilder.js
		 // panelBuilder.js
	if ( gbCanInjectCode ) // panelBuilder.js
		oasFnInjectCode.body.push( oParams.pcode ) // panelBuilder.js
 // panelBuilder.js
	// Create the call panel as a NetSuite form // panelBuilder.js
	var oForm	= nlapiCreateForm( goText.callPanelTitle + getBuildInfo(), gbHideNavBar ) // panelBuilder.js
 // panelBuilder.js
	with ( oForm ) { // panelBuilder.js
 // panelBuilder.js
		// Insert various pieces of initialization code // panelBuilder.js
		var	sName		= getNsObjectName( "code", "init", 1 ) // panelBuilder.js
		var	sNSType		= "inlinehtml" // panelBuilder.js
	    var	sInitial	= // panelBuilder.js
	           "<script" // panelBuilder.js
	       		+ ' type="text/javascript"' // panelBuilder.js
	       		+ ">" // panelBuilder.js
 // panelBuilder.js
	       		// Hide everything in the window while we're setting it up // panelBuilder.js
	       	//	+ "\n" + "hideEverything()"		// Call fails; this function isn't defined at this point // panelBuilder.js
	    		+ "\n" + "document.body.style.opacity = 0" // panelBuilder.js
	    		+ "\n" + 'document.body.style.filter = "alpha(opacity=0)"'		// IE doesn't follow the W3C standard // panelBuilder.js
 // panelBuilder.js
	       		// Set timestamp of the JavaScript used to build this file // panelBuilder.js
	       		+ "\n" + 'var gsPanelJavaScriptBuildTime = "' + gsJavaScriptBuildTime + '"' // panelBuilder.js
 // panelBuilder.js
	       		// Function for overriding constants // panelBuilder.js
	       		+ insertCode( oasFnOverrideDefines ) // panelBuilder.js
 // panelBuilder.js
	       		// Function for injecting code // panelBuilder.js
	       		+ insertCode( oasFnInjectCode ) // panelBuilder.js
 // panelBuilder.js
	       		+ "<\/script>" // panelBuilder.js
	       		 // panelBuilder.js
/*	       		// Include the applet embedding package // panelBuilder.js
       		 // panelBuilder.js
	       		+ "<script" // panelBuilder.js
	       		+ ' type="text/javascript"' // panelBuilder.js
	       		+ ' src="' + gsAppletEmbedURL + '"' // panelBuilder.js
	       		+ ">" // panelBuilder.js
	       		+ "<\/script>" // panelBuilder.js
// */ // panelBuilder.js
 // panelBuilder.js
	    with ( addField( sName, sNSType, "" )) // panelBuilder.js
	       	setDefaultValue( sInitial ) // panelBuilder.js
 // panelBuilder.js
		// Insert applet into form // panelBuilder.js
		sName = getNsObjectName( "applet", "", 0 ) // panelBuilder.js
		sNSType = "inlinehtml" // panelBuilder.js
		// TODO: Should be able to use a relative URL; e.g., /images/java/JSjava.jar // panelBuilder.js
/*	// TODO: Handshake isn't working right, so let's just inject the applet in the panel's JavaScript, rather than in the panel builder  // panelBuilder.js
		sInitial = getHtmlToEmbedApplet( 0, gsAppletURL, gsAppletPackage + "." + gsAppletRootClass ) // panelBuilder.js
// */ // panelBuilder.js
//* // panelBuilder.js
		// Create a place for the panel itself to put the applet // panelBuilder.js
		sInitial = '<span id="appletHolder.0"></span>' // panelBuilder.js
// */ // panelBuilder.js
 // panelBuilder.js
        with ( addField( sName, sNSType, "" )) // panelBuilder.js
			setDefaultValue( sInitial ) // panelBuilder.js
 // panelBuilder.js
		// Generate our debugging controls // panelBuilder.js
		if ( gnDebug != 0 ) { // panelBuilder.js
 // panelBuilder.js
			// Initialize gadget counters // panelBuilder.js
			var	iButton = 0 // panelBuilder.js
			var	iSelect	= 0 // panelBuilder.js
 // panelBuilder.js
			// Make a pulldown of state names // panelBuilder.js
			if ( gbShowForceStateControl ) { // panelBuilder.js
				var sName	= getNsObjectName( "select", "debug", ++iSelect ) // panelBuilder.js
				var	sLabel	= "" // panelBuilder.js
				with ( addField( sName, "select", sLabel )) { // panelBuilder.js
					a = gaoStateMachine.sort // panelBuilder.js
					var	s	= "" // panelBuilder.js
					for ( var sState in gaoStateMachine ) // panelBuilder.js
						s += "|" + sState // panelBuilder.js
					var	a	= s.substr( 1 ).split( "|" ) // panelBuilder.js
					a.sort() // panelBuilder.js
					setDisplaySize( 120, 20 ) // panelBuilder.js
					addSelectOption( "", "--- " + goText.forceState + " ---" ) // panelBuilder.js
					for ( var i in a ) // panelBuilder.js
						if ( a[ i ] != "" ) // panelBuilder.js
							addSelectOption( a[ i ], a[ i ]) // panelBuilder.js
				} // panelBuilder.js
			} // panelBuilder.js
 // panelBuilder.js
			// Make a status log // panelBuilder.js
			// TODO: fix name and ID // panelBuilder.js
			if ( gbMaintainLog ) { // panelBuilder.js
				var	sName	= getNsObjectName( "log", "debug", "main" ) // panelBuilder.js
				var	sID		= getNsObjectName( "log", "debug", "mainid" ) // panelBuilder.js
				sNSType		= "inlinehtml" // panelBuilder.js
				sInitial	= // panelBuilder.js
	   	            '<textarea' // panelBuilder.js
	   	        		+ ' id="'   + sID + '"' // panelBuilder.js
//	           			+ ' name="' + sID + '"' // panelBuilder.js
	   	        		+ ' class="debugLog"' // panelBuilder.js
	   	        		+ ' readonly' // panelBuilder.js
	   	        		+ ' rows="3"' // panelBuilder.js
	   	        		+ ' cols="64"' // panelBuilder.js
	   	        		+ '>' // panelBuilder.js
	   	        		+ '</textarea>' // panelBuilder.js
		        with ( addField( sName, sNSType, "" )) // panelBuilder.js
		    		setDefaultValue( sInitial ) // panelBuilder.js
			} // panelBuilder.js
 // panelBuilder.js
			// Make a debug info window // panelBuilder.js
			var	sName	= getNsObjectName( "log", "debug", "info" ) // panelBuilder.js
			var	sID		= getNsObjectName( "log", "debug", "infoid" ) // panelBuilder.js
			sNSType		= "inlinehtml" // panelBuilder.js
	        sInitial	= // panelBuilder.js
   	            '<textarea' // panelBuilder.js
   	        		+ ' id="'   + sID + '"' // panelBuilder.js
//           			+ ' name="' + sID + '"' // panelBuilder.js
   	        		+ ' class="debugInfo"' // panelBuilder.js
   	        		+ ' readonly' // panelBuilder.js
   	        		+ ' rows="1"' // panelBuilder.js
   	        		+ ' cols="64"' // panelBuilder.js
   	        		+ '>' // panelBuilder.js
   	        		+ '</textarea>' // panelBuilder.js
	        with ( addField( sName, sNSType, "" )) // panelBuilder.js
	    		setDefaultValue( sInitial ) // panelBuilder.js
 // panelBuilder.js
			// Collect all asynchronous triggers that can trigger state transitions // panelBuilder.js
	    	if ( gbShowAsyncButtons ) { // panelBuilder.js
				var	s	= "" // panelBuilder.js
				for ( var sState in gaoStateMachine ) { // panelBuilder.js
					var	a	= gaoStateMachine[ sState ][ "A" ] // panelBuilder.js
					for ( var sTrigger in a ) // panelBuilder.js
						if ( sTrigger != "" ) // panelBuilder.js
							s += "|" + sTrigger // panelBuilder.js
				} // panelBuilder.js
				var	a	= s.substr( 1 ).split( "|" ) // panelBuilder.js
				a.sort() // panelBuilder.js
				var	sLabelPrev = ""		// Skip duplicates // panelBuilder.js
				for ( var i in a ) { // panelBuilder.js
					var	sLabel		= a[ i ] // panelBuilder.js
					if ( sLabel == sLabelPrev ) // panelBuilder.js
						continue // panelBuilder.js
					sLabelPrev = sLabel // panelBuilder.js
					var sName		= getNsObjectName( "button", "debug", ++iButton ) // panelBuilder.js
					var	sOnClick	= "fnClkdButton( -1, this )" // panelBuilder.js
					addButton( sName, sLabel, sOnClick ) // panelBuilder.js
//					setLayoutType("outsideabove", "startrow") // panelBuilder.js
//* // panelBuilder.js
					if ( iButton == 1 ) // panelBuilder.js
						setLayoutType( "outsideabove", "startrow" ) // panelBuilder.js
					else // panelBuilder.js
						setLayoutType( "outsideabove", "endrow") // panelBuilder.js
// */ // panelBuilder.js
				} // panelBuilder.js
	    	} // panelBuilder.js
		} // panelBuilder.js
 // panelBuilder.js
		var	iCall = 0				// Current call/tab (1-based) // panelBuilder.js
		for ( ; ++iCall <= gnCalls; ) { // panelBuilder.js
			var	iButton			= 0			// Current button on this tab (1-based) // panelBuilder.js
			var	sTabName		= getNsObjectName( "tab", "", iCall )  // panelBuilder.js
			addTab( sTabName, iCall )		// Each phone call tab will be named "C#", where // panelBuilder.js
											//  "#" is a number, but for now, we set the tab names // panelBuilder.js
											//  to just the number part, so that NetSuite's automatic // panelBuilder.js
											//  hotkey generator will use the number and not the "C". // panelBuilder.js
											//  When the form is initializing itself, it inserts "C". // panelBuilder.js
 // panelBuilder.js
			// Set up the fields on the tab // panelBuilder.js
			for ( var iField in ganCallField ) { // panelBuilder.js
				var	sKey	= ganCallField[ iField ] // panelBuilder.js
				if ( sKey == null ) // panelBuilder.js
					continue // panelBuilder.js
				with ( gaoCallField[ sKey ]) { // panelBuilder.js
					sNSType = type // panelBuilder.js
					sInitial = "" // panelBuilder.js
 // panelBuilder.js
					var sName	= getNsObjectName( "field", iCall, sKey ) // panelBuilder.js
 // panelBuilder.js
					switch ( type ) { // panelBuilder.js
 // panelBuilder.js
					case "button": // panelBuilder.js
						var	sID		= getNsObjectName( "button", iCall, sKey ) // panelBuilder.js
						sNSType = "inlinehtml" // panelBuilder.js
						sInitial = // panelBuilder.js
							'<input' // panelBuilder.js
			        			+ ' id="'   + sID + '"' // panelBuilder.js
			        			+ ' name="' + sID + '"' // panelBuilder.js
			        			+ ' type="button"' // panelBuilder.js
//dhz			        		+ ' class="nlinlineeditbutton actionButton"' // panelBuilder.js
			        			+ ' class="actionButton"' // panelBuilder.js
//TODO: choose			    	+ ' class="rndbuttoninpt"' // panelBuilder.js
			        			+ ' value="' + label.replace( /"/g, "\\\"" ) + '"' // panelBuilder.js
			        			+ ' onclick="fnClkdButton(' + iCall + ',this)"' // panelBuilder.js
			        			+ '>' // panelBuilder.js
			        	break // panelBuilder.js
 // panelBuilder.js
					case "list": // panelBuilder.js
						//fallthru // panelBuilder.js
 // panelBuilder.js
					case "label": // panelBuilder.js
						sNSType = "text" // panelBuilder.js
						type = "text" // panelBuilder.js
						bEditable = false // panelBuilder.js
						break // panelBuilder.js
 // panelBuilder.js
					default: // panelBuilder.js
						break // panelBuilder.js
					} // panelBuilder.js
 // panelBuilder.js
					with ( addField( sName, sNSType, label, source, sTabName )) { // panelBuilder.js
						// TODO: STRANGE! The isOneOf fails, even though it certainly returns TRUE // panelBuilder.js
//						if ( isOneOf( type, ",text,select,button" )) // panelBuilder.js
						if ( type != "textarea" ) // panelBuilder.js
							setDefaultValue( sInitial ) // panelBuilder.js
//						if ( gnDebug != 0 && sKey == "matches" ) { // panelBuilder.js
//							addSelectOption( -2, "" ) // panelBuilder.js
//	TODO: delete			for ( var j in gaoTester ) // panelBuilder.js
//								addSelectOption( j, gaoTester[ j ].name ) // panelBuilder.js
//							addSelectOption( -1, "?" ) // panelBuilder.js
//						} // panelBuilder.js
						if ( isOneOf( type, ",text,textarea,select" )) { // panelBuilder.js
							setDisplaySize( nWidth, nHeight ) // panelBuilder.js
							if ( !bEditable ) // panelBuilder.js
								for ( var j in gaReadOnlyAttribute ) // panelBuilder.js
									if ( j != 0 ) // panelBuilder.js
										setDisplayType( gaReadOnlyAttribute[ j ]) // panelBuilder.js
						} // panelBuilder.js
					} // panelBuilder.js
				} // panelBuilder.js
			} // panelBuilder.js
			// Force single-column layout by setting "start of column" flag on first debug field and first tab field // panelBuilder.js
			if ( gnDebug != 0 ) // panelBuilder.js
				if ( false )	// TODO: It's not there anymore // panelBuilder.js
					getField( getNsObjectName( "select", "debug", 1 )).setLayoutType( "normal", "startcol" ) // panelBuilder.js
			getField( getNsObjectName( "field", iCall, ganCallField[ 1 ])).setLayoutType( "normal", "startcol" ) // panelBuilder.js
		} // panelBuilder.js
 // panelBuilder.js
//* // panelBuilder.js
		var	sTabName = getNsObjectName( "tab", "", "log" ) // panelBuilder.js
		addTab( sTabName, goText.logTab ) // panelBuilder.js
 // panelBuilder.js
//		var oList = nlapiCreateList( "list title", true ) // panelBuilder.js
//		with ( oList ) { // panelBuilder.js
//			addColumn( getNsObjectName( "col", "", 1 ), "text", "Label1", "center" ) // panelBuilder.js
//			addRow({ Label1: "yow" }) // panelBuilder.js
//			response.writePage( oList ) // panelBuilder.js
//		} // panelBuilder.js
 // panelBuilder.js
//		for each entry in gaLogCols // panelBuilder.js
//			create column // panelBuilder.js
//		for ( var i = 0; ++i <= gnLogRows; ) // panelBuilder.js
//			display data in columns // panelBuilder.js
 // panelBuilder.js
/* // panelBuilder.js
		// TODO: For now, add some invisible fields just so the tab will be displayed // panelBuilder.js
		for ( var i = 15; --i; ) // panelBuilder.js
			with ( addField( getNsObjectName( "field", "log", i ), "text", " ", null, sTabName )) { // panelBuilder.js
				setDisplayType( "inline" ) // panelBuilder.js
			} // panelBuilder.js
// */ // panelBuilder.js
 // panelBuilder.js
			var	oSL	= addSubList( getNsObjectName( "list", "log", 1 ), "staticlist", goText.logTitle, getNsObjectName( "tab", "", "log" ))	// TODO: Label isn't appearing? // panelBuilder.js
			with ( oSL ) { // panelBuilder.js
 // panelBuilder.js
				// Run the saved search // panelBuilder.js
				var	aoPC	= nlapiSearchRecord( "phonecall", gsLogSearchID ) // panelBuilder.js
 // panelBuilder.js
				// Define the columns based on what the search has // panelBuilder.js
				var	aField	= // panelBuilder.js
					[ null // panelBuilder.js
					, { label : goText.logColumnDate, name : "formulatext" } // panelBuilder.js
					// We are joining through phonecall.custeventcti_call_speaking_to to contact.entityid  // panelBuilder.js
											//		name		 _		join // panelBuilder.js
					, { label : goText.logColumnSpokeTo, name : "entityid" + "_" + gsNetSuiteEventPrefix + "cti_call_speaking_to" } // panelBuilder.js
					, { label : goText.logColumnSubject, name : "title" } // panelBuilder.js
					] // panelBuilder.js
//				if ( aoPC[ 0 ] != null ) // panelBuilder.js
//					aField = aoPC[ 0 ].rawColumns  // panelBuilder.js
 // panelBuilder.js
				for ( var i in aField ) // panelBuilder.js
					if ( aField[ i ] != null ) { // panelBuilder.js
						var	a	= [ aField[ i ].label , aField[ i ].name ] // panelBuilder.js
						var	x	= ( a.length < 3 ) ? null : trim( a[ 2 ]) // panelBuilder.js
						var	y = ( a.length < 3 ) ? "text" : "select" // panelBuilder.js
						addField( trim( aField[ i ].name ), y, trim( aField[ i ].label ), x ) // panelBuilder.js
					} // panelBuilder.js
 // panelBuilder.js
				// Add the "Refresh" button // panelBuilder.js
				addRefreshButton() // panelBuilder.js
 // panelBuilder.js
				// Teach the sublist how to populate itself by running a saved search // panelBuilder.js
				setLineItemValues( aoPC )// nlapiSearchRecord( "phonecall", gsLogSearchID )) // panelBuilder.js
			} // panelBuilder.js
 // panelBuilder.js
		// Force single-column layout by setting "start of column" flag on first field // panelBuilder.js
//		getField( getNsObjectName( "field", "log", 1 )).setLayoutType( "normal", "startcol" ) // panelBuilder.js
// */ // panelBuilder.js
			 // panelBuilder.js
			 // panelBuilder.js
			 // panelBuilder.js
			/* // panelBuilder.js
			    setLineItemValues( // panelBuilder.js
			    	[ // panelBuilder.js
			    		{ // panelBuilder.js
			    		  speakingto	: "val1"  // panelBuilder.js
			    		, subject		: mid( "!qwertyuiop", 1, 2 ) // panelBuilder.js
			    		, date			: "1/2/34" // panelBuilder.js
			    		} // panelBuilder.js
			    	,	{ // panelBuilder.js
			    		  speakingto	: "val2"  // panelBuilder.js
			    		, subject		: mid( "!qwertyuiop", 2, 2 ) // panelBuilder.js
			    		, date			: "5/6/78" // panelBuilder.js
			    		} // panelBuilder.js
			    	]) // panelBuilder.js
			   // */ // panelBuilder.js
		 // panelBuilder.js
        // Set this JavaScript file to be the form's script // panelBuilder.js
		setScript( gnNetSuiteScriptID ) // panelBuilder.js
	} // panelBuilder.js
 // panelBuilder.js
	response.writePage( oForm ) // panelBuilder.js
 // panelBuilder.js
/*  dhzdhz test // panelBuilder.js
	var	oList	= nlapiCreateList( "test list", false ) // panelBuilder.js
	with ( oList ) { // panelBuilder.js
		addColumn( "idtest1", "text", "Column 1" ) // panelBuilder.js
		addColumn( "idtest2", "text", "Column 2" ) // panelBuilder.js
		addRow( { // panelBuilder.js
	          idtest2: "two" // panelBuilder.js
		        , idtest1: "one" // panelBuilder.js
		}) // panelBuilder.js
		addRow( { // panelBuilder.js
		          idtest1: "fred" // panelBuilder.js
		        , idtest2: "wilma" // panelBuilder.js
		}) // panelBuilder.js
	} // panelBuilder.js
	response.writePage( oList ) // panelBuilder.js
// */ // panelBuilder.js
} // panelBuilder.js
 // panelBuilder.js
/* // panelBuilder.js
 // panelBuilder.js
function request(request, response)  // panelBuilder.js
{  // panelBuilder.js
var form = nlapiCreateForm('myform');  // panelBuilder.js
var list = form.addSubList('results', 'staticlist', 'My Sublist', 'resultsTab');  // panelBuilder.js
list.addField("rownum","text","#");  // panelBuilder.js
  // panelBuilder.js
var i=1;  // panelBuilder.js
for(var i=1; i< 10; i++ )  // panelBuilder.js
    list.setLineItemValue("rownum", i, "val"+i);  // panelBuilder.js
  // panelBuilder.js
var count = list.getLineItemCount();  // panelBuilder.js
form.addSubmitButton("Count#:"+count);  // panelBuilder.js
  // panelBuilder.js
response.writePage( form );  // panelBuilder.js
}  // panelBuilder.js
 // panelBuilder.js
// */ // panelBuilder.js
 // panelBuilder.js
 // panelBuilder.js
/** // panelBuilder.js
 *	Initialize form builder. // panelBuilder.js
 * // panelBuilder.js
 *	@return	void // panelBuilder.js
 */ // panelBuilder.js
 // panelBuilder.js
function // panelBuilder.js
init_builder( // panelBuilder.js
	nInstance )		// Applet instance (-1 = initialize the page as a whole)  // panelBuilder.js
{ // panelBuilder.js
} // panelBuilder.js
 // panelBuilder.js
 // panelBuilder.js
function // panelBuilder.js
insertCode( // panelBuilder.js
	oasFn ) // panelBuilder.js
{ // panelBuilder.js
	var	s	= "" // panelBuilder.js
 // panelBuilder.js
	var	a	= "bra,body,ket".split( "," ) // panelBuilder.js
	for ( var i in a ) { // panelBuilder.js
		var	o	= oasFn[ a[ i ]] // panelBuilder.js
		for ( var j in o ) // panelBuilder.js
			if ( o[ j ] != null ) // panelBuilder.js
				s += "\n" + o[ j ] // panelBuilder.js
	} // panelBuilder.js
 // panelBuilder.js
	return ( s ) // panelBuilder.js
} // panelBuilder.js
 // panelBuilder.js
 // panelBuilder.js
var createLayout = layOutPanel	// TODO: Temporary // panelBuilder.js
	
// --- panel.js ------------------------------------------------------------- 	
	
/** // panel.js
 *	The call panel Suitelet for the NetSuite/M5 integration. // panel.js
 */ // panel.js
 // panel.js
 // panel.js
/** // panel.js
 * When entering or exiting certain states, perform certain functions. // panel.js
 */ // panel.js
 // panel.js
var	gofStateTransition	= // panel.js
	{ _					: null // panel.js
 // panel.js
	, BEFORE_ENTER :	// For all states (runs before any state-specific // panel.js
						// function) // panel.js
		function ( // panel.js
			iCall, // panel.js
			sState )	// The state we are entering // panel.js
		{ // panel.js
			// Set the call disposition // panel.js
			var	s	= gaoStateMachine[ sState ].disposition // panel.js
			if ( s != "{unchg}" ) // panel.js
				setCallInfo( iCall, "disposition", goCallDisposition.byValue[ s ]) // panel.js
 // panel.js
			// Set the call direction // panel.js
			var	sDirection		= "" // panel.js
			switch ( gaoStateMachine[ sState ].io ) { // panel.js
			case "I":	sDirection = goCallDirectionIndex.rx	; break		// In only // panel.js
			case "O":	sDirection = goCallDirectionIndex.tx	; break		// Out only // panel.js
			case "IO":	sDirection = null						; break		// Unchanged // panel.js
			case "":	sDirection = ""							; break		// No call // panel.js
			default:											; break // panel.js
			} // panel.js
			if ( sDirection != null ) // panel.js
				setCallInfo( iCall, "direction", sDirection ) // panel.js
 // panel.js
			// Set the tab appearance // panel.js
			setCallInfo( iCall, "tab", gaoStateMachine[ sState ].tab ) // panel.js
			 // panel.js
			// Enable just the buttons defined for this state, in the order in // panel.js
			// which they appear in the state table // panel.js
			hideButtons( iCall ) // panel.js
			var	iButton = 0 // panel.js
			var	a = gaoStateMachine[ sState ].buttons // panel.js
			var	n = a.length // panel.js
			for ( var i = 0; i < n; ++i ) { // panel.js
				var	s = a[ i ] // panel.js
				var	oButton	= getNsObject( "button", iCall, "_" + ++iButton ) // panel.js
				oButton.value = s // panel.js
				oButton.style.visibility = ( s == "" ) ? "hidden" : "visible" // panel.js
			} // panel.js
		} // panel.js
 // panel.js
	, AFTER_ENTER :		// For all states (runs after any state-specific // panel.js
						// function) // panel.js
		function ( // panel.js
			iCall, // panel.js
			sState )	// The state we are entering // panel.js
		{ // panel.js
//		popUpDebug("entering " + sState) // dhzdhz2 // panel.js
			// Set the off-hook status // panel.js
			var	bWasOffHook	= ( left( getCallInfo( iCall, "bOffHook" ), 1 ) == "t" ) // panel.js
			var	bIsOffHook	= ( gaoStateMachine[ sState ].bOffHook == "t" ) // panel.js
// kch			popUpDebug( "dhz off hook w=" + bWasOffHook + ", i=" + bIsOffHook + "..." + sState + " " + getCallInfo( iCall, "bOffHook" )) // panel.js
			setCallInfo( iCall, "bOffHook", String( bIsOffHook )) // panel.js
 // panel.js
			// If the call is just ending, track it // panel.js
			if ( bWasOffHook && !bIsOffHook ) { // panel.js
				var	nNow	= nowSec() // panel.js
				setCallInfo( iCall, // panel.js
					{ _				: null // panel.js
					, secCallEnd	: nNow // panel.js
					, duration		: nNow - getCallInfo( iCall, "secCallStart" ) // panel.js
					, bOnCall		: "false" // panel.js
					}) // panel.js
			} // panel.js
		} // panel.js
 // panel.js
	, BEFORE_EXIT :		// For all states (runs before any state-specific // panel.js
						// function) // panel.js
		function ( // panel.js
			iCall, // panel.js
			sState )	// The state we are exiting // panel.js
		{ // panel.js
			// nlapiSetFieldDisabled( getNsObjectName( "field", iCall, "contact" // panel.js
			// ), !bIdle ) // dhzdhz Should always be able to edit contact // panel.js
			nlapiSetFieldDisabled( getNsObjectName( "field", iCall, "number"  ), true ) // panel.js
		} // panel.js
 // panel.js
	, AFTER_EXIT :		// For all states (runs after any state-specific // panel.js
						// function) // panel.js
		function ( // panel.js
			iCall, // panel.js
			sState )	// The state we are exiting // panel.js
		{ // panel.js
		} // panel.js
 // panel.js
	, Idle_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Clear the slot // panel.js
			setCallInfo( iCall, goCallInfoInit.Idle ) // panel.js
 // panel.js
			// Clear certain elements of the call // panel.js
			var	gsClear	= "comments,company,contact,disposition,duration,matches,number,priority,result,speaking_to,status,subject"  // panel.js
			resetCallInfo( iCall, gsClear.split( "," )) // panel.js
			setCallInfo( iCall, "title", "" )	// So Title doesn't show "null" in IE. TODO: Better way to do this is to fix setCallInfo()  // panel.js
 // panel.js
//			displayCallInfo( iCall ) // panel.js
 // panel.js
			// Allow him to edit Number field // panel.js
			nlapiSetFieldDisabled( getNsObjectName( "field", iCall, "number"  ), false ) // panel.js
			// TODO: Would be nice to put focus in Number field automatically, but this doesn't work // panel.js
			// Set focus to the "Number" field on tab 1 // panel.js
			// getNsObject( "field", 1, "number", "_fs" ).focus() // panel.js
 // panel.js
			// TODO: To put focus in Number field manually, why do we first have to click somewhere else (e.g., in comments field)? // panel.js
		} // panel.js
 // panel.js
	, Dialing_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Start call timer // panel.js
			setCallInfo( iCall, "secCallStart", nowSec() - getCallInfo( iCall, "duration" )) // panel.js
		} // panel.js
 // panel.js
	, Ringing_In_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Start call timer // panel.js
			setCallInfo( iCall, "secCallStart", nowSec() - getCallInfo( iCall, "duration" )) // panel.js
 // panel.js
			// Start bouncing the tab // panel.js
			bounce( getNsObjectName( "tab", "", iCall, "txt" ), -1, goRingBounce.nAmplitude, goRingBounce.nHz ) // panel.js
		} // panel.js
 // panel.js
	, Ringing_In_EXIT : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Stop bouncing the tab // panel.js
			bounce( getNsObjectName( "tab", "", iCall, "txt" ), 0 ) // panel.js
		} // panel.js
 // panel.js
	, Going_on_Hold_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// If call timer is not running (because we started the call panel // panel.js
			// with a call already on hold), start it // panel.js
			if ( nz( getCallInfo( iCall, "secCallStart" ), 0 ) == 0 ) // panel.js
				setCallInfo( iCall, "secCallStart", nowSec() - getCallInfo( iCall, "duration" )) // panel.js
 // panel.js
			// If we're jumping from Idle into a call (because we started the // panel.js
			// call panel with a call already in progress) // panel.js
			if ( getCallInfo( iCall, "statePrev" ) == "Idle" ) // panel.js
				// Update our state // panel.js
				setCallInfo( iCall, // panel.js
					{ _				: null // panel.js
					, statePrev		: "On Call" // panel.js
					, disposition	: goCallDisposition.byValue[ "Complete" ] // panel.js
					}) // panel.js
 // panel.js
			// Lastly, note that we're on a call and on hold, and start hold // panel.js
			// timer // panel.js
			setCallInfo( iCall, // panel.js
				{ _					: null // panel.js
				, bOnCall			: "true" // panel.js
				, bOnHold			: "true"	// dhzdhz fake booleans as // panel.js
												// strings // panel.js
				, secHoldStart		: nowSec() // panel.js
				}) // panel.js
		} // panel.js
 // panel.js
	, Going_on_Hold_EXIT : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Accumulate hold time (do it now and restart again when entering Hold because we can also enter Hold on a call panel restart)  // panel.js
			setCallInfo( iCall, // panel.js
				{ _					: null // panel.js
				, bOnHold			: "false" // panel.js
				, secHoldTotal		: getCallInfo( iCall, "secHoldTotal" ) + ( nowSec() - getCallInfo( iCall, "secHoldStart" )) // panel.js
				}) // panel.js
		} // panel.js
 // panel.js
	, Hold_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
		// Note that we're on a call and on hold, and start hold timer (seems redundant, but we might be coming in from a call panel restart) // panel.js
			setCallInfo( iCall, // panel.js
				{ _					: null // panel.js
				, bOnCall			: "true" // panel.js
				, bOnHold			: "true" // panel.js
				, secHoldStart		: nowSec() // panel.js
			}) // panel.js
		} // panel.js
 // panel.js
	, Hold_EXIT : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Accumulate hold time (do it now instead of only at the end of Resuming because we might be going to some other state)  // panel.js
			setCallInfo( iCall, // panel.js
				{ _					: null // panel.js
				, bOnHold			: "false" // panel.js
				, secHoldTotal		: getCallInfo( iCall, "secHoldTotal" ) + ( nowSec() - getCallInfo( iCall, "secHoldStart" )) // panel.js
				}) // panel.js
		} // panel.js
 // panel.js
	, Resuming_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Restart hold time counter  // panel.js
			setCallInfo( iCall, // panel.js
				{ _					: null // panel.js
				, bOnHold			: "true" // panel.js
				, secHoldStart		: nowSec() // panel.js
				}) // panel.js
		} // panel.js
 // panel.js
	, Resuming_EXIT : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Accumulate hold time // panel.js
			setCallInfo( iCall, // panel.js
				{ _					: null // panel.js
				, bOnHold			: "false" // panel.js
				, secHoldTotal		: getCallInfo( iCall, "secHoldTotal" ) + ( nowSec() - getCallInfo( iCall, "secHoldStart" )) // panel.js
				}) // panel.js
		} // panel.js
 // panel.js
	, On_Call_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// If we're jumping from Idle into a call (because we started the // panel.js
			// call panel with a call already in progress) // panel.js
			if ( getCallInfo( iCall, "statePrev" ) == "Idle" ) // panel.js
				// Update our state // panel.js
				setCallInfo( iCall, // panel.js
					{ _				: null // panel.js
					, statePrev		: "On Call" // panel.js
					, disposition	: goCallDisposition.byValue[ "Complete" ] // panel.js
					}) // panel.js
 // panel.js
			// Lastly, note that we're on a call // panel.js
			setCallInfo( iCall, "bOnCall", "true" ) // panel.js
		} // panel.js
 // panel.js
	, Ignored_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Prepend the word "Ignored" to the subject // panel.js
			var	s	= getCallInfo( iCall, "subject" ) // panel.js
			setCallInfo( iCall, "subject", goText.ignored + " " + left( s, 1 ).toLowerCase() + mid( s, 1 )) // panel.js
		} // panel.js
 // panel.js
	, Missed_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Prepend the word "Missed" to the subject // panel.js
			var	s	= getCallInfo( iCall, "subject" ) // panel.js
			setCallInfo( iCall, "subject", goText.missed + " " + left( s, 1 ).toLowerCase() + mid( s, 1 )) // panel.js
		} // panel.js
 // panel.js
	, Store_ENTER : // panel.js
		function ( // panel.js
			iCall ) // panel.js
		{ // panel.js
			// Store phonecall record // panel.js
			updatePhoneCallRecord( iCall ) // panel.js
 // panel.js
			// If desired, update the call log(s) // panel.js
			updateCallLog( iCall ) // panel.js
		} // panel.js
	} // panel.js
 // panel.js
 // panel.js
/** // panel.js
 * Set a phone call's state, regardless of its current state. If the new state // panel.js
 * has a transition with a null trigger, immediately perform that transition as // panel.js
 * well, ad infinitum. // panel.js
 *  // panel.js
 * @return void // panel.js
 *  // panel.js
 * @param int // panel.js
 *            iCall Phone call // panel.js
 * @param string // panel.js
 *            sState New state for that call ("-" = remain in current state) // panel.js
 */ // panel.js
 // panel.js
function // panel.js
setState( // panel.js
	iCall, // panel.js
	sState ) // panel.js
{ // panel.js
	// Get current state (unless we're just starting up) // panel.js
	var	sStateFrom	= getCallInfo( iCall, "state" ) // panel.js
	if ( sStateFrom == null ) // panel.js
		sStateFrom = "None" // panel.js
 // panel.js
	// A reference to the previous state means the state before the one we're // panel.js
	// exiting // panel.js
	if ( sState == "{prev}" ) // panel.js
		sState = getCallInfo( iCall, "statePrev" ) // panel.js
 // panel.js
	// If transition keeps us in this same state, do nothing // panel.js
	if ( sState == "-" || sStateFrom == sState ) // panel.js
		return // panel.js
 // panel.js
	var	sStateShort		= sState    .replace( / /g, "_" ) // panel.js
	var	sStateFromShort	= sStateFrom.replace( / /g, "_" ) // panel.js
 // panel.js
	// Note the call's previous state // panel.js
	setCallInfo( iCall, "statePrev", sStateFrom ) // panel.js
 // panel.js
	// Perform operations specifically related to exiting the old state // panel.js
	gofStateTransition.BEFORE_EXIT( iCall, sStateFrom ) // panel.js
	callFuncIfExists( gofStateTransition[ sStateFromShort + "_EXIT" ], iCall ) // panel.js
	gofStateTransition.AFTER_EXIT( iCall, sStateFrom ) // panel.js
 // panel.js
	// Perform operations specifically related to entering the new state // panel.js
	gofStateTransition.BEFORE_ENTER( iCall, sState ) // panel.js
	callFuncIfExists( gofStateTransition[ sStateShort + "_ENTER" ], iCall ) // panel.js
	gofStateTransition.AFTER_ENTER( iCall, sState ) // panel.js
 // panel.js
	// Set the call's new state // panel.js
	setCallInfo( iCall, "state", sState ) // panel.js
 // panel.js
 // panel.js
/* // panel.js
 * // TODO: Do a similar thing with the hold timer -- will need additional flags // // panel.js
 * If the new state asks for the timer to be reset, then reset it if ( // panel.js
 * gaoStateMachine[ sState ].timerReset == "t" ) setCallInfo( iCall, "timer", 0 ) // // panel.js
 * TODO: Unused else { // Otherwise, if the new state defines a timer and the // panel.js
 * old state did not, start the timer var s = gaoStateMachine[ sState ].timed + // panel.js
 * gaoStateMachine[ sOldState ].timed if ( s == "tf" ) setCallInfo( iCall, { _ : // panel.js
 * null , secCallStart : nowSec() , bOnCall : "true" }) // Otherwise, if the // panel.js
 * new state does not define a timer and the old state did, stop the timer else // panel.js
 * if ( s == "ft" ) setCallInfo( iCall, "bOnCall", "false" ) } // panel.js
 */ // panel.js
 // panel.js
	// If the new state has a null trigger, follow that transition immediately // panel.js
	changeState( iCall, "X", "X" ) // panel.js
} // panel.js
 // panel.js
 // panel.js
/** // panel.js
 * Perform a state transition on a phone call, going from its current state to // panel.js
 * the new state specified by the given trigger. If no such trigger is defined // panel.js
 * for the current state of the call, do nothing. // panel.js
 *  // panel.js
 * @return void // panel.js
 *  // panel.js
 * @param int // panel.js
 *            iCall Phone call // panel.js
 * @param string // panel.js
 *            sState New state for that call // panel.js
 */ // panel.js
 // panel.js
function // panel.js
changeState( // panel.js
	iCall, // panel.js
	sType, // panel.js
	sTrigger ) // panel.js
{ // panel.js
	// Get current state of this call // panel.js
	var	sState	= getCallInfo( iCall, "state" ) // panel.js
 // panel.js
	// If the given trigger is not defined on the current state, just stay where // panel.js
	// we are // panel.js
	var	oTrigger	= gaoStateMachine[ sState ][ sType ][ sTrigger ] // panel.js
	if ( typeof( oTrigger ) == "undefined" || oTrigger == null ) { 	// TODO: // panel.js
																	// Make a // panel.js
																	// function // panel.js
																	// that does // panel.js
																	// this // panel.js
																	// undefined/null // panel.js
																	// comparison // panel.js
		if ( isOneOf( sTrigger, "AB" )) // panel.js
			logme( 1, "Call #" + iCall + ": Trigger " + sTrigger + ' not defined for state "' + sState + '"' ) // panel.js
		return // panel.js
	} // panel.js
 // panel.js
	// Execute the trigger // panel.js
	setState( iCall, oTrigger.state ) // panel.js
} // panel.js
 // panel.js
 // panel.js
/** // panel.js
 * Hook for the "field changed" function. Doing so allows us to capture // panel.js
 * selection changes. // panel.js
 *  // panel.js
 * This will only be called when the user (rather than the program) changes a // panel.js
 * field's value, thanks to the firefieldchanged parameter of // panel.js
 * nlapiSetFieldValue/Text. // panel.js
 *  // panel.js
 * @return void // panel.js
 *  // panel.js
 * @param Object // panel.js
 *            type ?dhz? // panel.js
 * @param string // panel.js
 *            fldnam Name of the field HTML object // panel.js
 * @param int // panel.js
 *            linenum ?dhz? // panel.js
 * @param int // panel.js
 *            column ?dhz? // panel.js
 * @param Object // panel.js
 *            optionswin ?dhz? // panel.js
 */ // panel.js
 // panel.js
function // panel.js
mynlapiFieldChanged( // panel.js
	type, // panel.js
	fldnam, // panel.js
	linenum, // panel.js
	column, // panel.js
	optionswin ) // panel.js
{ // panel.js
	// Perform standard behavior // panel.js
	chainHookedFunction( arguments.callee, null, type, fldnam, linenum, column, optionswin ) // panel.js
 // panel.js
	/* // panel.js
	 * Process the field, but not inside this thread, because if our processing // panel.js
	 * happens to change another screen field (e.g., via nlapiSetFieldValue), // panel.js
	 * that will trigger a second call to this function, and if the nested call // panel.js
	 * makes a call to certain NetSuite functions (e.g., nlapiLoadRecord), those // panel.js
	 * functions will attempt to crawl the stack and will be confused by the two // panel.js
	 * occurrences of mynlapiFieldChanged, resulting in an infinite loop. // panel.js
	 */ // panel.js
 // panel.js
	setTimeout( 'tryCatchLog("' + 'mynlapiFieldChanged_2(\\"' + type + '\\",\\"' + fldnam + '\\")' + '")', 10 ) // panel.js
} // panel.js
 // panel.js
 // panel.js
function // panel.js
mynlapiFieldChanged_2( // panel.js
	type, // panel.js
	fldnam ) // panel.js
{ // panel.js
	// This is the field's name, not its ID // panel.js
	var o				= getNsObjectByName( fldnam ) // panel.js
	var	aNamePart		= fldnam.split( "_" ) // panel.js
	var	sValue			= nlapiGetFieldValue( fldnam ) // panel.js
	var	sVisibleText	= nlapiGetFieldText(  fldnam )	// For pulldowns, the // panel.js
														// value is a code; it's // panel.js
														// not generally the same as the visible text // panel.js
	if ( sVisibleText == null ) // panel.js
		sVisibleText = sValue // panel.js
 // panel.js
	if ( gnDebug != 0 ) { // panel.js
 // panel.js
		// If this is the debugging "User" selector // panel.js
		if ( fldnam == getNsObjectName( "select", "debug", 1 )) { // panel.js
			if ( sValue != "" ) { // panel.js
				// TODO: Tear down any previous subscribe // panel.js
				// Use the phone number and password to log him into the applet // panel.js
				javaScriptCallsOutToJava( 0, "login", sValue.replace( /\|/, "," )) // panel.js
				// Request a "subscribe" // panel.js
				doM5Command( "subscribe" ) // panel.js
			} // panel.js
 // panel.js
			return // panel.js
		} // panel.js
	 // panel.js
		// If this is the debugging "State" selector, display the new state on // panel.js
		// the tab // panel.js
		if ( fldnam == getNsObjectName( "select", "debug", 2 )) { // panel.js
			if ( sValue != "" ) { // panel.js
				var	sStatePrev	= getCallInfo( giCurrentCall, "state" ) // panel.js
				setCallInfo( giCurrentCall, // panel.js
					{ _			: null // panel.js
					, statePrev	: sStatePrev // panel.js
					, state		: sValue // panel.js
					}) // panel.js
				displayCallInfo() // panel.js
			} // panel.js
 // panel.js
			return // panel.js
		} // panel.js
	} // panel.js
 // panel.js
	var	sFieldType	=  aNamePart[ 1 ] // panel.js
	var	iCall		= +aNamePart[ 2 ]		// dhzdhz will this fail on the log // panel.js
											// page or for a debug field? // panel.js
	var	sFieldID	=  aNamePart[ 3 ] // panel.js
 // panel.js
	if ( sFieldType == "field" ) { // panel.js
		// Save the field's value // panel.js
		setCallInfo( iCall, sFieldID, sValue ) // panel.js
 // panel.js
/* // panel.js
 	// TODO: Need to update this every time he types something in the empty field or clears the non-empty field // panel.js
		// If this was the Number field and we're in the Idle state, activate or deactivate the "Dial Out" button, // panel.js
		//  depending on whether the field now contains anything // panel.js
		if ( sFieldID == "number" && getCallInfo( iCall, "state" ) == "Idle" ) // panel.js
			getNsObject( "button", iCall, "_" + 1 ).style.visibility = ( sValue == "" ) ? "hidden" : "visible" // panel.js
// */ // panel.js
 // panel.js
		// If the "Speaking To" field has changed to a non-empty value but the "Number" field is empty // panel.js
		//  (ignoring spaces), look up the contact named in "Speaking To" and copy his "Main Phone" value // panel.js
		//  (if any) into the "Number" field // panel.js
		if ( sFieldID == "speakingto" ) { // panel.js
			var	sNumberFieldName	= getNsObjectName( "field", iCall, "number" ) // panel.js
			var	fnGetSetNumber		= gaoCallField[ "number" ].fScreenControl // panel.js
			if ( fnGetSetNumber.get( sNumberFieldName ).replace( / /g, "" ) == "" ) { // panel.js
				var	oContact = nlapiLoadRecord( "contact", sValue ) // panel.js
				if ( oContact != null ) // panel.js
					fnGetSetNumber.set( sNumberFieldName, oContact.getFieldValue( "phone" )) // panel.js
			} // panel.js
		} // panel.js
	} // panel.js
} // panel.js
 // panel.js
 // panel.js
/*		// PROBABLY NOT NEEDED // panel.js
function // panel.js
refreshCallLog( // panel.js
	iCall ) // panel.js
{ // panel.js
	return // panel.js
	var	oFilter	= new nlobjSearchFilter( "phone", null, "is", "4155551212") // panel.js
	// Saved search // panel.js
	// gsLogSearchID // panel.js
	var	sColumns	= "custeventcti_call_speaking_to,title,startdate,starttime".split( "," ) // panel.js
	var	columns	= [] // panel.js
	for ( var ii in sColumns ) // panel.js
		columns.push( new nlobjSearchColumn( sColumns[ ii ])) // panel.js
	var	aoPC	= nlapiSearchRecord( "phonecall", gsLogSearchID ) //null, oFilter, columns ) // panel.js
	// TODO: Sort entries; get rid of sorting arrow in column headers // panel.js
	var	aa	= [] // panel.js
	for ( var ee in aoPC ) { // panel.js
		aa.push( // panel.js
				{ date			: gsLogLinkBra.replace( /\{ID\}/g, aoPC[ ee ].getId() ) + formatDateTime( new Date( aoPC[ ee ].getValue( "startdate" )), "m/d" ) + gsLogLinkKet // panel.js
				, speakingto	: aoPC[ ee ].getValue( "custeventcti_call_speaking_to" ) // panel.js
				, subject		: "overload " +aoPC[ ee ].getValue( "title" )   // panel.js
				}) // panel.js
 // panel.js
		if ( ee == gnLogRows - 1 ) // panel.js
			break // panel.js
	} // panel.js
	getNsObject( "list", iCall, "1" ).setLineItemValues( aa ) // panel.js
} // panel.js
// */ // panel.js
	
// --- panelInit.js ------------------------------------------------------------- 	
	
/** // panelInit.js
 *	Initialize the call panel. // panelInit.js
 */ // panelInit.js
 // panelInit.js
 // panelInit.js
/** // panelInit.js
 *	Initialize call panel Suitelet. // panelInit.js
 * // panelInit.js
 *	@return	void // panelInit.js
 */ // panelInit.js
 // panelInit.js
function // panelInit.js
init_panel( // panelInit.js
	nInstance )		// Applet instance (-1 = initialize the page as a whole)  // panelInit.js
{ // panelInit.js
	switch ( nInstance ) { // panelInit.js
 // panelInit.js
	case -1: // panelInit.js
		// Run any injected code // panelInit.js
		if ( gbCanInjectCode ) // panelInit.js
			injectCode() // panelInit.js
 // panelInit.js
		// Hook NetSuite's "page init" function // panelInit.js
		hookFunction( "page_init", "mypage_init" ) // panelInit.js
 // panelInit.js
		// In each tab, collect all the action buttons onto a single row // panelInit.js
		putActionButtonsOnOneRow() // panelInit.js
 // panelInit.js
		// In each tab, highjack the code that launches the "New Contact" window // panelInit.js
		highjackNewContactLauncher() // panelInit.js
	 // panelInit.js
		// Inject applet into the space the panel builder created for it // panelInit.js
		var	sInitial = getHtmlToEmbedApplet( 0, gsAppletURL, gsAppletPackage + "." + gsAppletRootClass ) // panelInit.js
//		popUpDebug(sInitial) // panelInit.js
		// TODO: This fails when we set innerHTML, but it works when we just do a document.write // panelInit.js
//		element( 0, "appletHolder" ).innerHTML = sInitial // panelInit.js
		document.write( sInitial ) // panelInit.js
 // panelInit.js
		// If any pulldown is too wide, narrow it // panelInit.js
		var	a	= "speakingto".split( "," ) // panelInit.js
		for ( var i in a ) // panelInit.js
			if ( getNsObject( "field", 1, a[ i ], "_display" ) != null ) // panelInit.js
				for ( var iCall = gnCalls + 1; --iCall; ) // panelInit.js
					getNsObject( "field", iCall, a[ i ], "_display" ).style.width = gnPulldownWidth // panelInit.js
 // panelInit.js
		// If the screen is narrower than we like, say so // panelInit.js
		if ( screen.width < gnMinRecScreenWidth ) // panelInit.js
			popUpMessage( goText.screenTooNarrow ) // panelInit.js
		break // panelInit.js
 // panelInit.js
	default: // panelInit.js
		break // panelInit.js
	} // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
// Suppress all but the top N lines of the log // panelInit.js
 // panelInit.js
/* // panelInit.js
function // panelInit.js
dhzshh() // panelInit.js
{ // panelInit.js
	// Get the log table // panelInit.js
	var o = getNsObjectById( "custpagem5_list_log_1_splits" ) // panelInit.js
		// Get the TBODY // panelInit.js
		.firstChild // panelInit.js
		// Go to the first row, which is the column headers // panelInit.js
		.firstChild // panelInit.js
		// And skip it // panelInit.js
		.nextSibling // panelInit.js
	for ( var i = gnLogRows; o; o = o.nextSibling ) { // panelInit.js
		// Every row is followed by a sibling that is not a row // TODO: So then what is it? // panelInit.js
		if ( typeof( o.id ) == "undefined" )  // panelInit.js
			continue // panelInit.js
		if ( --i < 0 ) // panelInit.js
			o.style.visibility = "hidden" // panelInit.js
	} // panelInit.js
} // panelInit.js
*/ // panelInit.js
 // panelInit.js
 // panelInit.js
// TODO: Bad function name // panelInit.js
 // panelInit.js
function // panelInit.js
tryToGetAppletVersion( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	var sVersion	= javaScriptCallsOutToJava( 0, "get version" ) // panelInit.js
	if ( typeof( sVersion ) != "string" ) { // panelInit.js
		// TODO: Should be allowed to use tryCatchLog here, but we're running into bug #87 // panelInit.js
//		setTimeout( 'tryCatchLog("' + "tryToGetAppletVersion()" + '")', 250 ) // panelInit.js
		setTimeout( "tryToGetAppletVersion()", 250 ) // panelInit.js
		return // panelInit.js
	} // panelInit.js
 // panelInit.js
//	popUpDebug( "Applet is active; version = " + sVersion )	// TODO: Show this somewhere // panelInit.js
 // panelInit.js
	// Color the background to show that the applet is alive // panelInit.js
	document.body.style.backgroundColor = getCSSRule( ".suitelet" ).style.backgroundColor // panelInit.js
 // panelInit.js
	// Initialize applet // panelInit.js
	javaScriptCallsOutToJava( 0, "init", "" ) // panelInit.js
 // panelInit.js
	// Look up the current user // panelInit.js
	var	oUser	= getUsersM5Info( nlapiGetUser() )	// TODO: Returns -4 on error // panelInit.js
	if ( oUser == null ) // panelInit.js
		return // panelInit.js
 // panelInit.js
	// Complain if phone is disabled // panelInit.js
	if ( oUser.enabled != "T" ) { // panelInit.js
	   	 logme( 1, "CTI Phone Enabled is false for user " + oUser.nUserID ) // panelInit.js
	   	 popUpMessage( goText.phoneDisabled, null, goText.contactSysAdmin ) // panelInit.js
	   	 return // panelInit.js
	} // panelInit.js
 // panelInit.js
	// Log in // panelInit.js
	logme( 1, "Logging in user " + oUser.userID + " with phone number " + formatPhone( oUser.phone ))// TODO: temporary // panelInit.js
	javaScriptCallsOutToJava( 0, "login", oUser.phone + "," + oUser.password ) // panelInit.js
 // panelInit.js
	// Insert the phone logo // panelInit.js
	insertLogo( false ) // panelInit.js
 // panelInit.js
	// Request a "subscribe" // panelInit.js
	doM5Command( "subscribe" ) // panelInit.js
	 // panelInit.js
	// Get state of phone // panelInit.js
	doM5Command( "listCalls", "Arguments" ) // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
/** // panelInit.js
 *	Move and resize the call panel. // panelInit.js
 * // panelInit.js
 *	@return	void // panelInit.js
 */ // panelInit.js
 // panelInit.js
function // panelInit.js
moveAndResizePanel( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	var l = ganPanelMargin[ 0 ] // panelInit.js
	var t = ganPanelMargin[ 1 ] // panelInit.js
	var r = ( window.screen.availWidth  - ganPanelDim[ 0 ]) - l // panelInit.js
	var b = ( window.screen.availHeight - ganPanelDim[ 1 ]) - t // panelInit.js
	 // panelInit.js
	var	s = "ul" // panelInit.js
	var	anPanelPos	= null // panelInit.js
	if ( gbPromptForPanelPos ) // panelInit.js
		s = prompt( goText.movePrompt, s ) // panelInit.js
 // panelInit.js
	switch ( s.toLowerCase() ) { // panelInit.js
	default: // panelInit.js
	case "ul":	anPanelPos = [ l, t ]	; break // panelInit.js
	case "ur":	anPanelPos = [ r, t ]	; break // panelInit.js
	case "ll":	anPanelPos = [ l, b ]	; break // panelInit.js
	case "lr":	anPanelPos = [ r, b ]	; break // panelInit.js
	} // panelInit.js
 // panelInit.js
	window.moveTo( anPanelPos[ 0 ], anPanelPos[ 1 ]) // panelInit.js
 // panelInit.js
	return	// dhzdhz2 FOR NOW, DOON'T RESIZE // panelInit.js
 // panelInit.js
	// TODO: Google Chrome does not support resizeTo and moveTo in top-level windows // panelInit.js
 // panelInit.js
//	popUpDebug(getClientAreaSize())	// dhzdhz2 // panelInit.js
	window.resizeTo( ganPanelDim[ 0 ], ganPanelDim[ 1 ]) // panelInit.js
	var	a	= getClientAreaSize() // panelInit.js
//	popUpDebug(a)	// dhzdhz2 // panelInit.js
	window.resizeBy( ganPanelDim[ 0 ] - a[ 0 ], ganPanelDim[ 1 ] - a[ 1 ]) // panelInit.js
//	popUpDebug(getClientAreaSize())	// dhzdhz2 // panelInit.js
	window.resizeBy( ganPanelDim[ 0 ] - a[ 0 ], ganPanelDim[ 1 ] - a[ 1 ]) // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
function // panelInit.js
mypage_init( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	if ( gnDebug > 0 && gsJavaScriptBuildTime != gsPanelJavaScriptBuildTime ) { // panelInit.js
		popUpMessage( goText.jsMismatch, null, null ) // panelInit.js
		return // panelInit.js
	} // panelInit.js
 // panelInit.js
	// Give the browser a chance to show the changed window, then continue // panelInit.js
	setTimeout( 'tryCatchLog("' + "mypage_init_2()" + '")', 10 ) // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
function // panelInit.js
mypage_init_2( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	// Perform standard behavior // panelInit.js
	chainHookedFunction( arguments.callee, "page_init()" ) // panelInit.js
 // panelInit.js
	// Hide all the buttons while we're initializing, just to be tidy // panelInit.js
	hideButtons() // panelInit.js
 // panelInit.js
	// Insert the phone logo, dimmed // panelInit.js
	insertLogo( true ) // panelInit.js
 // panelInit.js
	// If we're not debugging, permanently hide some NetSuite UI elements // panelInit.js
	if ( gnDebug == 0 ) // panelInit.js
		hideNetSuiteUiGadgets() // panelInit.js
 // panelInit.js
	// Insert a "position: absolute" style into the <div> that contains the tabs; // panelInit.js
	//  without this, the bounce() code will not work // panelInit.js
	findElementByID( "div__body" ).style.position = "absolute" // panelInit.js
 // panelInit.js
	// Initialize constants // panelInit.js
	initConstants( nlapiGetFieldValue( "script" )) // panelInit.js
 // panelInit.js
	// Hook NetSuite's "clicked on a tab" function // panelInit.js
	hookFunction( "ShowTab", "myShowTab" ) // panelInit.js
 // panelInit.js
	// Hook NetSuite's "field changed" function // panelInit.js
	hookFunction( "nlapiFieldChanged", "mynlapiFieldChanged" ) // panelInit.js
 // panelInit.js
	// Add style sheet rules // panelInit.js
	addStyleSheetRules() // panelInit.js
 // panelInit.js
/* // panelInit.js
	// Color the background gray, to show that the applet is not yet known to be alive // panelInit.js
	document.body.style.backgroundColor = getCSSRule( ".suiteletInactive" ).style.backgroundColor // panelInit.js
// */ // panelInit.js
 // panelInit.js
	// Create an option list for the priority field (to make it always available) // panelInit.js
	var	aaPriority	= [] // panelInit.js
	for ( var sKey in goPriority.byID ) // panelInit.js
		if ( sKey != "_" ) // panelInit.js
			aaPriority.push( // panelInit.js
				[ sKey // panelInit.js
				, goPriority.byID[ sKey ] // panelInit.js
				]) // panelInit.js
 // panelInit.js
	// Set up info for each call // panelInit.js
	gaoCall = [] // panelInit.js
	for ( var iCall = gnCalls + 1; --iCall; ) { // panelInit.js
 // panelInit.js
		// Initialize the get/setCallInfo machinery // panelInit.js
		gaoCall[ iCall ] = {} // panelInit.js
 // panelInit.js
		for ( var sKey in gaoCallField ) // panelInit.js
			gaoCall[ iCall ][ sKey ] = // panelInit.js
				{ _					: null // panelInit.js
				, vValue			: null		// Value of the item // panelInit.js
				, bDirty			: true		// Does the item need to be (re)drawn? // panelInit.js
				, aOption			: null		// List of options (only meaningful for selectors) // panelInit.js
				, bOptionsDirty		: false		// Is this a selector, and has its options list changed? // panelInit.js
				, fScreenControl	: gaoCallField[ sKey ].fScreenControl // panelInit.js
				} // panelInit.js
 // panelInit.js
		// Set the option list for the priority field // panelInit.js
		setCallInfo( iCall, "priority", aaPriority ) // panelInit.js
 // panelInit.js
		// Initialize state machine // panelInit.js
		setState( iCall, gsInitialState ) // panelInit.js
	} // panelInit.js
 // panelInit.js
	// Insert a C before the call number on each tab // panelInit.js
	for ( var iCall = gnCalls + 1; --iCall; ) { // panelInit.js
		var	o	= getNsObject( "tab", "", iCall, "txt" )  // panelInit.js
		o.innerHTML = "C" + o.innerHTML // panelInit.js
	} // panelInit.js
 // panelInit.js
	// Start us on tab 1  // panelInit.js
	giCurrentCall = 1 // panelInit.js
 // panelInit.js
	/*	TEMP // panelInit.js
	if ( true ) { // panelInit.js
		var x = nlapiSearchRecord( "phonecall", gsLogSearchID ) // panelInit.js
		var z = "column A:" // panelInit.js
		var y = x[ 0 ].rawColumns[ 0 ] // panelInit.js
		for ( var e in y) // panelInit.js
			z += "\n" + e + " {" + y[ e ] + "}" // panelInit.js
		popUpDebug(z) // panelInit.js
		z = "column C:" // panelInit.js
		var y = x[ 0 ].rawColumns[ 2 ] // panelInit.js
		for ( var e in y) // panelInit.js
			z += "\n" + e + " {" + y[ e ] + "}" // panelInit.js
		popUpDebug(z) // panelInit.js
	} // panelInit.js
	// */ // panelInit.js
	 // panelInit.js
	// Move and resize window // panelInit.js
	moveAndResizePanel() // panelInit.js
 // panelInit.js
	// Hide the debug gadgets at the window top // panelInit.js
	if ( gnDebug != 0 ) { // panelInit.js
		window.scroll( 0, 0 ) // panelInit.js
		window.scrollBy( 0, ganPanelDim[ 1 ] + ganPanelDebugHeight + 1 )	// TODO: Choose a better number? // panelInit.js
	} // panelInit.js
 // panelInit.js
	// Set the display to update regularly // panelInit.js
	gooDisplayTimer = // panelInit.js
		{ _			: null // panelInit.js
		, heartbeat	: setInterval( 'tryCatchLog("' + "heartbeat()"	 + '")', gnMsecBlinkTabs ) // panelInit.js
/*	// Just do as a single heartbeat // panelInit.js
		, tab		: setInterval( 'tryCatchLog("' + "colorTab()"	     + '")', gnMsecBlinkTabs ) // panelInit.js
		, duration	: setInterval( 'tryCatchLog("' + "updateDuration()"  + '")', gnMsecUpdateDurations ) // panelInit.js
		, display	: setInterval( 'tryCatchLog("' + "displayCallInfo()" + '")', gnMsecDisplayCallInfo ) // panelInit.js
// */ // panelInit.js
		} // panelInit.js
 // panelInit.js
	// Let the applet know that the JavaScript is initialized // panelInit.js
	javaScriptInitialized( true ) // panelInit.js
 // panelInit.js
	// Display the window contents // panelInit.js
	hideEverything( false ) // panelInit.js
 // panelInit.js
	// See whether applet is responsive // panelInit.js
	// TODO: Should be allowed to use tryCatchLog here, but we're running into bug #87 // panelInit.js
//	tryCatchLog( "tryToGetAppletVersion()" ) // panelInit.js
	tryToGetAppletVersion() // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
function // panelInit.js
putActionButtonsOnOneRow( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	for ( var iCall = gnCalls + 1; --iCall; ) { // panelInit.js
		var	i	= 0 // panelInit.js
		// Find the HTML that implements the first button // panelInit.js
		var	oButton1TD	= getNsObject( "button", iCall, "_" + ++i ) // panelInit.js
		// First button gets special CSS treatment // panelInit.js
		oButton1TD.className += " actionButtonFirst" // panelInit.js
		// The first button is enclosed in "<td><span>" // panelInit.js
		oButton1TD = oButton1TD.parentNode.parentNode // panelInit.js
		// For each subsequent action button // panelInit.js
		for ( ; ; ) { // panelInit.js
			// Find the HTML that implements this button // panelInit.js
			var	o	= getNsObject( "button", iCall, "_" + ++i ) // panelInit.js
			if ( o == null ) // panelInit.js
				break // panelInit.js
			// The button is enclosed in "<td><span>" // panelInit.js
			o = o.parentNode.parentNode // panelInit.js
			// Append this button to the cell containing the first button // panelInit.js
			oButton1TD.innerHTML += o.innerHTML // panelInit.js
			// Delete this button from its original cell // panelInit.js
			o.innerHTML = "" // panelInit.js
		} // panelInit.js
	} // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
/** // panelInit.js
 *	NetSuite provides each tab with a function called // panelInit.js
 *	Synccustpagem5_field_*_speakingto, which is called // panelInit.js
 *	when the user clicks the "New" entry on the pulldown // panelInit.js
 *	of the "Speaking To" field.  That function launches // panelInit.js
 *	the "New Contact" page.  To pass the contents of the // panelInit.js
 *	"Number" field into that page, we highjack that // panelInit.js
 *	function and alter it slightly. // panelInit.js
 * // panelInit.js
 *	CAUTION:  THIS FUNCTION MODIFIES NETSUITE CODE. // panelInit.js
 */ // panelInit.js
 // panelInit.js
function // panelInit.js
highjackNewContactLauncher( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	for ( var iCall = gnCalls + 1; --iCall; ) // panelInit.js
		eval( // panelInit.js
			eval( "Synccustpagem5_field_" + iCall + "_speakingto" ) // panelInit.js
				.toString() // panelInit.js
				// Get a reference to the New Contact window // panelInit.js
				.replace( /nlOpenWindow/, "var w = nlOpenWindow" ) // panelInit.js
				// Before returning // panelInit.js
				.replace( // panelInit.js
					/return;/, // panelInit.js
					'fnarf( ' + iCall + ', w, gaoCallField[ "number" ].fScreenControl.get( getNsObjectName( "field", ' + iCall + ', "number" )))' ) // panelInit.js
				// Overwrite the original NetSuite function with our improved version // panelInit.js
				.replace( /function[^(]*/, "Synccustpagem5_field_" + iCall + "_speakingto = function " )) // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
var ggw = [] // panelInit.js
 // panelInit.js
           // TODO: Bad function name // panelInit.js
function // panelInit.js
fnarf(iCall, w, sNumber ) // panelInit.js
{ // panelInit.js
	if ( ggw[ iCall ] == null ) // panelInit.js
		ggw[ iCall ] = { w:w, n:sNumber } // panelInit.js
 // panelInit.js
	// Wait for the "New Contact" window to finish loading // panelInit.js
	w = ggw[ iCall ].w // panelInit.js
	if ( w.document == null || w.document.getElementById( "phone" ) == null ) { // panelInit.js
		setTimeout( "fnarf( " + iCall + " )", 100 ) // panelInit.js
		return // panelInit.js
	} // panelInit.js
 // panelInit.js
//	+ 'while ( w.document.readyState.indexOf( "d" ) >= 0 )' // panelInit.js
//	+ ' ;' // panelInit.js
	// Copy the call panel's "Number" field into the New Contact window's "Main Phone" field // panelInit.js
	w.document.getElementById( "phone" ).value = ggw[ iCall ].n // panelInit.js
		 // panelInit.js
	ggw[ iCall ] = null // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
/** // panelInit.js
 *	Hide various Suitelet objects (the suffix "^" means "parent"). // panelInit.js
 */ // panelInit.js
 // panelInit.js
function // panelInit.js
hideDomObject( // panelInit.js
	vObject ) // panelInit.js
{ // panelInit.js
	if ( vObject == null ) // panelInit.js
		return // panelInit.js
 // panelInit.js
	if ( isArray( vObject )) { // panelInit.js
		for ( var i in vObject ) // panelInit.js
			hideDomObject( vObject[ i ]) // panelInit.js
		return // panelInit.js
	} // panelInit.js
 // panelInit.js
	if ( !isObject( vObject )) { // panelInit.js
	    var n   = vObject.length // panelInit.js
	    var i   = ( vObject + "^" ).indexOf( "^" ) // panelInit.js
		vObject = findElementByID( left( vObject, i )) // panelInit.js
		while ( i++ < n ) // panelInit.js
	    	vObject = vObject.parentNode // panelInit.js
	} // panelInit.js
 // panelInit.js
	vObject.style.visibility = "hidden" // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
function // panelInit.js
insertLogo( // panelInit.js
	bDim ) // panelInit.js
{ // panelInit.js
	// TODO: We are actually replacing, not inserting // panelInit.js
 // panelInit.js
/* // panelInit.js
	// This doesn't work, because there isn't a row above the tabs // panelInit.js
 // panelInit.js
	// Find the leftmost piece of the tab for call 1 // panelInit.js
	getNsObject( "tab", "", "1", "lt" ) // panelInit.js
		// It is enclosed in a <td> // panelInit.js
		.parentNode // panelInit.js
		//  which is enclosed in a <tr> containing all the tabs // panelInit.js
		.parentNode // panelInit.js
		//  which is enclosed in a <tbody> containing all the rows of the panel // panelInit.js
		.parentNode // panelInit.js
		//  whose first row is a <tr> containing the tabs // panelInit.js
		.rows[ 0 ] // panelInit.js
		//  whose first cell is a <td> containing the blank space to the left of the tabs // panelInit.js
		.cells[ 0 ] // panelInit.js
		//  into which we now insert the logo // panelInit.js
		.innerHTML // panelInit.js
			= '<img src="' + (( bDim ) ? gsNetSuiteImageDimURL : gsNetSuiteImageURL ) + '" width=32 height=20>' // panelInit.js
// */ // panelInit.js
 // panelInit.js
/* // panelInit.js
	// Find the hyperlinked text in the tab for call 1 // panelInit.js
	getNsObject( "tab", "", "1", "txt" ) // panelInit.js
		// It is enclosed in a <td> // panelInit.js
		.parentNode // panelInit.js
		//  which is enclosed in a <tr> containing all the tabs // panelInit.js
		.parentNode // panelInit.js
		//  whose last child is a collector for text not in <td>'s // panelInit.js
		.lastChild // panelInit.js
		//  and whose second-to-last child is the <td> containing (or formerly containing) the "Expand tabs" button // panelInit.js
		.previousSibling	// TODO: Maybe there's a cells[] solution that's tidier // panelInit.js
		//  into which we now insert the logo // panelInit.js
		.innerHTML // panelInit.js
			= '<img src="' + (( bDim ) ? gsNetSuiteImageDimURL : gsNetSuiteImageURL ) + '" width=32 height=20>' // panelInit.js
// */ // panelInit.js
 // panelInit.js
	// TODO: Maybe there's a cells[] solution that's tidier // panelInit.js
	// Find the hyperlinked text in the tab for call 1 // panelInit.js
	var	o	= getNsObject( "tab", "", "1", "txt" ) // panelInit.js
				// It is enclosed in a <td> // panelInit.js
				.parentNode // panelInit.js
				//  which is enclosed in a <tr> containing all the tabs // panelInit.js
				.parentNode // panelInit.js
				//  which is enclosed in a <tbody> // panelInit.js
				.parentNode // panelInit.js
				//  which is enclosed in a <table> // panelInit.js
				.parentNode // panelInit.js
				//  which is enclosed in a <td> // panelInit.js
				.parentNode // panelInit.js
	// Insert the logo into the <td> before the <table>; if there's anything before // panelInit.js
	//  the <table> (e.g., another logo), delete it		 // panelInit.js
	o.innerHTML // panelInit.js
		= "<img" // panelInit.js
		+ ' src="' + (( bDim ) ? gsLogoLoadingURL : gsLogoLoadedURL ) + '"' // panelInit.js
		+ (( ganLogoDims[ 0 ] >= 0 ) ? " width="  + ganLogoDims[ 0 ] : "" ) // panelInit.js
		+ (( ganLogoDims[ 1 ] >= 0 ) ? " height=" + ganLogoDims[ 1 ] : "" ) // panelInit.js
		+ ' style="margin-bottom: ' + ganLogoDims[ 2 ] + 'px"' // panelInit.js
		+ ">" // panelInit.js
		+ "<br>" // panelInit.js
		+ o.innerHTML.substr( o.innerHTML.search( /<table/i )) // panelInit.js
} // panelInit.js
 // panelInit.js
 // panelInit.js
function // panelInit.js
hideNetSuiteUiGadgets( // panelInit.js
	) // panelInit.js
{ // panelInit.js
	// Hide the area above the call tabs // panelInit.js
	var	a	= "div__header,div__title,div__label,main_form".split( "," ) // panelInit.js
	for ( var i in a ) // panelInit.js
		hideDomObject( a[ i ]) // panelInit.js
 // panelInit.js
	// And shrink it to remove the big vertical gap // panelInit.js
	with ( findElementByID( "main_form" ).style ) { // panelInit.js
		height = 1 // panelInit.js
		paddingBottom = 0 // panelInit.js
		display = "none" // panelInit.js
	} // panelInit.js
 // panelInit.js
	// Hide the "expand tabs" double down-arrow (to the right of the call tabs) // panelInit.js
	// Find the space that comes right before the "expand tabs" gadget // panelInit.js
	findElementByID( "tb_sp_7" ) // panelInit.js
		// Its next sibling is the <td> containing the "Expand tabs" button // panelInit.js
		.nextSibling	// TODO: Maybe there's a cells[] solution that's tidier // panelInit.js
		// Delete the contents of that <td> // panelInit.js
		.innerHTML = "" // panelInit.js
} // panelInit.js
	
// --- panelUtil.js ------------------------------------------------------------- 	
	
 // panelUtil.js
 // panelUtil.js
/** // panelUtil.js
 *	Hide all the buttons on the given tab. // panelUtil.js
 * // panelUtil.js
 *	@return	void // panelUtil.js
 */ // panelUtil.js
 // panelUtil.js
function // panelUtil.js
hideButtons( // panelUtil.js
	iCall ) // panelUtil.js
{ // panelUtil.js
	// Assume that all buttons are numbered sequentially, starting from 1, and just continue // panelUtil.js
	//  until we reach a button that is not defined // panelUtil.js
	for ( var iButton = 0; ; ) { // panelUtil.js
		var	oButton	= getNsObject( "button", iCall, "_" + ++iButton ) // panelUtil.js
		if ( oButton == null || typeof( oButton ) == "undefined" ) // panelUtil.js
			break // panelUtil.js
		oButton.style.visibility = "hidden" // panelUtil.js
	} // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
function // panelUtil.js
heartbeat( // panelUtil.js
	) // panelUtil.js
{ // panelUtil.js
	colorTab() // panelUtil.js
	updateDuration() // panelUtil.js
	displayCallInfo() // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
/** // panelUtil.js
 *	Color the given call's tab to reflect the call's state. // panelUtil.js
 * // panelUtil.js
 *	@return	void // panelUtil.js
 * // panelUtil.js
 *	@param	int					iCall // panelUtil.js
 *		Call [opt.]; if none, color the tabs of all calls // panelUtil.js
 */ // panelUtil.js
 // panelUtil.js
function // panelUtil.js
colorTab( // panelUtil.js
	iCall ) // panelUtil.js
{ // panelUtil.js
	if ( arguments.length < 1 ) { // panelUtil.js
		// Color all the call tabs to show their status // panelUtil.js
		for ( var iCall = gnCalls + 1; --iCall; ) // panelUtil.js
			colorTab( iCall ) // panelUtil.js
		return // panelUtil.js
	} // panelUtil.js
 // panelUtil.js
	// Get the tab's state // panelUtil.js
	var	sTabState	= getCallInfo( iCall, "tab" ) // panelUtil.js
 // panelUtil.js
	// Use a bold font for anything other than the "None" tab state // panelUtil.js
	getNsObject( "tab", "", iCall, "txt" ).style.fontWeight = ( sTabState == "None" ) ? "" : "bold" // panelUtil.js
 // panelUtil.js
	// Set the color based on the state and the time (so lamps blink in unison) // panelUtil.js
	var	asColor		= goasTabColor[ sTabState ] // panelUtil.js
	var	aColor		= ( asColor[ nowSec() % asColor.length ] + ":" ).split( ":" ) // panelUtil.js
 // panelUtil.js
	// Color the tab // panelUtil.js
	var	s	= "#" + aColor[ 0 ] // panelUtil.js
	if ( s == "#" ) // panelUtil.js
		s = "" // panelUtil.js
	getNsObject( "tab", "", iCall, "txt" ).style.color = s // panelUtil.js
 // panelUtil.js
	s	= "#" + aColor[ 1 ] // panelUtil.js
	if ( s == "#" ) // panelUtil.js
	   	s = "" // panelUtil.js
	var	asTabPart	= [ "lnk" ] // [ "lt", "lnk", "rt" ] // panelUtil.js
	for ( var i in asTabPart ) // panelUtil.js
		getNsObject( "tab", "", iCall, asTabPart[ i ]).style.backgroundColor = s // panelUtil.js
 // panelUtil.js
	// Special case:  the leftmost call tab has an extra curved "ear" on the left, which // panelUtil.js
	//  is found in the <td> that precedes the tab; color that, too // panelUtil.js
	if ( iCall == 1 ) // panelUtil.js
		getNsObject( "tab", "", iCall, "lnk" ).previousSibling.style.backgroundColor = s // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
/** // panelUtil.js
 *	Update the call duration and hold duration of the given call. // panelUtil.js
 * // panelUtil.js
 *	@return	void // panelUtil.js
 * // panelUtil.js
 *	@param	int					iCall // panelUtil.js
 *		Call [opt.]; if none, update all calls // panelUtil.js
 */ // panelUtil.js
 // panelUtil.js
function // panelUtil.js
updateDuration( // panelUtil.js
	iCall ) // panelUtil.js
{ // panelUtil.js
	if ( arguments.length < 1 ) { // panelUtil.js
		// Update all the call durations // panelUtil.js
		for ( var iCall = gnCalls + 1; --iCall; ) // panelUtil.js
			updateDuration( iCall ) // panelUtil.js
		return // panelUtil.js
	} // panelUtil.js
 // panelUtil.js
	// If we're on a call, update the call duration // panelUtil.js
	if ( getCallInfo( iCall, "bOnCall" ) == "true" ) { // panelUtil.js
		setCallInfo( iCall, "duration", nowSec() - getCallInfo( iCall, "secCallStart" )) // panelUtil.js
		// If we're on hold, update the hold duration // panelUtil.js
		if ( getCallInfo( iCall, "bOnHold" ) == "true" ) // panelUtil.js
			setCallInfo( iCall, "secHoldDuration", nowSec() - getCallInfo( iCall, "secHoldStart" )) // panelUtil.js
	} // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
/** // panelUtil.js
 *	A button was clicked. // panelUtil.js
 * // panelUtil.js
 *	@return	void // panelUtil.js
 * // panelUtil.js
 *	@param	Object			o // panelUtil.js
 *		The button that was clicked // panelUtil.js
 */ // panelUtil.js
 // panelUtil.js
function // panelUtil.js
fnClkdButton( // panelUtil.js
	iCall, // panelUtil.js
	o ) // panelUtil.js
{ // panelUtil.js
	var	sTrigger	= o.value // panelUtil.js
 // panelUtil.js
	if ( iCall < 0 ) {	// If this is one of the asynchronous events // panelUtil.js
		sTrigger = "A " + sTrigger // panelUtil.js
		iCall = giCurrentCall // panelUtil.js
	} // panelUtil.js
	else // panelUtil.js
		sTrigger = "B " + sTrigger // panelUtil.js
 // panelUtil.js
	tryCatchLog( "handleEvent(" + iCall + ',"' + sTrigger + '")' ) // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
// TODO: Rename // panelUtil.js
function // panelUtil.js
handleEvent( // panelUtil.js
	iCall, // panelUtil.js
	sTrigger ) // panelUtil.js
{ // panelUtil.js
	// Make sure a user has been selected // panelUtil.js
	// TODO: We may have logged in automatically // panelUtil.js
//	if ( nlapiGetFieldValue( getNsObjectName( "select", "debug", 1 )) == "" ) { // panelUtil.js
//		popUpDebug( "ERROR: No user selected" ) // panelUtil.js
//		return // panelUtil.js
//	} // panelUtil.js
 // panelUtil.js
	logme( 1, "Call #" + iCall + ': trigger "' + sTrigger + '"' )	// dhzdhz // panelUtil.js
 // panelUtil.js
	// Perform the action (if any) defined for this event // panelUtil.js
	var	sAction	= goTriggerAction[ toIdentifier( sTrigger )] // panelUtil.js
	if ( typeof( sAction ) != "undefined" && sAction != "" ) // panelUtil.js
		eval( sAction )( iCall ) // panelUtil.js
 // panelUtil.js
	// Perform the state change (if any) defined for this event // panelUtil.js
	changeState( iCall, sTrigger.charAt( 0 ), sTrigger.substr( 2 )) // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
/** // panelUtil.js
 *	Hook for the "clicked on a tab" function.  Doing so allows us to // panelUtil.js
 *	redefine buttons on a per-tab basis. // panelUtil.js
 * // panelUtil.js
 *	The only time we really want to do anything here is if the // panelUtil.js
 *	user has clicked on one of the tabs along the top of the // panelUtil.js
 *	screen.  In such a case, bIgnoreInited will be false.  This // panelUtil.js
 *	function gets called at other times (e.g., when the log is // panelUtil.js
 *	being auto-updated), but since the active tab isn't being // panelUtil.js
 *	changed in such cases, we don't do anything.  Such cases // panelUtil.js
 *	can be distinguished by the fact that bIgnoreInited is // panelUtil.js
 *	missing. // panelUtil.js
 * // panelUtil.js
 *	@return	void // panelUtil.js
 * // panelUtil.js
 *	@param	string			lname // panelUtil.js
 *		Name of the tab // panelUtil.js
 *	@param	bool			bIgnoreInited // panelUtil.js
 *		?dhz? // panelUtil.js
 */ // panelUtil.js
 // panelUtil.js
function // panelUtil.js
myShowTab( // panelUtil.js
	lname, // panelUtil.js
	bIgnoreInited ) // panelUtil.js
{ // panelUtil.js
	// Perform standard behavior // panelUtil.js
	chainHookedFunction( arguments.callee, null, lname, bIgnoreInited ) // panelUtil.js
 // panelUtil.js
	// If bIgnoreInited is anything other than false, we're done // panelUtil.js
	if ( arguments.length < 2 || bIgnoreInited ) // panelUtil.js
		return // panelUtil.js
 // panelUtil.js
	iCall = right( lname, 2 ).replace( /_/, "" ) // panelUtil.js
 // panelUtil.js
	// The log tab gets the special value 0 // panelUtil.js
	if ( !isFinite( iCall )) { // panelUtil.js
		iCall = 0 // panelUtil.js
 // panelUtil.js
		// Fake a press of the "Refresh" button // panelUtil.js
		nlapiRefreshLineItems( getNsObjectName( "list", "log", 1 )) // panelUtil.js
	} // panelUtil.js
 // panelUtil.js
	// Remember this tab // panelUtil.js
	giCurrentCall = iCall // panelUtil.js
 // panelUtil.js
	// Show details of current call // panelUtil.js
	displayCallInfo() // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
function // panelUtil.js
updateCallLog( // panelUtil.js
	iCall ) // panelUtil.js
{ // panelUtil.js
	var	iCallBegin	= iCall // panelUtil.js
	var	iCallEnd	= iCall // panelUtil.js
	switch ( gnAutoUpdateCallLogs ) { // panelUtil.js
 // panelUtil.js
	case -1: // panelUtil.js
		nlapiRefreshLineItems( getNsObjectName( "list", "log", 1 )) // panelUtil.js
		break // panelUtil.js
 // panelUtil.js
	case 0: // panelUtil.js
		++iCallBegin // panelUtil.js
		break // panelUtil.js
 // panelUtil.js
	case 1: // panelUtil.js
		break // panelUtil.js
 // panelUtil.js
	default: // panelUtil.js
		iCallBegin	= 1 // panelUtil.js
		iCallEnd	= gnCalls // panelUtil.js
		break // panelUtil.js
	} // panelUtil.js
	while ( iCallBegin <= iCallEnd ) // panelUtil.js
		// TODO: This list is not a scriptable sublist according to NetSuite, so refreshing it // panelUtil.js
		//  in this manner may not be supported in the future // panelUtil.js
		nlapiRefreshLineItems( getNsObjectName( "list", iCallBegin++, 1 )) // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
function // panelUtil.js
getBuildInfo( // panelUtil.js
	) // panelUtil.js
{ // panelUtil.js
	if ( gnDebug != 0 ) { // panelUtil.js
/* // panelUtil.js
		for ( var e in ganNetSuiteScriptID ) // panelUtil.js
			if ( ganNetSuiteScriptID[ e ] == gnNetSuiteScriptID ) // panelUtil.js
				return ( " (" + String( e ).toUpperCase() + " " + gsJavaScriptBuildTime + ")" ) // panelUtil.js
// */ // panelUtil.js
		return ( " (js=" + gnNetSuiteScriptID + ") " + gsJavaScriptBuildTime ) // panelUtil.js
	} // panelUtil.js
 // panelUtil.js
	return ( "" ) // panelUtil.js
} // panelUtil.js
 // panelUtil.js
 // panelUtil.js
 // panelUtil.js
function // panelUtil.js
lookForUrlParameters( // panelUtil.js
	sParamNames ) // panelUtil.js
{ // panelUtil.js
	// Read URL parameters // panelUtil.js
	var	a		= sParamNames.split( "," ) // panelUtil.js
	var	oParams	= {} // panelUtil.js
	for ( var i in a ) { // panelUtil.js
		var	s	= a[ i ] // panelUtil.js
		var	t	= s // panelUtil.js
		// TODO: Alternatively, we could just try to find the parameter both with and without our prefix, or we could pre-attach the prefix // panelUtil.js
		if ( !isOneOf( s, "," + gsNetSuiteUrlParameters )) // panelUtil.js
			t = gsNetSuiteParamPrefix + t // panelUtil.js
		oParams[ s ] = nz( request.getParameter( t )) // panelUtil.js
	} // panelUtil.js
 // panelUtil.js
	return ( oParams ) // panelUtil.js
} // panelUtil.js
 // panelUtil.js
//TODO: Needed? Clean up // panelUtil.js
var	gasLogLine	= [ "", "", "", "", "" ] // panelUtil.js
 // panelUtil.js
function // panelUtil.js
logme( // panelUtil.js
	nLevel,		// Minimum debug level: if gnDebug is less than this, message will not be logged // panelUtil.js
	sMsg )		// Message // panelUtil.js
{ // panelUtil.js
	if ( !isOneOf( gsDocType, ",panel,harness" )) // panelUtil.js
		return // panelUtil.js
	if ( gsDocType == "panel" && ( gnDebug < nLevel || !gbMaintainLog )) // panelUtil.js
		return // panelUtil.js
 // panelUtil.js
	var	sTimestamp	= formatDuration( nowSec() - gnStartTime, "mm:ss" ) // panelUtil.js
 // panelUtil.js
/* // panelUtil.js
	// TODO: Have another URL parameter that determines whether to drop old log entries // panelUtil.js
	if ( this is not the dev build ) // panelUtil.js
		gasLogLine.shift() // panelUtil.js
// */ // panelUtil.js
	gasLogLine.push( "- " + sTimestamp + " " + sMsg.replace( /  */g, " " )) // panelUtil.js
 // panelUtil.js
	with ( getNsObject( "log", "debug", "mainid" )) { // panelUtil.js
		innerHTML =  gasLogLine.join( gsLogNewline ) // panelUtil.js
		// Scroll down so we can see this most recent addition // panelUtil.js
		scrollTop = scrollHeight // panelUtil.js
	} // panelUtil.js
} // panelUtil.js
	
// --- dialerBuilder.js ------------------------------------------------------------- 	
	
function // dialerBuilder.js
layOutDialer( // dialerBuilder.js
	request, // dialerBuilder.js
	response ) // dialerBuilder.js
{ // dialerBuilder.js
	// Initialize constants // dialerBuilder.js
	initConstants() // dialerBuilder.js
	 // dialerBuilder.js
	// URL parameters that matter to us (parameters that are not defined by NetSuite must have our custom prefix) // dialerBuilder.js
	var	oParams = lookForUrlParameters( "debug,deploy,dial,script" ) // dialerBuilder.js
 // dialerBuilder.js
	// Catch the "debug" parameter, if any // dialerBuilder.js
	if ( oParams.debug != "" ) // dialerBuilder.js
		gnDebug = oParams.debug // dialerBuilder.js
 // dialerBuilder.js
	// Which version (dev, test, release candidate) is this? // dialerBuilder.js
	gnNetSuiteScriptID = oParams.script // dialerBuilder.js
	gnNetSuiteDeploymentID = oParams.deploy // dialerBuilder.js
 // dialerBuilder.js
	var	sNumber			= formatPhone( oParams.dial ) // dialerBuilder.js
	var	sTitle			= "" // dialerBuilder.js
	var	sHTML			= "" // dialerBuilder.js
 // dialerBuilder.js
	// Look up the current user // dialerBuilder.js
	var	oUser	= getUsersM5Info( nlapiGetUser() )	// TODO: Returns -4 on error // dialerBuilder.js
	if ( oUser == null ) // dialerBuilder.js
		return // dialerBuilder.js
 // dialerBuilder.js
	// If unable to dial, say so // dialerBuilder.js
	if ( oUser.enabled != "T" ) { // dialerBuilder.js
		sTitle = goText.dialerUnableToDial // dialerBuilder.js
					.replace( /%t/, sNumber ) // dialerBuilder.js
		sHTML = "" // dialerBuilder.js
			+ goText.phoneDisabled // dialerBuilder.js
			+ "<br><br>" // dialerBuilder.js
			+ goText.contactSysAdmin // dialerBuilder.js
			+ "<br><br>" // dialerBuilder.js
	    	+ '<input type="button" class="dialerButton" value="OK" onclick="self.close()">' // dialerBuilder.js
	} // dialerBuilder.js
	else { // dialerBuilder.js
		sTitle = goText.dialerTitle // dialerBuilder.js
					.replace( /%t/, sNumber ) // dialerBuilder.js
		var	sURL = nlapiResolveURL( "SUITELET", gnNetSuiteScriptID, gnNetSuiteDeploymentID, false ) // dialerBuilder.js
 // dialerBuilder.js
		// Pass the "debug" parameter as well, even though we might only be debugging the call panel // dialerBuilder.js
		if ( gnDebug != 0 ) // dialerBuilder.js
			sURL += "&debug=" + gnDebug // dialerBuilder.js
 // dialerBuilder.js
		sHTML = "" // dialerBuilder.js
			+ goText.dialerDialing // dialerBuilder.js
				.replace( /%t/, sNumber ) // dialerBuilder.js
				.replace( /%f/, formatPhone( oUser.phone )) // dialerBuilder.js
			+ "<br>" // dialerBuilder.js
			+ '<iframe width=1 height=1 style="visibility: hidden"' // dialerBuilder.js
	    	+ ' src="' // dialerBuilder.js
	    	+ gsM5WebSvcsURL // dialerBuilder.js
	    	+ "?name=org.m5.apps.v1.cti.ClickToDial.dial" // dialerBuilder.js
	    	+ "&user=" + getPhoneDigits( oUser.phone ) // dialerBuilder.js
	    	+ "&password=" + oUser.password // dialerBuilder.js
	    	+ "&args=" + getPhoneDigits( sNumber ) // dialerBuilder.js
	    	+ "&args=" // dialerBuilder.js
	    	+ "&cachebuster=" + mid( Math.random(), 2 ) // dialerBuilder.js
	    	+ '"></iframe><br><br>' // dialerBuilder.js
	    	// dhz window.open( '/app/site/hosting/scriptlet.nl?script=4&deploy=2', 'ShoreTel Sky Connect for NetSuite call panel' ) // dialerBuilder.js
	    	+ '<input id="openButton" type="button" class="dialerButton" style="visibility: hidden" value="' // dialerBuilder.js
	    		+ goText.dialerButton + '" onclick="' + "window.open( '" + sURL + "', '" // dialerBuilder.js
	    		// IE 8+ fails silently if there are any spaces in window name   // dialerBuilder.js
	    		+ goText.callPanelWindowName.replace( / /g, "_" ) // dialerBuilder.js
	    		+ "' )" + '">' // dialerBuilder.js
	} // dialerBuilder.js
 // dialerBuilder.js
	// Add a flag so we know we're the dialer // dialerBuilder.js
	sHTML += "<script>var gbIsDialer = true<\/script>" // dialerBuilder.js
 // dialerBuilder.js
	// Create the form // dialerBuilder.js
	var oForm = nlapiCreateForm( sTitle + getBuildInfo(), gbHideNavBar ) // dialerBuilder.js
 // dialerBuilder.js
	with ( oForm ) { // dialerBuilder.js
 // dialerBuilder.js
		var	sName	= getNsObjectName( "dialer", "panel", 1 )		// TODO: Better name? // dialerBuilder.js
		sNSType		= "inlinehtml" // dialerBuilder.js
 // dialerBuilder.js
        with ( addField( sName, sNSType, "" )) // dialerBuilder.js
    		setDefaultValue( sHTML ) // dialerBuilder.js
 // dialerBuilder.js
		// Set this JavaScript file to be the form's script // dialerBuilder.js
		setScript( gnNetSuiteScriptID ) // dialerBuilder.js
	} // dialerBuilder.js
 // dialerBuilder.js
	response.writePage( oForm ) // dialerBuilder.js
} // dialerBuilder.js
	
// --- dialer.js ------------------------------------------------------------- 	
	
/** // dialer.js
 *	Move and resize the dialer. // dialer.js
 * // dialer.js
 *	@return	void // dialer.js
 */ // dialer.js
 // dialer.js
function // dialer.js
moveAndResizeDialer( // dialer.js
	) // dialer.js
{ // dialer.js
	var l = ganDialerMargin[ 0 ] // dialer.js
	var t = ganDialerMargin[ 1 ] // dialer.js
	var r = ( window.screen.availWidth  - ganDialerDim[ 0 ]) - l // dialer.js
	var b = ( window.screen.availHeight - ganDialerDim[ 1 ]) - t // dialer.js
 // dialer.js
	window.moveTo( l, t ) // dialer.js
 // dialer.js
	// TODO: resizing is broken // dialer.js
	return // dialer.js
 // dialer.js
	// TODO: Google Chrome does not support resizeTo and moveTo in top-level windows; may not be an issue, since dialer is generally launched from a NetSuite page // dialer.js
 // dialer.js
	window.resizeTo( ganDialerDim[ 0 ], ganDialerDim[ 1 ]) // dialer.js
	var	a	= getClientAreaSize() // dialer.js
	window.resizeBy( ganDialerDim[ 0 ] - a[ 0 ], ganDialerDim[ 1 ] - a[ 1 ]) // dialer.js
} // dialer.js
 // dialer.js
 // dialer.js
/** // dialer.js
 *	Initialize dialer Suitelet. // dialer.js
 */ // dialer.js
 // dialer.js
function // dialer.js
init_dialer( // dialer.js
	nInstance )		// Applet instance (-1 = initialize the page as a whole)  // dialer.js
{ // dialer.js
	// Move and resize window // dialer.js
	moveAndResizeDialer() // dialer.js
 // dialer.js
	// Add style sheet rules // dialer.js
	addStyleSheetRules() // dialer.js
 // dialer.js
	// If we were given a button for opening the call panel // dialer.js
	var	oButton	= findElementByID( "openButton" ) // dialer.js
	if ( oButton ) { // dialer.js
		// If we can't find the call panel in some other window // dialer.js
		// ... TODO: Search for call panel window // dialer.js
			// TODO: If we were able to open the window, close it right away // dialer.js
			// Give him a button for opening the call panel // dialer.js
			oButton.style.visibility = "visible" // dialer.js
 // dialer.js
		// Go away after a little while // dialer.js
		setTimeout( "self.close()", gnDialerAutoCloseSec * 1000 ) // dialer.js
	} // dialer.js
} // dialer.js
	
// --- harness.js ------------------------------------------------------------- 	
	
/** // harness.js
 *	Initialize test harness. // harness.js
 * // harness.js
 *	@return	void // harness.js
 */ // harness.js
 // harness.js
function // harness.js
init_harness( // harness.js
	nInstance )		// Applet instance (-1 = initialize the page as a whole)  // harness.js
{ // harness.js
	switch ( nInstance ) { // harness.js
 // harness.js
	case -1: // harness.js
		initConstants( -1 ) // harness.js
 // harness.js
		// Commented out because it's confusing: it's really "the latest version of the applet as of the time the JavaScript was built" // harness.js
//		document.title += " (applet v. " + gsAppletBuildTime.substr( 2, 4 ) + ")" // harness.js
 // harness.js
		element( 0, "appletHolder" ).innerHTML = getHtmlToEmbedApplet( 0, gsAppletPath + gsAppletFile, gsAppletPackage + "." + gsAppletRootClass ) // harness.js
 // harness.js
		// Let the applet know that the JavaScript is initialized // harness.js
		javaScriptInitialized( true ) // harness.js
 // harness.js
		showAppletInfo( gnAppletInstances ) // harness.js
		break // harness.js
 // harness.js
	default: // harness.js
		// Initialize instance // harness.js
		clicked( "DID." + nInstance ) // harness.js
		clicked( "cmdtimeout." + nInstance ) // harness.js
		break // harness.js
	} // harness.js
} // harness.js
 // harness.js
 // harness.js
function // harness.js
showAppletInfo( // harness.js
	nInstances )    // Number of instances of the applet on this page // harness.js
{ // harness.js
	// Try to show applet info; if failed, wait a while and try again // harness.js
	if ( !tryToShowAppletInfo( nInstances )) { // harness.js
	    setTimeout( "showAppletInfo(" + nInstances + ")", 250 )	// 0.250 sec // harness.js
		return // harness.js
	} // harness.js
 // harness.js
	// For every instance of the applet // harness.js
	for ( var iInstance = nInstances; iInstance--; ) { // harness.js
 // harness.js
		// Tell the applet that it's running in the test harness // harness.js
		javaScriptCallsOutToJava( iInstance, "init", "h" ) // harness.js
 // harness.js
		// Initialize the radio buttons // harness.js
		clicked( element( iInstance, "RDID" )) // harness.js
		clicked( element( iInstance, "Rex_tn" )) // harness.js
	} // harness.js
} // harness.js
 // harness.js
 // harness.js
function // harness.js
tryToShowAppletInfo( // harness.js
	nInstances )    // Number of instances of the applet on this page // harness.js
{ // harness.js
	var bSuccess    = true // harness.js
 // harness.js
	// Display applet info // harness.js
	for ( var iInstance = 0; iInstance < nInstances; ++iInstance ) { // harness.js
		 // harness.js
		// Announce that we're still trying to get the applet status // harness.js
		var	o	= element( iInstance, "applet.info" ) // harness.js
		o.innerHTML = rotator( o.innerHTML ) // harness.js
 // harness.js
		// Get applet status // harness.js
		var	sStatus		= "&nbsp;" // harness.js
	    var sVersion	= javaScriptCallsOutToJava( iInstance, "get version" ) // harness.js
	    if ( typeof( sVersion ) == "undefined" || sVersion == null || sVersion.indexOf( "." ) < 0 ) // harness.js
	        bSuccess = false // harness.js
		else { // harness.js
	        sStatus = "Applet #" + iInstance + " (v. " + sVersion + ")" // harness.js
	        element( iInstance, "applet.info" ).innerHTML = sStatus // harness.js
		} // harness.js
	} // harness.js
 // harness.js
	return ( bSuccess ); // harness.js
} // harness.js
 // harness.js
 // harness.js
/** // harness.js
 *  The value or state of an input object on the web page was changed (e.g., // harness.js
 *  text was edited or a button was clicked). // harness.js
 */ // harness.js
 // harness.js
function // harness.js
clicked( // harness.js
	o )				// (object) The input object or (string) its HTML ID // harness.js
{ // harness.js
	var s = o       // Name of the object // harness.js
 // harness.js
	if ( typeof( o ) == "string" ) { // harness.js
		o = findElementByID( s ) // harness.js
		if ( o == null ) { // harness.js
		    popUpDebug( 'clicked: Unknown object "' + s + '"' ) // harness.js
			return // harness.js
		} // harness.js
	} // harness.js
 // harness.js
	// The non-instance part of the object's name // harness.js
	var a			= ( o.id + ".-1" ).split( "." ) // harness.js
	var sTag		= a[ 0 ] // harness.js
	// Instance of the Java applet this object affects (-1 = all) // harness.js
	var	nInstance	= a[ 1 ] // harness.js
 // harness.js
	// Handle inputs that affect other inputs // harness.js
	switch ( sTag ) { // harness.js
 // harness.js
	case "RDID": // harness.js
	case "Rex_tn": // harness.js
		var	a = o.value.split( ";" ) // harness.js
		element( nInstance, sTag.substr( 1 )).value = a[ 0 ]	                                                 ; // harness.js
		if ( a.length > 1 ) // harness.js
			element( nInstance, "password" ).value = a[ 1 ] // harness.js
		break // harness.js
 // harness.js
	default: // harness.js
	    break // harness.js
	} // harness.js
 // harness.js
	// Do whatever the changed input requires // harness.js
	// TODO: Should really only do this if applet has told us it's alive // harness.js
	switch ( sTag ) { // harness.js
 // harness.js
	case "select": // harness.js
	case "ex_tn": // harness.js
	case "Rex_tn": // harness.js
	case "call_ID": // harness.js
	case "endpoint": // harness.js
	    break // harness.js
 // harness.js
	case "doit": // harness.js
		var	sPrototype	= selected( element( nInstance, "select" )) // harness.js
		if ( sPrototype.charAt( 0 ) == "-" ) { // harness.js
			popUpMessage( "Select a command" ) // harness.js
			break // harness.js
		} // harness.js
		var a           = ( sPrototype + "?" ).split( "?" ) // harness.js
		var sCmd    	= a[ 0 ] // harness.js
		a               = a[ 1 ].split( "," ) // harness.js
		var sParams     = "" // harness.js
		for ( var i in a ) { // harness.js
		    var sKey	= a[ i ].replace( /^\*/, "" ) // harness.js
		    var sValue	= element( nInstance, sKey ).value // harness.js
 // harness.js
			// Don't send parameters we already sent via other commands // harness.js
		    switch ( sKey ) { // harness.js
 // harness.js
			case "DID": // harness.js
			case "password": // harness.js
			case "cmdtimeout": // harness.js
			case "svrtimeout": // harness.js
			case "respformat": // harness.js
			    sValue = "" // harness.js
				break // harness.js
 // harness.js
			default: // harness.js
			    break // harness.js
			} // harness.js
 // harness.js
		    sParams += "&" + xlate( sKey ) + "=" + sValue // harness.js
		} // harness.js
		sendWebSvcRequest( nInstance, sCmd, sParams.substr( 1 )) // harness.js
 // harness.js
		// Clear out the call ID field, since the next command probably won't need it // harness.js
		element( nInstance, "call_ID" ).value = "" // harness.js
		break // harness.js
 // harness.js
	case "DID": // harness.js
	case "RDID": // harness.js
	case "password": // harness.js
		var s   = "" // harness.js
		            + element( nInstance, "DID" ).value // harness.js
		            + "," // harness.js
		            + element( nInstance, "password" ).value // harness.js
		javaScriptCallsOutToJava( nInstance, "login", s ) // harness.js
		break // harness.js
 // harness.js
	case "cmdtimeout": // harness.js
	case "svrtimeout": // harness.js
	    var s   = "" // harness.js
					+ element( nInstance, "cmdtimeout" ).value // harness.js
					+ "," // harness.js
					+ element( nInstance, "svrtimeout" ).value // harness.js
		javaScriptCallsOutToJava( nInstance, "set timeouts", s ) // harness.js
	    break // harness.js
 // harness.js
	case "Rrespformat": // harness.js
		javaScriptCallsOutToJava( nInstance, "set response format", o.value ) // harness.js
	    break // harness.js
 // harness.js
	case "web":		// TODO: Unused // harness.js
	    // Collect web service name and parameters in raw, tilde-separated format // harness.js
	    var sWebSvcReqURL	= element( nInstance, "params" ).value // harness.js
	    var i				= sWebSvcReqURL.indexOf( "~" ) // harness.js
	    var sCommand    	= sWebSvcReqURL.substr( 0, i - 1 ) // harness.js
	    var sParams     	= sWebSvcReqURL.substr( i + 1 ) // harness.js
	    sendWebSvcRequest( nInstance, sCommand, sParams ) // harness.js
	    break // harness.js
 // harness.js
	case "subscribe":	// TODO: Unused // harness.js
	    // Collect web service name and parameters in raw, tilde-separated format // harness.js
	    var sWebSvcReqURL	= element( nInstance, "params" ).value // harness.js
	    var a               = sWebSvcReqURL.split( "~" ) // harness.js
	    a[ 0 ] = "subscribe" // harness.js
	    a[ 3 ] = "Arguments" // harness.js
	    a.length = 4 // harness.js
	    var i				= sWebSvcReqURL.indexOf( "~" ) // harness.js
	    var sCommand    	= sWebSvcReqURL.substr( 0, i - 1 ) // harness.js
	    var sParams     	= sWebSvcReqURL.substr( i + 1 ) // harness.js
	    sendWebSvcRequest( nInstance, sCommand, sParams ) // harness.js
		break // harness.js
 // harness.js
	default: // harness.js
	    popUpDebug( 'clicked(): Unknown input "' + sTag + '"' ) // harness.js
	    break // harness.js
	} // harness.js
} // harness.js
 // harness.js
 // harness.js
function // harness.js
selectCall( // harness.js
	nInstance, // harness.js
	id ) // harness.js
{ // harness.js
	element( nInstance, "call_ID" ).value = id // harness.js
} // harness.js
 // harness.js
 // harness.js
/** // harness.js
 *  Get an HTTP request.  Normally called by the Java applet. // harness.js
 *  TODO: Actually, this is now called by the JavaScript when it's about to // harness.js
 *  send a request to the applet. // harness.js
 */ // harness.js
 // harness.js
function // harness.js
getHttpRequest( // harness.js
	nInstance )	// Instance of the Java applet // harness.js
{ // harness.js
	var s	= element( nInstance, "params" ).value // harness.js
 // harness.js
	s = s // harness.js
		.replace( / *~ */g, "&" ) // harness.js
		.replace( /[& ]*$/, "" ) // harness.js
		.replace( /[ =][ =]*/g, "=" ) // harness.js
		.replace( /&&*/g, "&" ) // harness.js
		.replace( /(=[^=&]*)=$/, "$1" ) // harness.js
 // harness.js
	element( nInstance, "url" ).value = s // harness.js
 // harness.js
//	s = "https://hostedconnect.m5net.com/bobl/bobl?name=org.m5.apps.v1.cti.ClickToDial." + s // harness.js
 // harness.js
	return s; // harness.js
} // harness.js
 // harness.js
 // harness.js
function // harness.js
showHttpRequest( // harness.js
	nInstance,	// Instance of the Java applet // harness.js
	sRequest )	// Request // harness.js
{ // harness.js
	element( nInstance, "request" ).innerHTML = sRequest.replace( /&/g, " &amp;&nbsp;" ) // harness.js
} // harness.js
 // harness.js
		 // harness.js
/** // harness.js
 *  Display an HTTP response in the "response" field.  If the response is a // harness.js
 *  string containing XML, do some minor formatting on the XML to make it // harness.js
 *  easier to view. // harness.js
 * // harness.js
 *  Normally called by the Java applet. // harness.js
 */ // harness.js
 // harness.js
function // harness.js
showHttpResponse( // harness.js
	nInstance,	// Instance of the Java applet // harness.js
	nStatus,	// Status code // harness.js
	sStatus )	// Status text (usually XML) // harness.js
{ // harness.js
	// Number of spaces per indent // harness.js
	var nIndent = 4 // harness.js
 // harness.js
	var ss = sStatus // harness.js
 // harness.js
	ss = ss // harness.js
	        .replace( /<([^\/>]*)\/>/g, "<$1></$1>" ) // harness.js
	        .replace( /  *>/g, ">" ) // harness.js
	        .replace( /<\?xml[^>]*>/, "" ) // harness.js
	    	.replace( /</g, "{{" ) // harness.js
	    	.replace( /{\{\/[^>]*>/g, "[-]" ) // harness.js
			.replace( /({\{[^>]*>)/g, "<span style=\"color: #990000; font-size: 8pt; font-weight: normal\"}}$1:</span}} " ) // harness.js
 // harness.js
	do { // harness.js
	    i = ss.length // harness.js
	    ss = ss // harness.js
	    	.replace( /({\{[^> ]*) ([^> ]*)/g, "$1[+][+]<i}}$2</i}}[-][-]" ) // harness.js
	} while ( ss.length > i ) // harness.js
 // harness.js
	ss = ss // harness.js
	    	.replace( /{\{/g, "[+]" ) // harness.js
	var sa = ss.split( "[+]" ) // harness.js
	var n = 0 // harness.js
	for ( var i in sa ) { // harness.js
	    for ( var j = n++; j--; ) // harness.js
	        sa[ i ] = "~" + sa[ i ] // harness.js
		var sb = sa[ i ].split( "[-]" ) // harness.js
		sa[ i ] = sb.join( "" ) // harness.js
		n -= sb.length - 1 // harness.js
	} // harness.js
	ss = sa.join( "`" ) // harness.js
 // harness.js
	var si = "" // harness.js
	while ( nIndent-- ) // harness.js
	    si = si + "&nbsp;" // harness.js
 // harness.js
	ss = ss // harness.js
			.replace( />/g, "" ) // harness.js
	    	.replace( /`[~`]*`/g, "`" ) // harness.js
	    	.replace( /`/g, "<br>" ) // harness.js
	    	.replace( /~/g, si ) // harness.js
	    	.replace( /}}/g, ">" ) // harness.js
	    	.replace( /<i>/g, "<span style=\"font-style: italic; font-size: 7pt\">" ) // harness.js
	    	.replace( /<\/i>/g, "</span>" ) // harness.js
 // harness.js
	element( nInstance, "response" + 0 ).innerHTML = // harness.js
	    "" // harness.js
		// + sLastDIDRequested + " -- " + nStatus // harness.js
		+ ss // harness.js
		+ "<br>" + element( nInstance, "response" + 0 ).innerHTML // harness.js
} // harness.js
 // harness.js
 // harness.js
/** // harness.js
 *  Show applet's response to a web services request from us. // harness.js
 */ // harness.js
 // harness.js
var gaCallStatus    = [] // harness.js
 // harness.js
function // harness.js
showSerializedResponse( // harness.js
	nInstance,				// Instance of the Java applet // harness.js
	nID,					// Request ID // harness.js
	sDescr, 			    // Request description // harness.js
	sSerializedResponse )	// Status text (as ";key:value" pairs) // harness.js
{ // harness.js
	// Make the response more readable, based on its format, which we can // harness.js
	//  infer from its first character // harness.js
	var sFormat	= "" // harness.js
 // harness.js
	// Keep track of call status // harness.js
	if ( sDescr == "subscribe" ) { // harness.js
		var	o	= parseSubscribeResponse( sSerializedResponse ) // harness.js
 // harness.js
		if ( o.ID != "" && o.state != "" && o.remote != "" && o.dir != "" ) { // harness.js
		    var	iCall 		= -1 // harness.js
			var iCallEmpty  = -1 // harness.js
		    for ( var i in gaCallStatus ) { // harness.js
		        var os  = gaCallStatus[ i ] // harness.js
		        if ( os == null ) // harness.js
		            iCallEmpty = i // harness.js
				else if ( os.ID == o.ID ) { // harness.js
		            iCall = i // harness.js
		            break // harness.js
				} // harness.js
			} // harness.js
			if ( iCall < 0 ) // harness.js
			    iCall = ( iCallEmpty < 0 ) ? gaCallStatus.length : iCallEmpty // harness.js
 // harness.js
		    gaCallStatus[ iCall ] = ( o.state == "DELETED" ) ? null : o // harness.js
		} // harness.js
 // harness.js
		var s   = "" // harness.js
		for ( var i in gaCallStatus ) { // harness.js
		    var o	= gaCallStatus[ i ] // harness.js
		    if ( o != null ) // harness.js
		        s += "<br><a onclick=selectCall(" + nInstance + "," + o.ID + ")>" + o.ID + "</a> " // harness.js
					+ (( o.dir == goCallDirectionIndex.rx ) ? "&lt;" : "&gt;" ) // harness.js
		            + " " + o.remote + " " + o.state // harness.js
		} // harness.js
		if ( s == "" ) // harness.js
		    s = "<br>No calls." // harness.js
 // harness.js
		element( nInstance, "callList" ).innerHTML = s // harness.js
	} // harness.js
 // harness.js
	switch ( sSerializedResponse.charAt( 0 )) { // harness.js
 // harness.js
	case ";": // harness.js
		sFormat = "keyval" // harness.js
		sSerializedResponse = // harness.js
			sSerializedResponse // harness.js
				.replace( /;Id:[^;]*/, "" ) // harness.js
			    .replace( /MajorErrorCode:([^;]*);Message:([^;]*);MinorErrorCode:([^;]*)/, // harness.js
			        "Error $1.$3:$2" ) // harness.js
		   		.replace( /:/g, ": " ) // harness.js
		   		.substr( 1 ) // harness.js
				.split( ";" ) // harness.js
				.join( "<br>" ) // harness.js
		break // harness.js
 // harness.js
	case "&": // harness.js
		sFormat = "URL" // harness.js
		sSerializedResponse = // harness.js
			sSerializedResponse // harness.js
				.substr( 1 ) // harness.js
		break // harness.js
 // harness.js
	case "<": // harness.js
		sFormat = "XML" // harness.js
		sSerializedResponse = // harness.js
			sSerializedResponse // harness.js
	        	.replace( /</g, "&lt;" ) // harness.js
	        	.replace( /\n/g, "<br>" ) // harness.js
		break // harness.js
 // harness.js
	default: // harness.js
		break // harness.js
	} // harness.js
 // harness.js
	with ( element( nInstance, "response" + (( sDescr == "subscribe" ) ? "Status" : "" ))) { // harness.js
		innerHTML = // harness.js
	    	"" // harness.js
			+ "<span style=\"color: red\">ID " + nID + " (" + sDescr + "):</span><br>" // harness.js
			+ sSerializedResponse // harness.js
			+ "<hr>" // harness.js
			+ innerHTML // harness.js
	} // harness.js
} // harness.js
	
// --- callInfo.js ------------------------------------------------------------- 	
	
function // callInfo.js
processCallInfo( // callInfo.js
	o ) // callInfo.js
{ // callInfo.js
	var	iCall // callInfo.js
 // callInfo.js
	// Keep track of the best candidate slot for this call // callInfo.js
	var	oSlot	= // callInfo.js
		{ iCall		:  0 // callInfo.js
		, nLevel	: -1 // callInfo.js
		, nAge		:  0 // callInfo.js
		} // callInfo.js
 // callInfo.js
	// We don't know which call slot this call should appear in // callInfo.js
	o.call = 0 // callInfo.js
 // callInfo.js
	var	nNow	= nowSec() // callInfo.js
	for ( iCall = 0; ++iCall <= gnCalls; ) { // callInfo.js
		var	sCallID	= getCallInfo( iCall, "callID" ) // callInfo.js
 // callInfo.js
		// This is definitely this call's slot // callInfo.js
		if ( sCallID == o.ID ) { // callInfo.js
			o.call = iCall // callInfo.js
			break // callInfo.js
		} // callInfo.js
 // callInfo.js
		// Is this the best candidate slot we've seen so far? // callInfo.js
		var	oCandidate		= // callInfo.js
			{ iCall		: iCall // callInfo.js
			, nLevel	: // callInfo.js
				/* 	// May be unnecessary or more confusing than it's worth // callInfo.js
				( iCall == giCurrentCall ) ? 0 : // callInfo.js
				// */ // callInfo.js
				gaoStateMachine[ getCallInfo( iCall, "state" )].autocommitLevel // callInfo.js
			, nAge		: nNow - getCallInfo( iCall, "secCallEnd" ) // callInfo.js
			} // callInfo.js
		// If we've seen no candidates yet, or this tab is in a state whose autocommit preference is higher // callInfo.js
		//  than the best we've seen so far, or this is at the same level as the best we've seen so far // callInfo.js
		//  but went on-hook longer ago // callInfo.js
		var	nLevelDiff	= oCandidate.nLevel - oSlot.nLevel // callInfo.js
		if ( nLevelDiff > 0 // callInfo.js
				|| ( nLevelDiff == 0 && oCandidate.nAge > oSlot.nAge )) // callInfo.js
		{ logme( 10, "Best candidate now is " + oCandidate.iCall + ": " + oCandidate.nLevel + " @ " + oCandidate.nAge) // callInfo.js
			// This is now our best candidate // callInfo.js
			oSlot = oCandidate // callInfo.js
		} // callInfo.js
		// This is definitely some other call's slot // callInfo.js
		if ( sCallID != "" ) // callInfo.js
			continue // callInfo.js
 // callInfo.js
		// This is the slot of a call that is not active // callInfo.js
		// TODO: What if a state change comes in just after call goes on-hook?  // callInfo.js
		// TODO: Does off-hook even matter? // callInfo.js
//		if ( !getCallInfo( iCall, "bOffHook" ) // callInfo.js
//				&& !( o.dir == "In"  && o.state == "RINGING" ) // callInfo.js
//				&& !( o.dir == "Out" && o.state == "PENDING" )) // callInfo.js
//			continue // callInfo.js
 // callInfo.js
		// If this slot specifies a direction opposite to that of the call, don't use it   // callInfo.js
		if ( gsCallDirectionTest.indexOf( ";" + getCallInfo( iCall, "direction" ) + ";" + o.dir + ";" ) >= 0 ) // callInfo.js
			continue // callInfo.js
 // callInfo.js
		// This slot specifies either no direction or the same direction as this call // callInfo.js
		var	sDigits	= getCallInfo( iCall, "digits" ) // callInfo.js
		// If this slot specifies a different remote number from the call, it's some other call's slot // callInfo.js
		if ( sDigits != null && sDigits != o.remote ) // callInfo.js
			continue // callInfo.js
		// This slot specifies either no remote number or the same remote number as this call // callInfo.js
		// Grab the lowest such slot // callInfo.js
		o.call = iCall // callInfo.js
		// If the slot specifies the same remote number as the call and is associated with the same "dial" request, it's the same call // callInfo.js
//		if ( sDigits == o.remote && sDir == "Out" && getCallInfo( iCall, "reqID" ) == o.reqID )	// dhzdhz need to save req ID // callInfo.js
//			break // callInfo.js
		// If this slot specifies the same remote number as this call, assume it's the same call // callInfo.js
		// TODO: This will be fooled if multiple calls with the same direction and remote number are outstanding // callInfo.js
		if ( sDigits != null ) // callInfo.js
			break // callInfo.js
		// This slot specifies no remote number // callInfo.js
	} // callInfo.js
 // callInfo.js
	var z = "" // callInfo.js
	for ( var e in o ) // callInfo.js
		if ( e != "_" ) // callInfo.js
			z += " " + e + "=" + o[ e ] // callInfo.js
	logme( 10, "Call info:" + z.replace( /;/g, " " )) // callInfo.js
 // callInfo.js
	// No call slots available or we got a new call with an unexpected direction // callInfo.js
	iCall = o.call // callInfo.js
	if ( iCall == 0 ) { // callInfo.js
		iCall = oSlot.iCall // callInfo.js
		logme( 1, "Haven't seen this call before; using slot #" + iCall + " (after autocommitting if needed)") // callInfo.js
		// Send tab a "please commit your record" message, just in case it's not in Idle // callInfo.js
		handleEvent( iCall, "A Autocommit" ) // callInfo.js
	} // callInfo.js
 // callInfo.js
	// Perform a state transition, based on what M5 says the call's state is // callInfo.js
	// TODO: What if this is a repetition of state info we already have? // callInfo.js
	handleEvent( iCall, "M " + o.state ) // callInfo.js
 // callInfo.js
	// Load the slot with any information we have // callInfo.js
	// If Suitelet has just started up and "listCalls" tells us we're on a call, pretend we already knew that // callInfo.js
	// TODO: Need a more elegant way to test for "jumped from Idle to some other state" // callInfo.js
//	if ( getCallInfo( iCall, "statePrev" ) == "Idle" && ( o.state == "HOLDING" || o.state == "CONNECTED" )) // callInfo.js
//		setCallInfo( iCall, // callInfo.js
//			{ _				: null // callInfo.js
//			, statePrev		: "On Call" // callInfo.js
//			, secCallStart	: nowSec() - o.duration // callInfo.js
//			, disposition	: "Complete" // callInfo.js
//			, direction		: o.dir // callInfo.js
//			}) // callInfo.js
//		setCallInfo( iCall, "timer", -( nowSec() - o.duration )) // callInfo.js
		// TODO: Unfortunately, no way to know how long we've been on hold // callInfo.js
//		if ( o.state == "HOLDING" ) // callInfo.js
//			setCallInfo( iCall, "secHoldStart", nowSec() )	// This is done for us automatically // callInfo.js
	// TODO dhzdhz: Every time we go off hold, accumulate hold timer into call record, in case call panel has to be restarted before end of call // callInfo.js
 // callInfo.js
	// If we have never seen this call before, fill in additional info // callInfo.js
	if ( getCallInfo( iCall, "callID" ) == "" ) {		// TODO: Null would be better, but setCallInfo likes to translate null to empty string  // callInfo.js
		var	nSecCallStart	= nNow - o.duration // callInfo.js
		var	dStartTime	= new Date() // callInfo.js
		dStartTime.setTime( nSecCallStart * 1000 ) // callInfo.js
 // callInfo.js
		// If he has started typing a subject, use it; otherwise, set a default subject  // callInfo.js
		var	sSubject	= nlapiGetFieldValue( getNsObjectName( "field", iCall, "subject" )) // callInfo.js
		if ( sSubject == "" ) // callInfo.js
			sSubject = "Call on " + formatDateTime( dStartTime, "m/d/yy @ h:nn aa" ).replace( /@/, "at" ) // callInfo.js
				// + (( gnDebug > 0 ) ? " (M5 ID " + o.ID + ")" : "" )	// TODO: Delete the M5 ID from this and move into goText // callInfo.js
 // callInfo.js
		// Attach this call ID to this slot // callInfo.js
		setCallInfo( iCall, // callInfo.js
			{ _				: null // callInfo.js
			, callID		: o.ID // callInfo.js
			, digits		: o.remote // callInfo.js
			, number		: formatPhone( o.remote ) // callInfo.js
			, direction		: o.dir // callInfo.js
			, duration		: o.duration // callInfo.js
			, secCallStart	: nSecCallStart // callInfo.js
			, subject		: sSubject // callInfo.js
			}) // callInfo.js
 // callInfo.js
		// Do a reverse lookup on this phone number: show the contact (if any) who has that number // callInfo.js
//		updateFieldContents( getNsObjectName( "field", o.call, "matches" ), "number", remote ) // callInfo.js
 // callInfo.js
		// Load the record for the call (if any), or create one if none // callInfo.js
		createPhoneCallRecord( iCall, o.ID, o.remote, dStartTime ) // callInfo.js
//		setCallInfo( iCall, "bDirty", true ) // callInfo.js
	} // callInfo.js
} // callInfo.js
 // callInfo.js
 // callInfo.js
function // callInfo.js
getCallInfo( // callInfo.js
	iCall, // callInfo.js
	sKey, // callInfo.js
	bGetVisibleText )	// Get visible text, if any? (default = false) // callInfo.js
{ // callInfo.js
	if ( arguments.length < 3 ) // callInfo.js
		bGetVisibleText = false // callInfo.js
 // callInfo.js
	var	v	= null // callInfo.js
 // callInfo.js
	var	oCallInfo	= gaoCall[ iCall ] // callInfo.js
	if ( typeof( oCallInfo ) != "undefined" ) { // callInfo.js
		oCallInfo = oCallInfo[ sKey ] // callInfo.js
		if ( typeof( oCallInfo ) != "undefined" ) // callInfo.js
			v = ( bGetVisibleText ) ? oCallInfo.sVisibleText : oCallInfo.vValue // callInfo.js
	} // callInfo.js
 // callInfo.js
	// If we were unable to read it for some reason, return null // callInfo.js
	if ( typeof( v ) == "undefined" ) // callInfo.js
		v = null // callInfo.js
 // callInfo.js
	return ( v ) // callInfo.js
} // callInfo.js
 // callInfo.js
 // callInfo.js
/** // callInfo.js
 *	Set a property of the given call. // callInfo.js
 * // callInfo.js
 *	If the value is null, then what happens to the property depends on its type: // callInfo.js
 *		A pulldown ("select") property loses its selection array and is set to the empty string // callInfo.js
 *		A non-numeric property is set to the empty string // callInfo.js
 *		A numeric property is set to zero // callInfo.js
 * // callInfo.js
 * @param iCall // callInfo.js
 * @param sKey // callInfo.js
 * @param vValue // callInfo.js
 * @return // callInfo.js
 */ // callInfo.js
 // callInfo.js
function // callInfo.js
setCallInfo( // callInfo.js
	iCall, // callInfo.js
	sKey,		// Key (or object containing multiple key/value pairs) // callInfo.js
	vValue )	// (Does not exist if sKey is an object consisting of key/value pairs) // callInfo.js
{ // callInfo.js
	// Can pass in an object of key/value pairs to set // callInfo.js
	if ( typeof( sKey ) == "object" ) { // callInfo.js
		for ( var sK in sKey ) // callInfo.js
			if ( sK != "_" ) // callInfo.js
				setCallInfo( iCall, sK, sKey[ sK ]) // callInfo.js
		return // callInfo.js
	} // callInfo.js
 // callInfo.js
	// Never set any property to an undefined value // callInfo.js
	if ( typeof( vValue ) == "undefined" ) // callInfo.js
		vValue = ""		// dhzdhz Is this a better value than null? // callInfo.js
 // callInfo.js
	// Is the property tied to an onscreen control? // callInfo.js
	var	bIsOnscreen			= ( typeof( gaoCallField[ sKey ]) != "undefined" ) // callInfo.js
	// Is the property tied to an onscreen selector? // callInfo.js
	var	bIsSelector			= ( bIsOnscreen && gaoCallField[ sKey ].type == "select" ) // callInfo.js
 // callInfo.js
	// Setting an onscreen selector's option list to a set containing zero choices is the same as clearing it   // callInfo.js
	if ( bIsSelector && vValue != null && typeof( vValue ) == "object" && vValue.length == 0 ) // callInfo.js
		vValue = null // callInfo.js
 // callInfo.js
	// Is the value null? // callInfo.js
	var	bIsNull				= ( vValue == null ) // callInfo.js
	// Is the value empty? // callInfo.js
	var	bIsEmpty			= ( bIsNull || vValue == "" ) // callInfo.js
	// Are we setting an onscreen selector's option list? // callInfo.js
	var	bSettingOptionList	= ( bIsSelector && !bIsNull && typeof( vValue ) == "object" ) // callInfo.js
	// Are we clearing an onscreen selector's option list? // callInfo.js
	var	bClearingOptionList	= ( bIsSelector && bIsNull ) // callInfo.js
	// Are we making a legitimate selection from an onscreen selector?  (Note that the empty string is not a legitimate key) // callInfo.js
	var	bSelectingOption	= ( bIsSelector && !( bClearingOptionList || bSettingOptionList || bIsEmpty )) // callInfo.js
 // callInfo.js
/* // callInfo.js
	// Setting to null or empty string is shorthand for clearing // callInfo.js
	if ( bNotARef ) // callInfo.js
		// Use the correct initialization value for this field // callInfo.js
		vValue = ( bIsOnscreen ) ? gaoCallField[ sKey ].sDefault : null // callInfo.js
// */ // callInfo.js
 // callInfo.js
										// dhzdhz handle booleans as well // callInfo.js
 // callInfo.js
	// If there's no entry for this call in the array, add one // callInfo.js
	var	oCallInfo		= gaoCall[ iCall ]		// This is an alias for the call info structure in the array // callInfo.js
	if ( typeof( oCallInfo ) == "undefined" ) // callInfo.js
		oCallInfo = gaoCall[ iCall ] = {} // callInfo.js
 // callInfo.js
	// TODO: If clearing option list, do a different test; then again, vValueWas will never be the same as vValue, which is null // callInfo.js
	// If setting to same value that's already there, do nothing // callInfo.js
	var	vValueWas	= getCallInfo( iCall, sKey ) // callInfo.js
	if ( vValue == vValueWas ) // callInfo.js
		return // callInfo.js
		 // callInfo.js
/* // callInfo.js
	// If this value does not correspond to an onscreen control // callInfo.js
	if ( !bIsOnscreen ) { // callInfo.js
		// Set the value as a primitive // callInfo.js
		oCallInfo[ sKey ] = vValue // callInfo.js
		return // callInfo.js
	} // callInfo.js
// */ // callInfo.js
 // callInfo.js
	// Else set the value, and indicate that it might need updating on the screen // callInfo.js
	if ( typeof( oCallInfo[ sKey ]) == "undefined" ) // callInfo.js
		oCallInfo[ sKey ] = {} // callInfo.js
	var	oCallInfoProp = oCallInfo[ sKey ]				// Create an alias for the property within the call info structure // callInfo.js
 // callInfo.js
	// If we're either setting or clearing an option list (as opposed to selecting an entry or setting a non-list property) // callInfo.js
	if ( bSettingOptionList || bClearingOptionList ) { // callInfo.js
		// Set/clear the option list // callInfo.js
		oCallInfoProp.aOption = vValue // callInfo.js
		oCallInfoProp.bOptionsDirty = true // callInfo.js
 // callInfo.js
		// Now that we've changed the option list, we must change the property // callInfo.js
		//  (even if we've changed the option list to what it already was) // callInfo.js
 // callInfo.js
		// If the list has at least one entry, auto-select the first entry // callInfo.js
		if ( bSettingOptionList ) { // callInfo.js
			vValue = vValue[ 0 ][ 0 ] // callInfo.js
			bIsEmpty = ( vValue == "" ) // callInfo.js
		} // callInfo.js
		// Else set the property to null // callInfo.js
		else { // callInfo.js
			vValue = null // callInfo.js
			bIsEmpty = bIsNull = true // callInfo.js
		} // callInfo.js
	} // callInfo.js
 // callInfo.js
	// At this point, if we've just set an option list, vValue is the lookup value of the first item in the list. // callInfo.js
	// Calls to action (e.g., "Select one") typically use an empty string as their lookup key. // callInfo.js
 // callInfo.js
	// If the value is null, convert it to the property's default value // callInfo.js
	if ( !bClearingOptionList && bIsNull ) // callInfo.js
		// TODO: If the property is numeric, set it to 0, not the empty string; and what about booleans? and should we use the default values from the tables in defines.js? // callInfo.js
		// TODO: Actually, don't automatically set numerics to 0 (e.g., recID and callID); it would be better for each property to define its own "here's what null means" // callInfo.js
		vValue = "" // callInfo.js
 // callInfo.js
	// Set the property // callInfo.js
	oCallInfoProp.vValue = vValue // callInfo.js
	oCallInfoProp.bDirty = true // callInfo.js
 // callInfo.js
	// If the property has an option list, capture the first piece of visible text whose key matches the value // callInfo.js
	//  (CAUTION:  We have no way of knowing whether the option list was altered after he chose the value) // callInfo.js
	if ( oCallInfoProp.aOption != null ) { // callInfo.js
		for ( var i in oCallInfoProp.aOption ) { // callInfo.js
			if ( oCallInfoProp.aOption[ i ][ 0 ] == vValue ) { // callInfo.js
				oCallInfoProp.sVisibleText = oCallInfoProp.aOption[ i ][ 1 ] // callInfo.js
				break // callInfo.js
			} // callInfo.js
		} // callInfo.js
	} // callInfo.js
 // callInfo.js
	// Certain fields cascade into additional fields // callInfo.js
	var	oSet	= {} // callInfo.js
	var	s		= null // callInfo.js
 // callInfo.js
	switch ( sKey ) { // callInfo.js
 // callInfo.js
	case "number": // callInfo.js
		// If the only thing that's changed is the formatting, treat it as unchanged // callInfo.js
		if ( getPhoneDigits( vValueWas ) == getPhoneDigits( vValue )) // callInfo.js
			break // callInfo.js
 // callInfo.js
		oSet = listFieldsToClear( "matches" ) // callInfo.js
 // callInfo.js
		// We're done if he cleared the field // callInfo.js
		if ( bIsEmpty ) // callInfo.js
			break // callInfo.js
 // callInfo.js
		// If we're here, it's because he gave a non-empty value // callInfo.js
 // callInfo.js
		// Look it up to see whether we have any matches // callInfo.js
		var	aoMatch	= getContactsGivenNumber( vValue ) // callInfo.js
		var	aaMatch	= [] // callInfo.js
		switch ( aoMatch.length ) { // callInfo.js
		case 0:		s = "noMatches"		; break		// No matches: insert "no matches" // callInfo.js
		case 1:							; break // callInfo.js
		default:	s = "selectContact"	; break		// More than one match: insert "please select" // callInfo.js
		} // callInfo.js
		if ( s != null ) // callInfo.js
			aaMatch.push( // callInfo.js
				[ "" // callInfo.js
				, goText[ s ] // callInfo.js
				]) // callInfo.js
		for ( var i in aoMatch ) // callInfo.js
			aaMatch.push( // callInfo.js
				[ aoMatch[ i ].recType + "#" + aoMatch[ i ].recID // callInfo.js
				, aoMatch[ i ].visibleText // callInfo.js
				]) // callInfo.js
		oSet.matches = aaMatch // callInfo.js
		break // callInfo.js
 // callInfo.js
	case "matches": // callInfo.js
		oSet = listFieldsToClear( "speakingto,company" ) // callInfo.js
 // callInfo.js
		// We're done if he hasn't actually selected a match; i.e., if any of the following are true: // callInfo.js
		//	- He just selected "Select contact" or "No matches" (they use a lookup key of "") // callInfo.js
		//	- He just cleared the lookup list // callInfo.js
		//	- He just set a new lookup list containing more than one entry // callInfo.js
		//	- He just set a new lookup list containing only the entry "No matches" // callInfo.js
		//		(in which case we've just auto-selected that entry) // callInfo.js
		if ( bIsEmpty // callInfo.js
				|| bClearingOptionList // callInfo.js
				|| ( bSettingOptionList && oCallInfoProp.aOption.length > 1 )) // callInfo.js
			break // callInfo.js
 // callInfo.js
		// If we're here, we have a contact (either because he just // callInfo.js
		//  selected it or because there's only one match and it was auto-selected) // callInfo.js
 // callInfo.js
		// We'll copy his choice into the "speaking to" field // callInfo.js
 // callInfo.js
		// Get record type and ID // callInfo.js
		var	a			= vValue.split( "#" ) // callInfo.js
		var	sRecType	= a[ 0 ] // callInfo.js
		var	nRecID		= a[ 1 ] // callInfo.js
		// Look up this record's information // callInfo.js
		var	oRec		= nlapiLoadRecord( sRecType, nRecID ) // callInfo.js
		if ( oRec == null ) // callInfo.js
			break // callInfo.js
 // callInfo.js
		// If this is a person (possibly associated with a company) // callInfo.js
		if ( isOneOf( sRecType, ",contact,employee" )) { // callInfo.js
			// Set "speaking to" and "contact" to this person // callInfo.js
			oSet.speakingto = oSet.contact = nRecID // callInfo.js
			// Set "company" to the company he's associated with (if any) // callInfo.js
			oSet.company = oRec.getFieldValue( "company" ) // callInfo.js
		} // callInfo.js
 // callInfo.js
		// Else this is a company (with no person) // callInfo.js
		else { // callInfo.js
			// Set "company" to this company // callInfo.js
			oSet.company = nRecID // callInfo.js
			// Set "contact" to the primary contact // callInfo.js
			oSet.contact = oRec.getFieldValue( "contact" ) // callInfo.js
		} // callInfo.js
			//dhzdhz lookup: multiple // callInfo.js
		break // callInfo.js
 // callInfo.js
	case "speakingto": // callInfo.js
		oSet = listFieldsToClear( "title" ) // callInfo.js
 // callInfo.js
		// We're done if he cleared the field // callInfo.js
		if ( bIsEmpty ) // callInfo.js
			break // callInfo.js
 // callInfo.js
		// If we're here, it's because he gave a non-empty value // callInfo.js
 // callInfo.js
		// Look up the contact's title // callInfo.js
		if ( vValue == "" || vValue == 0 ) // callInfo.js
			break // callInfo.js
		var	sRecType	= "contact" // callInfo.js
		var	oRec		= nlapiLoadRecord( sRecType, vValue ) // callInfo.js
		if ( oRec == null ) // callInfo.js
			break // callInfo.js
		oSet.title   = oRec.getFieldValue( "title" ) // callInfo.js
		break // callInfo.js
 // callInfo.js
	case "company": // callInfo.js
		oSet = listFieldsToClear( "contact,supportcase,transaction" ) // callInfo.js
 // callInfo.js
		// We're done if he cleared the field // callInfo.js
		if ( bIsEmpty ) // callInfo.js
			break // callInfo.js
 // callInfo.js
		// If we're here, it's because he gave a non-empty value // callInfo.js
 // callInfo.js
		// Look up the company's support cases and transaction // callInfo.js
		if ( vValue == "" || vValue == 0 ) // callInfo.js
			break // callInfo.js
		// TODO: Sometimes throws an exception (e.g., if it's a company but not a customer) // callInfo.js
		var	sRecType	= "customer"	// dhzdhz This is not part of the selection value of the contact pulldown // callInfo.js
		var	oRec		= nlapiLoadRecord( sRecType, vValue ) // callInfo.js
		if ( oRec == null ) // callInfo.js
			break // callInfo.js
		oSet.supportcase = oRec.getFieldValue( "supportcase" )	//dhzdhz lookup: multiple // callInfo.js
		oSet.transaction = oRec.getFieldValue( "transaction" )	//dhzdhz lookup: multiple // callInfo.js
		break // callInfo.js
 // callInfo.js
	default: // callInfo.js
		break // callInfo.js
	} // callInfo.js
 // callInfo.js
	// Some fields are to be cleared; do them first // callInfo.js
	var	oSet2	= {} // callInfo.js
	var	sK // callInfo.js
	var	vV // callInfo.js
	for ( sK in oSet ) { // callInfo.js
		vV = oSet[ sK ] // callInfo.js
		if ( vV == null ) // callInfo.js
			resetCallInfo( iCall, sK ) // callInfo.js
		else // callInfo.js
			oSet2[ sK ] = vV // callInfo.js
	} // callInfo.js
 // callInfo.js
	// Other fields are to be set; do them now // callInfo.js
	for ( sK in oSet2 ) // callInfo.js
		setCallInfo( iCall, sK, oSet2[ sK ]) // callInfo.js
} // callInfo.js
 // callInfo.js
 // callInfo.js
function // callInfo.js
resetCallInfo( // callInfo.js
	iCall, // callInfo.js
	sKey,		// Key (or array containing multiple key names) // callInfo.js
	bOnCall )	// Starting a call (default: no)? // callInfo.js
{ // callInfo.js
	// Handle optional arguments // callInfo.js
	if ( arguments.length < 3 ) // callInfo.js
		bOnCall = false // callInfo.js
 // callInfo.js
	// Can pass in an array of keys to reset // callInfo.js
	if ( typeof( sKey ) == "object" ) { // callInfo.js
		for ( var iKey in sKey ) // callInfo.js
			resetCallInfo( iCall, sKey[ iKey ], bOnCall ) // callInfo.js
		return // callInfo.js
	} // callInfo.js
 // callInfo.js
	vValue = gaoCallProperty[ sKey ] // callInfo.js
	vValue = ( typeof( vValue ) == "undefined" ) ? null // callInfo.js
		   : ( bOnCall )						 ? vValue.vInitOnCall // callInfo.js
		   :									   vValue.vDefaultValue // callInfo.js
 // callInfo.js
	setCallInfo( iCall, sKey, vValue ) // callInfo.js
} // callInfo.js
 // callInfo.js
 // callInfo.js
function // callInfo.js
displayCallInfo( // callInfo.js
	iCall, // callInfo.js
	bForceUpdateAll )   // May not be needed // callInfo.js
{ // callInfo.js
	if ( arguments.length < 1 ) // callInfo.js
		iCall = giCurrentCall // callInfo.js
 // callInfo.js
	if ( arguments.length < 2 ) // callInfo.js
		bForceUpdateAll = false // callInfo.js
 // callInfo.js
	// If this is the log tab, there's nothing to do // callInfo.js
	if ( iCall < 1 || iCall > gnCalls ) // callInfo.js
		return // callInfo.js
 // callInfo.js
		// dhzdhz TEST // callInfo.js
	gaoCall[ iCall ].duration.bDirty = true // callInfo.js
 // callInfo.js
	// If we're on hold, force the state field to update, because it also shows the hold timer // callInfo.js
	var	bOnHold	= ( getCallInfo( iCall, "bOnHold" ) == "true" ) // callInfo.js
	if ( bOnHold ) // callInfo.js
		gaoCall[ iCall ].state.bDirty = true // callInfo.js
 // callInfo.js
	for ( var sKey in gaoCallField ) { // callInfo.js
		if ( !bForceUpdateAll && !gaoCall[ iCall ][ sKey ].bDirty && !gaoCall[ iCall ][ sKey ].bOptionsDirty ) // callInfo.js
			continue // callInfo.js
 // callInfo.js
		// We only update certain field types; buttons are updated when we change state, and labels are never updated // callInfo.js
		if ( !isOneOf( gaoCallField[ sKey ].type, ",text,select,textarea" )) // callInfo.js
			continue // callInfo.js
 // callInfo.js
		var	sFieldName	= getNsObjectName( "field", iCall, sKey ) // callInfo.js
		var	vValue		= getCallInfo( iCall, sKey ) // callInfo.js
 // callInfo.js
		// If it's a select field and the list of options has changed // callInfo.js
		if ( bForceUpdateAll || gaoCall[ iCall ][ sKey ].bOptionsDirty ) { // callInfo.js
			// Create a dropdown of the options // callInfo.js
			setDropdown( sFieldName, gaoCall[ iCall ][ sKey ].aOption ) // callInfo.js
			gaoCall[ iCall ][ sKey ].bOptionsDirty = false // callInfo.js
		} // callInfo.js
 // callInfo.js
		// If the actual value of the field has changed // callInfo.js
		if ( bForceUpdateAll || gaoCall[ iCall ][ sKey ].bDirty ) { // callInfo.js
			switch ( sKey ) { // callInfo.js
 // callInfo.js
			case "state": // callInfo.js
				// If on hold, show hold time // callInfo.js
				if ( bOnHold ) // callInfo.js
					vValue = vValue + " (" + formatDuration( getCallInfo( iCall, "secHoldDuration" ), "m:ss" ) + ")" // callInfo.js
//				vValue += getCallInfo( iCall, "bOnHold" )// dhzdhz // callInfo.js
				break // callInfo.js
 // callInfo.js
			case "duration": // callInfo.js
				// Blank duration if zero // callInfo.js
				vValue = ( nz( vValue, 0 ) == 0 ) ? "" : formatDuration( vValue ) // callInfo.js
				break // callInfo.js
 // callInfo.js
			default: // callInfo.js
				break // callInfo.js
			} // callInfo.js
 // callInfo.js
			gaoCallField[ sKey ].fScreenControl.set( sFieldName, vValue, false ) // callInfo.js
			gaoCall[ iCall ][ sKey ].bDirty = false // callInfo.js
		} // callInfo.js
	} // callInfo.js
 // callInfo.js
	// If we're on a call, show additional info about it // callInfo.js
/*	// Allow in all builds // callInfo.js
	if ( isOneOf( gsBuildType, "dt" )) // callInfo.js
// */ // callInfo.js
		if ( gnDebug > 0 ) { // callInfo.js
			var	sM5ID	= getCallInfo( iCall, "callID" ) // callInfo.js
			var	recID	= getCallInfo( iCall, "recID" ) // callInfo.js
			var	s	= "" // callInfo.js
				"Slot " + iCall // callInfo.js
				// TODO: Make a guess at which phone line the call is on // callInfo.js
				+ ": line " + getCallInfo( iCall, "line" ) // callInfo.js
				+ (( sM5ID != "" ) ? ", M5 ID " + sM5ID : "" ) // callInfo.js
				+ (( recID != "" ) ? ", NS ID " + recID : "" ) // callInfo.js
			nlapiSetFieldValue( getNsObjectName( "log", "debug", "infoid" ), s ) // callInfo.js
		} // callInfo.js
} // callInfo.js
 // callInfo.js
 // callInfo.js
function // callInfo.js
listFieldsToClear( // callInfo.js
	sFieldNames ) // callInfo.js
{ // callInfo.js
	var	oSet		= {} // callInfo.js
	var	asFieldName	= sFieldNames.split( "," ) // callInfo.js
	for ( var i in asFieldName ) // callInfo.js
		oSet[ asFieldName[ i ]] = null // callInfo.js
 // callInfo.js
	return ( oSet ) // callInfo.js
} // callInfo.js
	
// --- NetSuiteDB.js ------------------------------------------------------------- 	
	
/** // NetSuiteDB.js
 *	NetSuite database. // NetSuiteDB.js
 */ // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
/** // NetSuiteDB.js
 *	Get the external ID used to index a phone call, given the M5 call ID and the approximate start time. // NetSuiteDB.js
 * // NetSuiteDB.js
 *	The external ID is designed so that it sorts chronologically. // NetSuiteDB.js
 * // NetSuiteDB.js
 *	The approximate start time is computed by subtracting the current call duration from the computer's // NetSuiteDB.js
 *	current time.  Depending on network latency and computer clock accuracy, this time may be in error // NetSuiteDB.js
 *	by several seconds.  For this reason, we truncate the seconds value to :00 (and indicate that we have // NetSuiteDB.js
 *	done so by setting the seconds value to an invalid value; namely, :99). // NetSuiteDB.js
 * // NetSuiteDB.js
 *	If the call actually started very close to the top of the minute, the above strategy may sometimes // NetSuiteDB.js
 *	cause a miss (e.g., :10:59 -> :10:99 while :11:00 -> :11:99), so if our caller has failed to find a // NetSuiteDB.js
 *	phone call having the specified start time, try subtracting one minute (if the seconds value is :00 // NetSuiteDB.js
 *	through :29) or adding one minute (if the seconds value is :30 through :59). // NetSuiteDB.js
 */ // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
getPhoneCallExternalID( // NetSuiteDB.js
	nCallID, // NetSuiteDB.js
	dStartTime, // NetSuiteDB.js
	bFuzzySearch )	// Do a fuzzy search (default: no)? // NetSuiteDB.js
{ // NetSuiteDB.js
	// Set default values // NetSuiteDB.js
	bFuzzySearch = bFuzzySearch || false // NetSuiteDB.js
 // NetSuiteDB.js
	// If doing a fuzzy search, look one minute ahead or behind, depending on seconds value // NetSuiteDB.js
	if ( bFuzzySearch ) // NetSuiteDB.js
		dStartTime.setTime( dStartTime.getTime() + (( dStartTime.getUTCSeconds() < 30 ) ? 1 * 60 * 1000 : ( -1 * 60 * 1000 ))) // NetSuiteDB.js
 // NetSuiteDB.js
	// Find the start time of the call, truncated to the previous minute, in UTC (yymmddhhnn) // NetSuiteDB.js
	var	sStartTimeUTC	= "" // NetSuiteDB.js
		+ right(       dStartTime.getUTCFullYear() , 2 ) // NetSuiteDB.js
		+ right( 100 + dStartTime.getUTCMonth() + 1, 2 ) // NetSuiteDB.js
		+ right( 100 + dStartTime.getUTCDate()	   , 2 ) // NetSuiteDB.js
		+ right( 100 + dStartTime.getUTCHours()	   , 2 ) // NetSuiteDB.js
		+ right( 100 + dStartTime.getUTCMinutes()  , 2 ) // NetSuiteDB.js
//		+ right( 100 + dStartTime.getUTCSeconds()  , 2 ) // NetSuiteDB.js
 // NetSuiteDB.js
	// Plug in "99" for the seconds and append the call ID // NetSuiteDB.js
	return ( sStartTimeUTC + "99" + right( "000000000" + nCallID, 9 ))	// TODO: Is this length excessive? // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
createPhoneCallRecord( // NetSuiteDB.js
	iCall, // NetSuiteDB.js
	nCallID, // NetSuiteDB.js
	sDigits, // NetSuiteDB.js
	dStartTime )	// Estimated start time // NetSuiteDB.js
{ // NetSuiteDB.js
	// If a phonecall record for this call already exists, load it // NetSuiteDB.js
	var	sExternalID	= getPhoneCallExternalID( nCallID, dStartTime ) // NetSuiteDB.js
	setCallInfo( iCall, "externalID", sExternalID ) // NetSuiteDB.js
	if ( loadPhoneCallRecord( iCall, sExternalID ) != null ) // NetSuiteDB.js
		return // NetSuiteDB.js
 // NetSuiteDB.js
	// No phonecall record for this call exists; perhaps our estimated start time was a little off; try a fuzzier search // NetSuiteDB.js
	sExternalID	= getPhoneCallExternalID( nCallID, dStartTime, true ) // NetSuiteDB.js
	if ( loadPhoneCallRecord( iCall, sExternalID ) != null ) { // NetSuiteDB.js
		setCallInfo( iCall, "externalID", sExternalID ) // NetSuiteDB.js
		return // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
	// No phonecall record for this call exists; create one // NetSuiteDB.js
 // NetSuiteDB.js
	//  NetSuite requires end date & time to be at least one minute later than start date & time, // NetSuiteDB.js
	//  so cheat end time forward (NetSuite times have a resolution of one minute) // NetSuiteDB.js
	var	dEndTime	= new Date() // NetSuiteDB.js
	dEndTime.setTime( dStartTime.getTime() + 1 * 60 * 1000 ) // NetSuiteDB.js
 // NetSuiteDB.js
	// Set fields // NetSuiteDB.js
	var	oFields	= // NetSuiteDB.js
		{ _													: null // NetSuiteDB.js
 // NetSuiteDB.js
		// Mandatory fields // NetSuiteDB.js
//		, assigned											: nlapiGetUser()	// "Organizer": Set automatically // NetSuiteDB.js
//		, owner												: nlapiGetUser()	// "Created By": Set automatically // NetSuiteDB.js
		, phone												: formatPhone( sDigits ) // NetSuiteDB.js
		, status											: getCallInfo( iCall, "status" ) // NetSuiteDB.js
		, title												: "-"				// TODO: Evidently can't be empty string // NetSuiteDB.js
 // NetSuiteDB.js
		// Fields that will never change during the call // NetSuiteDB.js
		, externalid										: sExternalID // NetSuiteDB.js
		, startdate											: nlapiDateToString( dStartTime ) // NetSuiteDB.js
		, starttime											: formatDateTime( dStartTime, "h:nn aa" ) // NetSuiteDB.js
		, timedevent										: "T" // NetSuiteDB.js
 // NetSuiteDB.js
		// Fields that may change during the call // NetSuiteDB.js
 // NetSuiteDB.js
		// If we set startdate and starttime, NetSuite requires us to set // NetSuiteDB.js
		//  enddate and endtime as well, even though the call isn't over yet // NetSuiteDB.js
		, enddate											: nlapiDateToString( dEndTime ) // NetSuiteDB.js
		, endtime											: formatDateTime( dEndTime, "h:nn aa" ) // NetSuiteDB.js
		} // NetSuiteDB.js
 // NetSuiteDB.js
	var	asFields	= // NetSuiteDB.js
		[ null // NetSuiteDB.js
 // NetSuiteDB.js
		// Fields that will never change during the call // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_id"				, nCallID // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_direction"		, getCallInfo( iCall, "direction" ) // NetSuiteDB.js
		] // NetSuiteDB.js
 // NetSuiteDB.js
	// Save the record right now, so that we'll have it even if the call panel terminates // NetSuiteDB.js
	logme( 10, "Creating record" )	// dhzdhz // NetSuiteDB.js
	var	oRec	= nlapiCreateRecord( "phonecall" ) // NetSuiteDB.js
	var	recID	= commitPhoneCallRecord( iCall, oRec, oFields, asFields ) // NetSuiteDB.js
	logme( 10, "Committed {" + recID + "}" )	// dhzdhz // NetSuiteDB.js
	setCallInfo( iCall, "recID", recID ) // NetSuiteDB.js
 // NetSuiteDB.js
	// Set initial values for the various fields that may change during the call // NetSuiteDB.js
	updatePhoneCallRecord( iCall )	 // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
updatePhoneCallRecord( // NetSuiteDB.js
	iCall ) // NetSuiteDB.js
{ // NetSuiteDB.js
	logme( 10, "updatePhoneCallRecord: Loading record" ) // dhzdhz // NetSuiteDB.js
	// It isn't necessarily an error not to have a record // NetSuiteDB.js
	var	recID	= getCallInfo( iCall, "recID" ) // NetSuiteDB.js
	var	oRec	= ( recID != null ) ? nlapiLoadRecord( "phonecall", recID ) : null // NetSuiteDB.js
	if ( oRec == null ) { // NetSuiteDB.js
		logme( 1, "Call #" + iCall + ": No phonecall record with ID " + recID ) // NetSuiteDB.js
		return // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
	// Get call duration and end time (so far) // NetSuiteDB.js
	var	nDurationSec	= getCallInfo( iCall, "duration" ) // NetSuiteDB.js
	// dhzdhz Should be reading start time out of CallInfo, not record // NetSuiteDB.js
	var	dEndTime		= new Date( oRec.getFieldValue( "startdate" ) + " " + oRec.getFieldValue( "starttime" )) // NetSuiteDB.js
	dEndTime.setSeconds( dEndTime.getSeconds() + nDurationSec ) // NetSuiteDB.js
	setCallInfo( iCall, "secCallEnd", timeSec( dEndTime )) // NetSuiteDB.js
	// NetSuite requires end date & time to be at least one minute later than start date & time // NetSuiteDB.js
	if ( nDurationSec < 60 ) // NetSuiteDB.js
		// Cheat end time forward (NetSuite times have a resolution of one minute) // NetSuiteDB.js
		dEndTime.setMinutes( dEndTime.getMinutes() + 1 ) // NetSuiteDB.js
	// TODO: Does NetSuite get confused if we cross out of daylight-saving time and the clock goes backward? // NetSuiteDB.js
 // NetSuiteDB.js
	var	nCompanyRef		= getCallInfo( iCall, "company" ) // NetSuiteDB.js
	var	nContactRef		= getCallInfo( iCall, "contact" ) // NetSuiteDB.js
	if ( nullif( nCompanyRef, "" ) == null ) // NetSuiteDB.js
		nContactRef = null // NetSuiteDB.js
 // NetSuiteDB.js
	var	oFields	= // NetSuiteDB.js
		{ _													: null // NetSuiteDB.js
 // NetSuiteDB.js
		// Fields that may change during the call // NetSuiteDB.js
		, company											: nCompanyRef	// Fills Related Info | Company and trickles into Participants | Participant // NetSuiteDB.js
		, contact											: nContactRef	// Fills Related Info | Contact and trickles into Participants | Contact // NetSuiteDB.js
		, enddate											: nlapiDateToString( dEndTime ) // NetSuiteDB.js
		, endtime											: formatDateTime( dEndTime, "h:nn aa" ) // NetSuiteDB.js
		, message											: nz( getCallInfo( iCall, "comments" )) // NetSuiteDB.js
		, priority											:     getCallInfo( iCall, "priority" ) // NetSuiteDB.js
		, supportcase										: nz( getCallInfo( iCall, "support_case" )) // NetSuiteDB.js
		, title												: nz( getCallInfo( iCall, "subject" )) // NetSuiteDB.js
		, transaction										: nz( getCallInfo( iCall, "transaction" )) // NetSuiteDB.js
		} // NetSuiteDB.js
 // NetSuiteDB.js
	var	asFields	= // NetSuiteDB.js
		[ null // NetSuiteDB.js
 // NetSuiteDB.js
		// Fields that may change during the call // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_disposition"	, getCallInfo( iCall, "disposition" ) // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_duration"		, nDurationSec // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_matches"		, getCallInfo( iCall, "matches", true ) // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_result"			, getCallInfo( iCall, "result" ) // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_call_speaking_to"	, getCallInfo( iCall, "speakingto" ) // NetSuiteDB.js
		, gsNetSuiteEventPrefix + "cti_hold_duration"		, getCallInfo( iCall, "secHoldTotal" ) // NetSuiteDB.js
		] // NetSuiteDB.js
 // NetSuiteDB.js
	// Update record // NetSuiteDB.js
	commitPhoneCallRecord( iCall, oRec, oFields, asFields ) // NetSuiteDB.js
//	setCallInfo( iCall, "rPhoneCall", oRec ) // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
commitPhoneCallRecord( // NetSuiteDB.js
	iCall, // NetSuiteDB.js
	oRec, // NetSuiteDB.js
	oFields, // NetSuiteDB.js
	asFields ) // NetSuiteDB.js
{ // NetSuiteDB.js
	var	recID // NetSuiteDB.js
 // NetSuiteDB.js
	// Remove any leading nulls // NetSuiteDB.js
	while ( asFields.length != 0 && asFields[ 0 ] == null ) // NetSuiteDB.js
		asFields.shift() // NetSuiteDB.js
 // NetSuiteDB.js
	// Read all asFields entries as key/value pairs and attach to oFields  // NetSuiteDB.js
	var	nFieldsTimes2	= asFields.length // NetSuiteDB.js
	for ( var i = 0; i < nFieldsTimes2; i += 2 ) // NetSuiteDB.js
		oFields[ asFields[ i ]] = asFields[ i + 1 ] // NetSuiteDB.js
 // NetSuiteDB.js
	// Strange behavior in NetSuite:  If we write a phonerec record but do not explicitly set its // NetSuiteDB.js
	//  "phone" field (which contains the phone number), then the write operation automatically // NetSuiteDB.js
	//  overwrites that field with the phone number (if any) corresponding to the value in the // NetSuiteDB.js
	//  record's "contact" field.  Workaround:  Every time we write the record without explicitly // NetSuiteDB.js
	//  setting the "phone" field, read the field and then write that same value back to it. // NetSuiteDB.js
	if ( typeof( oFields[ "phone" ]) == "undefined" ) // NetSuiteDB.js
		oFields[ "phone" ] = oRec.getFieldValue( "phone" ) // NetSuiteDB.js
 // NetSuiteDB.js
	// In the record, set all fields named in oFields // NetSuiteDB.js
	for ( var sFieldName in oFields ) { // NetSuiteDB.js
		var	vValue	= oFields[ sFieldName ] // NetSuiteDB.js
	//	if ( vValue != null ) { // NetSuiteDB.js
			oRec.setFieldValue( sFieldName, vValue ) // NetSuiteDB.js
	//	} // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
/* // NetSuiteDB.js
	var	zz = "oFields:" // NetSuiteDB.js
	for ( var x in oFields ) // NetSuiteDB.js
		zz += "\n " + x + " {" + oFields[ x ] + "}" // NetSuiteDB.js
	zz += "\n\nCall info #" + iCall + ":" // NetSuiteDB.js
	for ( var x in gaoCall[ iCall ]) // NetSuiteDB.js
		zz += "\n " + x + " {" + getCallInfo( iCall, x ) + "}" // NetSuiteDB.js
	zz += "\n\nNetSuite record:" // NetSuiteDB.js
	var	asPC = // NetSuiteDB.js
		( "accesslevel,assigned,company,completeddate,contact,createddate,customform,enddate,endtime,externalid" // NetSuiteDB.js
		+ "," + "group,lastmodifieddate,message,owner,phone,priority,startdate,starttime,status,supportcase,timedevent,title,transaction" // NetSuiteDB.js
		+ "," + gsNetSuiteEventPrefix + "cti_call_disposition" // NetSuiteDB.js
		+ "," + gsNetSuiteEventPrefix + "cti_call_duration" // NetSuiteDB.js
		+ "," + gsNetSuiteEventPrefix + "cti_call_result" // NetSuiteDB.js
		+ "," + gsNetSuiteEventPrefix + "cti_hold_duration" // NetSuiteDB.js
		).split(",") // NetSuiteDB.js
	for ( var x in asPC ) // NetSuiteDB.js
		zz += "\n " + asPC[ x ] + " {" + oRec.getFieldValue( asPC[ x ]) + "}" // NetSuiteDB.js
	logme( 1, zz ) // NetSuiteDB.js
// */ // NetSuiteDB.js
	recID = nlapiSubmitRecord( oRec, false, true )	// dhzdhz -- cut off args? // NetSuiteDB.js
	logme( 10, "commitPhoneCallRecord: returned " + recID + "!") // NetSuiteDB.js
 // NetSuiteDB.js
	return ( recID ) // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
loadPhoneCallRecord( // NetSuiteDB.js
	iCall, // NetSuiteDB.js
	sExternalID ) // NetSuiteDB.js
{ // NetSuiteDB.js
	var	oRec	= null // NetSuiteDB.js
 // NetSuiteDB.js
	// Search for an existing phonecall record with this external ID // NetSuiteDB.js
	var	aoPC	= doSelectWhereEq( "phonecall", "externalid", sExternalID ) // NetSuiteDB.js
	if ( aoPC != null ) { // NetSuiteDB.js
		// Read existing phonecall record fields into call panel // NetSuiteDB.js
		var	nID	= aoPC[ 0 ].getId() // NetSuiteDB.js
		setCallInfo( iCall, "recID", nID ) // NetSuiteDB.js
 // NetSuiteDB.js
		// TODO: Copying these fields from the record to the call info structure must be done in a specific order, // NetSuiteDB.js
		//  since so many values cascade into one another (e.g., "matches" feeds "speaking to"); or else have a way // NetSuiteDB.js
		//  of turning off cascading, so that we can set values and have them stick // NetSuiteDB.js
		oRec = nlapiLoadRecord( "phonecall", nID ) // NetSuiteDB.js
		var	o	= goMapping.PhonecallRecordToCallInfo // NetSuiteDB.js
		for ( var e in o ) // NetSuiteDB.js
			if ( o[ e ] != "matches" )		// TODO: Should be able to handle this, but it's going from a text field to a lookup value // NetSuiteDB.js
				setCallInfo( iCall, o[ e ], oRec.getFieldValue( e )) // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
	return ( oRec ) // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
getContactsGivenNumber( // NetSuiteDB.js
	sNumber ) // NetSuiteDB.js
{ // NetSuiteDB.js
	if ( sNumber == "" ) // NetSuiteDB.js
		sNumber = null // NetSuiteDB.js
 // NetSuiteDB.js
	var	aoHit	= ( sNumber == null ) ? null : nlapiSearchGlobal( getPhoneDigits( sNumber )) // NetSuiteDB.js
	if ( aoHit == null ) // NetSuiteDB.js
		aoHit = [] // NetSuiteDB.js
 // NetSuiteDB.js
	// Build list of matches // NetSuiteDB.js
	var	aoContact	= [] // NetSuiteDB.js
	for ( var iHit in aoHit ) { // NetSuiteDB.js
		var	sType	= aoHit[ iHit ].getValue( "type" ).toLowerCase() // NetSuiteDB.js
		// TODO: We only want contact, employee, or customer // NetSuiteDB.js
		var	nID		= aoHit[ iHit ].getId() // NetSuiteDB.js
		aoContact.push( // NetSuiteDB.js
			{ _				: null // NetSuiteDB.js
			, recType		: sType // NetSuiteDB.js
			, recID			: nID // NetSuiteDB.js
			, visibleText	: aoHit[ iHit ].getValue( "name" ) + " (" + sType + ")" // NetSuiteDB.js
			}) // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
	// Sort multiple hits by contact name and type, ascending // NetSuiteDB.js
	aoContact.sort( // NetSuiteDB.js
		function ( // NetSuiteDB.js
			a, // NetSuiteDB.js
			b ) // NetSuiteDB.js
		{ // NetSuiteDB.js
			a = a.visibleText + a.recType // NetSuiteDB.js
			b = b.visibleText + b.recType // NetSuiteDB.js
				return (( a < b ) ? -1 : ( a > b ) ? 1 : 0 ) // NetSuiteDB.js
		}) // NetSuiteDB.js
 // NetSuiteDB.js
	return ( aoContact ) // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
/** // NetSuiteDB.js
 *	Look up the M5-relevant details of a NetSuite user. // NetSuiteDB.js
 * // NetSuiteDB.js
 * @return // NetSuiteDB.js
 */ // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
getUsersM5Info( // NetSuiteDB.js
	nUserID	) // NetSuiteDB.js
{ // NetSuiteDB.js
 	// Search for an existing cti_user record with this user ID // NetSuiteDB.js
	// TODO: Creation of this array can be done once, at startup // NetSuiteDB.js
	var asColumnName	= [] // NetSuiteDB.js
	for ( var e in gasPhoneInfo ) // NetSuiteDB.js
		if ( e != "_" ) // NetSuiteDB.js
			asColumnName.push( gasPhoneInfo[ e ]) // NetSuiteDB.js
 // NetSuiteDB.js
	var	aoUser	= doSelectWhereEq( gsNetSuiteUserType, gasPhoneInfo.userID, nUserID, asColumnName ) // NetSuiteDB.js
	if ( aoUser == null ) { // NetSuiteDB.js
	   	 logme( 1, "User " + nUserID + " not found in CTI_User list" ) // NetSuiteDB.js
	   	 popUpMessage( goText.userUnknown, null, goText.contactSysAdmin ) // NetSuiteDB.js
 // NetSuiteDB.js
	   	 return ( null ) // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
	// Read existing cti_user record fields // NetSuiteDB.js
	var	oU	= aoUser[ 0 ] // NetSuiteDB.js
	var	oUser	= {} // NetSuiteDB.js
	for ( var e in gasPhoneInfo ) // NetSuiteDB.js
		if ( e != "_" ) // NetSuiteDB.js
			oUser[ e ] = oU.getValue( gasPhoneInfo[ e ]) // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
/* dhzdhz		 // NetSuiteDB.js
var	a	= [] // NetSuiteDB.js
for ( var e in gasPhoneInfo ) // NetSuiteDB.js
   if ( e != "_" ) // NetSuiteDB.js
	   a.push( gasPhoneInfo[ e ]) // NetSuiteDB.js
var	o1	= nlapiLookupField( gsNetSuiteUserType, currentUserID, a )  // NetSuiteDB.js
var	o	= {} // NetSuiteDB.js
for ( var e in gasPhoneInfo ) // NetSuiteDB.js
	if ( e != "_" ) // NetSuiteDB.js
		o[ e ] = o1[ gasPhoneInfo[ e ]] // NetSuiteDB.js
*/ // NetSuiteDB.js
		             // TODO     if ( sUser == null || sPassword == null || sNumber == null ) // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
	return ( oUser ) // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
/** // NetSuiteDB.js
 *	Select columns from records; akin to a SQL SELECT having a // NetSuiteDB.js
 *	WHERE clause of the form "WHERE {field} = {value}". // NetSuiteDB.js
 * // NetSuiteDB.js
 *	If no column names are given, then only the record's ID will be returned. // NetSuiteDB.js
 */ // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
doSelectWhereEq( // NetSuiteDB.js
	sRecordType,	// Record type (akin to "FROM" clause) // NetSuiteDB.js
	sFieldName,		// (opt.) Search filter field (akin to the {field} in "WHERE {field} = {value}") // NetSuiteDB.js
	vValue,			// (opt.) Search filter value (akin to the {value} in "WHERE {field} = {value}") // NetSuiteDB.js
	asColumnName )	// (opt.) Column names (akin to "SELECT" clause) // NetSuiteDB.js
{ // NetSuiteDB.js
	sFieldName = sFieldName || null // NetSuiteDB.js
	vValue = vValue || null // NetSuiteDB.js
	asColumnName = asColumnName || null // NetSuiteDB.js
 // NetSuiteDB.js
	var	oFilter	= null // NetSuiteDB.js
	if ( sFieldName != null ) // NetSuiteDB.js
		oFilter = new nlobjSearchFilter( sFieldName, null, "is", vValue ) // NetSuiteDB.js
 // NetSuiteDB.js
	return ( doSelect( sRecordType, oFilter, asColumnName )) // NetSuiteDB.js
} // NetSuiteDB.js
 // NetSuiteDB.js
 // NetSuiteDB.js
/** // NetSuiteDB.js
 *	Select columns from records; akin to a SQL SELECT. // NetSuiteDB.js
 * // NetSuiteDB.js
 *	If no column names are given, then only the record's ID will be returned. // NetSuiteDB.js
 */ // NetSuiteDB.js
 // NetSuiteDB.js
function // NetSuiteDB.js
doSelect( // NetSuiteDB.js
	sRecordType,	// Record type (akin to "FROM" clause) // NetSuiteDB.js
	oFilter,		// (opt.) Search filter (akin to "WHERE" clause) // NetSuiteDB.js
	asColumnName )	// (opt.) Column names (akin to "SELECT" clause) // NetSuiteDB.js
{ // NetSuiteDB.js
	oFilter = oFilter || null // NetSuiteDB.js
	asColumnName = asColumnName || null // NetSuiteDB.js
 // NetSuiteDB.js
	var	aoCol	= null // NetSuiteDB.js
 // NetSuiteDB.js
	if ( asColumnName != null ) { // NetSuiteDB.js
		aoCol	= [] // NetSuiteDB.js
		for ( var i in asColumnName ) // NetSuiteDB.js
			aoCol.push( new nlobjSearchColumn( asColumnName[ i ])) // NetSuiteDB.js
	} // NetSuiteDB.js
 // NetSuiteDB.js
	return ( nlapiSearchRecord( sRecordType, null, oFilter, aoCol )) // NetSuiteDB.js
} // NetSuiteDB.js
	
// --- NetSuiteUI.js ------------------------------------------------------------- 	
	
/** // NetSuiteUI.js
 *	NetSuite user interface. // NetSuiteUI.js
 */ // NetSuiteUI.js
 // NetSuiteUI.js
 // NetSuiteUI.js
/** // NetSuiteUI.js
 *	Generate an internal name for one of our NetSuite objects. // NetSuiteUI.js
 * // NetSuiteUI.js
 *	@return	string // NetSuiteUI.js
 *		Name // NetSuiteUI.js
 * // NetSuiteUI.js
 *	@param	string			sType // NetSuiteUI.js
 *		Type of object (e.g., "field") (arbitrary) // NetSuiteUI.js
 *	@param	string			sFamily // NetSuiteUI.js
 *		Family of object (e.g., tab number) (arbitrary) // NetSuiteUI.js
 *	@param	string			sID // NetSuiteUI.js
 *		Identifier of object within its type and family (arbitrary) // NetSuiteUI.js
 */ // NetSuiteUI.js
 // NetSuiteUI.js
function // NetSuiteUI.js
getNsObjectName( // NetSuiteUI.js
	sType, // NetSuiteUI.js
	sFamily, // NetSuiteUI.js
	sID, // NetSuiteUI.js
	sTail ) // NetSuiteUI.js
{ // NetSuiteUI.js
	if ( sType != "" ) // NetSuiteUI.js
		sType += "_" // NetSuiteUI.js
	if ( sFamily != "" ) // NetSuiteUI.js
		sFamily += "_" // NetSuiteUI.js
 // NetSuiteUI.js
	if ( arguments.length < 4 || sTail == null ) // NetSuiteUI.js
		sTail = "" // NetSuiteUI.js
 // NetSuiteUI.js
	var	sName	= gsNetSuiteObjNamePrefix + sType + sFamily + sID + sTail // NetSuiteUI.js
 // NetSuiteUI.js
	// Element names must be prefixed with "custpage", unique, lowercase, and cannot contain // NetSuiteUI.js
	//  any non-alphanumeric characters (except for the underscore character).  In debug // NetSuiteUI.js
	//  mode, enforce the last two of these restrictions. // NetSuiteUI.js
	if ( gnDebug != 0 ) // NetSuiteUI.js
		sName = toIdentifier( sName ).toLowerCase() // NetSuiteUI.js
 // NetSuiteUI.js
	return ( sName ) // NetSuiteUI.js
} // NetSuiteUI.js
 // NetSuiteUI.js
 // NetSuiteUI.js
/** // NetSuiteUI.js
 *	Get a reference to one of our NetSuite objects. // NetSuiteUI.js
 * // NetSuiteUI.js
 *	@return	object // NetSuiteUI.js
 *		The object // NetSuiteUI.js
 * // NetSuiteUI.js
 *	@param	string			sType // NetSuiteUI.js
 *		Type of object (e.g., "field") (arbitrary) // NetSuiteUI.js
 *	@param	string			sFamily // NetSuiteUI.js
 *		Family of object (e.g., tab number) (arbitrary) // NetSuiteUI.js
 *	@param	string			sID // NetSuiteUI.js
 *		Identifier of object within its type and family (arbitrary) // NetSuiteUI.js
 *	@param	string			sTail // NetSuiteUI.js
 *		Tail of identifier, if any (often begins with an underscore) (arbitrary) // NetSuiteUI.js
 */ // NetSuiteUI.js
 // NetSuiteUI.js
function // NetSuiteUI.js
getNsObject( // NetSuiteUI.js
	sType, // NetSuiteUI.js
	sFamily, // NetSuiteUI.js
	sID, // NetSuiteUI.js
	sTail ) // NetSuiteUI.js
{ // NetSuiteUI.js
	return ( getNsObjectById( getNsObjectName( sType, sFamily, sID, sTail ))) // NetSuiteUI.js
} // NetSuiteUI.js
 // NetSuiteUI.js
 // NetSuiteUI.js
function // NetSuiteUI.js
getNsObjectByName( // NetSuiteUI.js
	sName ) // NetSuiteUI.js
{ // NetSuiteUI.js
	return ( document.forms[ "main_form" ].elements[ sName ]) // NetSuiteUI.js
} // NetSuiteUI.js
 // NetSuiteUI.js
 // NetSuiteUI.js
function // NetSuiteUI.js
getNsObjectById( // NetSuiteUI.js
	sID ) // NetSuiteUI.js
{ // NetSuiteUI.js
	return ( findElementByID( sID )) // NetSuiteUI.js
} // NetSuiteUI.js
 // NetSuiteUI.js
 // NetSuiteUI.js
/** // NetSuiteUI.js
 *	Set the values of an onscreen dropdown control, and select the first // NetSuiteUI.js
 *	item (unless there are no items). // NetSuiteUI.js
 * // NetSuiteUI.js
 *	The array of entries has the form: // NetSuiteUI.js
 *		[[ selection value, visible text], ... ] // NetSuiteUI.js
 *	Null entries are ignored.  E.g.: // NetSuiteUI.js
 *		[ null // NetSuiteUI.js
 *		, [  1,	"Positive"	] // NetSuiteUI.js
 *		, [  0,	"Zero		] // NetSuiteUI.js
 *		, [ -1,	"Negative"	] // NetSuiteUI.js
 *		] // NetSuiteUI.js
 */ // NetSuiteUI.js
 // NetSuiteUI.js
function // NetSuiteUI.js
setDropdown( // NetSuiteUI.js
	sFieldName,		// Name of the onscreen control // NetSuiteUI.js
	aaEntry,		// Array of entries (optional) (if none, remove all dropdown entries)   // NetSuiteUI.js
	bUnique )		// Don't show duplicate entries (optional; default = false) // NetSuiteUI.js
{ // NetSuiteUI.js
	// Delete all entries in the onscreen control // NetSuiteUI.js
	nlapiRemoveSelectOption( sFieldName, null )  // NetSuiteUI.js
 // NetSuiteUI.js
	// If there are no entries to add, we're done // NetSuiteUI.js
	if ( arguments.length < 2 || aaEntry == null || aaEntry.length == 0 ) // NetSuiteUI.js
		return // NetSuiteUI.js
 // NetSuiteUI.js
	// Don't show any name more than once // NetSuiteUI.js
	if ( arguments.length < 3 ) // NetSuiteUI.js
		bUnique = false // NetSuiteUI.js
 // NetSuiteUI.js
	if ( bUnique ) { // NetSuiteUI.js
		var	sPrev	= null // NetSuiteUI.js
		for ( var iEntry in aaEntry ) { // NetSuiteUI.js
			var	s	= aaEntry[ iEntry ][ 1 ] // NetSuiteUI.js
			if ( s == sPrev ) // NetSuiteUI.js
				aaEntry[ iEntry ] = null // NetSuiteUI.js
			sPrev = s // NetSuiteUI.js
		} // NetSuiteUI.js
	} // NetSuiteUI.js
 // NetSuiteUI.js
	// Add entries, and select the first one // NetSuiteUI.js
	var	bSelect	= true // NetSuiteUI.js
	for ( var iEntry in aaEntry ) {		 // NetSuiteUI.js
		var	aEntry	= aaEntry[ iEntry ] // NetSuiteUI.js
		if ( aEntry == null ) // NetSuiteUI.js
			continue // NetSuiteUI.js
		nlapiInsertSelectOption( sFieldName, aEntry[ 0 ], aEntry[ 1 ], bSelect ) // NetSuiteUI.js
		bSelect = false // NetSuiteUI.js
	} // NetSuiteUI.js
} // NetSuiteUI.js
	
// --- M5.js ------------------------------------------------------------- 	
	
/** // M5.js
 *	M5. // M5.js
 */ // M5.js
 // M5.js
function // M5.js
processSubscribeChunk( // M5.js
	sSerializedResponse ) // M5.js
{ // M5.js
	// TODO: Should really just check for this once // M5.js
	// If this is the first response after we call subscribe, it doesn't contain anything interesting  // M5.js
	if ( sSerializedResponse.indexOf( ";Result:0" ) >= 0 ) // M5.js
		return // M5.js
 // M5.js
	processCallsInfo( sSerializedResponse ) // M5.js
} // M5.js
 // M5.js
 // M5.js
/** // M5.js
 *	Apply information that comes from either a "subscribe" response or a "listCalls" response. // M5.js
 */ // M5.js
 // M5.js
function // M5.js
processCallsInfo( // M5.js
	sSerializedResponse ) // M5.js
{ // M5.js
	// TODO parse out as new status and log it // M5.js
	var ao	= parseSubscribeResponse( sSerializedResponse ) // M5.js
 // M5.js
	// If it was an error, nothing to do // M5.js
	if ( ao == null ) // M5.js
		return // M5.js
 // M5.js
	// Not an error: process call information // M5.js
	ao.sort( // M5.js
		function ( // M5.js
			a, // M5.js
			b ) // M5.js
		{ // M5.js
			return ( b.duration - a.duration ) // M5.js
		}) // M5.js
	var	n	= ao.length // M5.js
 // M5.js
	for ( var i = 0; i < n; ++i ) // M5.js
		processCallInfo( ao[ i ]) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
m5CmdDial( // M5.js
	iCall ) // M5.js
{ // M5.js
	doM5Command( "dial", "Arguments", getCallInfo( iCall, "digits" ), "Arguments" ) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
m5CmdAnswer( // M5.js
	iCall ) // M5.js
{ // M5.js
	doM5Command( "answer", "Arguments", getCallInfo( iCall, "callID" ), "Arguments" ) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
m5CmdIgnore( // M5.js
	iCall ) // M5.js
{ // M5.js
	doM5Command( "ignore", "Arguments", getCallInfo( iCall, "callID" )) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
m5CmdEnd( // M5.js
	iCall, // M5.js
	i )		// Max. times to loop (opt.) // M5.js
{ // M5.js
	if ( getCallInfo( iCall, "callID" ) != "" ) { // M5.js
		doM5Command( "release", "Arguments", getCallInfo( iCall, "callID" )) // M5.js
		return // M5.js
	} // M5.js
 // M5.js
	// If we are very quick on the draw, we might End an outgoing call before we've even seen the PENDING subscribe chunk with the call ID; // M5.js
	//  if that happens, wait a little while and try again, but eventually just give up // M5.js
	if ( typeof( i ) == "undefined" ) // M5.js
		i = 10 // M5.js
	if ( i-- ) // M5.js
		setTimeout( 'tryCatchLog("' + "m5CmdEnd(" + iCall + "," + i + ")" + '")', 200 ) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
m5CmdHold( // M5.js
	iCall ) // M5.js
{ // M5.js
	doM5Command( "hold", "Arguments", getCallInfo( iCall, "callID" )) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
m5CmdResume( // M5.js
	iCall ) // M5.js
{ // M5.js
	doM5Command( "resume", "Arguments", getCallInfo( iCall, "callID" )) // M5.js
} // M5.js
 // M5.js
 // M5.js
 // M5.js
function // M5.js
dhzToDo( // M5.js
	iCall ) // M5.js
{ // M5.js
//	popUpDebug( "Not yet implemented" ) // M5.js
} // M5.js
 // M5.js
 // M5.js
function // M5.js
clkdDialOut( // M5.js
	iCall ) // M5.js
{ // M5.js
	// Format the "Number" field as an actual telephone number // M5.js
	var	sFieldName	= getNsObjectName( "field", iCall, "number" ) // M5.js
	var	sDigits		= getPhoneDigits( nlapiGetFieldValue( sFieldName )) // M5.js
	var	sNumber		= formatPhone( sDigits ) // M5.js
 // M5.js
	nlapiSetFieldValue( sFieldName, sNumber ) // M5.js
 // M5.js
	// If there aren't any actual digits, don't actually dial // M5.js
	if ( sNumber == "" ) // M5.js
		return // M5.js
 // M5.js
	setCallInfo( iCall, // M5.js
		{ _			: null // M5.js
		, digits	: sDigits // M5.js
		, number	: sNumber // M5.js
		}) // M5.js
 // M5.js
	// Dial // M5.js
	m5CmdDial( iCall ) // M5.js
 // M5.js
	// Transition to the "Dialing" state // M5.js
	setState( iCall, "Dialing" ) // M5.js
} // M5.js
 // M5.js
 // M5.js
var	clkdCommit			= dhzToDo // M5.js
 // M5.js
 // M5.js
var	phoneActionIAnswer	= m5CmdAnswer // M5.js
var	phoneActionIHangUp	= m5CmdEnd // M5.js
var	phoneActionIIgnore	= m5CmdIgnore // M5.js
var	phoneActionIRing	= dhzToDo // M5.js
var	phoneActionImBusy	= dhzToDo // M5.js
 // M5.js
var m5EventHeAnswers	= dhzToDo // M5.js
var m5EventHeHangsUp	= dhzToDo // M5.js
var	m5EventHeIgnores	= dhzToDo // M5.js
var	m5EventHeRings		= dhzToDo // M5.js
var	m5EventHesBusy		= dhzToDo // M5.js
	
// --- M5util.js ------------------------------------------------------------- 	
	
/** // M5util.js
 *  The Java applet is sending us the latest information it has regarding an // M5util.js
 *	M5 phone. // M5util.js
 * // M5util.js
 *  The information is in a semicolon-separated string of key/value pairs. // M5util.js
 *  Each key is a single character, followed immediately by its value: // M5util.js
 * // M5util.js
 *      s   state // M5util.js
 *      d   direction (i[n]/o[ut]) // M5util.js
 *      l   local (M5) phone number // M5util.js
 *      r   remote phone number // M5util.js
 *      t   time/duration (sec.) // M5util.js
 * // M5util.js
 *  Elements can occur in any order, and not all elements need be present. // M5util.js
 */ // M5util.js
 // M5util.js
function // M5util.js
phoneStatus( // M5util.js
	sStatus ) // M5util.js
{ // M5util.js
} // M5util.js
 // M5util.js
 // M5util.js
function // M5util.js
doM5Command( // M5util.js
	sCommand,				// Command name // M5util.js
	sParam1					// First parameter to the command (if any) // M5util.js
	// , ...                // Additional command parameters (if any) // M5util.js
	) // M5util.js
{ // M5util.js
	// Concatenate the command and all its parameters into an ampersand-separated string // M5util.js
	var args = Array.prototype.slice.call( arguments ) // M5util.js
	args.push( null ) // M5util.js
	args.shift()	// Get to sParam1; push User, "", Password, "" in front of it // M5util.js
	// TODO: Might be better to redefine javaScriptCallsOutToJava() such that if we don't pass User= and Password= at all (not just empty, as we do now) and we need them, then Java just recopies its existing ones // M5util.js
	args.unshift( "User", "", "Password", "" ) // M5util.js
	var	sParams	= "" // M5util.js
	var	bKey	= true // M5util.js
	// TODO: Have to do this way because for ( var i in args ) gives i out of order (0, 1, 4, 2, 3) in IE!  Are there other places we should do this? // M5util.js
	var	n		= args.length // M5util.js
	for ( var i = 0; i < n; ++i ) { // M5util.js
		var	sParam	= args[ i ]	// TODO: URL-encode? // M5util.js
		if ( sParam == null ) // M5util.js
			sParam = "" // M5util.js
		sParam = (( bKey ) ? "&" : "=" ) + sParam // M5util.js
		if ( sParam != "&" ) // M5util.js
			sParams += sParam // M5util.js
		bKey = !bKey // M5util.js
	} // M5util.js
 // M5util.js
	sendWebSvcRequest( 0, sCommand, sParams.substr( 1 ))	 // M5util.js
} // M5util.js
 // M5util.js
 // M5util.js
function // M5util.js
sendWebSvcRequest( // M5util.js
	nInstance, // M5util.js
	sCommand, // M5util.js
	sParams )   // Params, as "&key=value" pairs // M5util.js
{ // M5util.js
	// Serialize command and param list into URL format // M5util.js
	var	sCommandAndParams	=		// TODO: This may not be necessary // M5util.js
		( sCommand + "&" + sParams ) // M5util.js
//			.replace( / *~ */g, "&" ) // M5util.js
			.replace( /[& ]*$/, "" ) // M5util.js
			.replace( /[ =][ =]*/g, "=" ) // M5util.js
			.replace( /&&*/g, "&" ) // M5util.js
			.replace( /(=[^=&]*)=$/, "$1" ) // M5util.js
 // M5util.js
    // Certain web services will return multiple chunks // M5util.js
    var	bMultiChunks		= ( sCommand == "subscribe" ) // M5util.js
 // M5util.js
	// How long is too long for the applet to respond (msec) // M5util.js
	var nCmdTimeout			= 20000 // M5util.js
 // M5util.js
	// How long is too long for a web service to respond (msec) // M5util.js
	var nSvrTimeout			= 10000 // M5util.js
 // M5util.js
	// What format do we want the response in? // M5util.js
	var sResponseFormat     = "keyval"      // "XML", "URL", "keyval" // M5util.js
 // M5util.js
	// Ask the applet to generate a unique request ID // M5util.js
    var	nID					= +javaScriptCallsOutToJava( nInstance, "generate ID" ) // M5util.js
	if ( nID == 0 ) { // M5util.js
		logme( 1, "ERROR: Cannot generate ID" ) // M5util.js
		return // M5util.js
	} // M5util.js
 // M5util.js
	// Keep track of outstanding requests // M5util.js
	var sUser               = sCommandAndParams.replace( /.*&User=([^&]*)&.*/, "$1" ) // M5util.js
	var sCParam             = ( sCommand == "dial" ) ? " " + sUser : ""    // TODO: add phone number being called // M5util.js
	var ri                  = jReqInfo_constructor( sCommand, sCParam, bMultiChunks ) // M5util.js
	jReqInfo_push( nInstance, nID, ri ) // M5util.js
 // M5util.js
	// Ask the applet to schedule a call to the web service // M5util.js
	javaScriptCallsOutToJava( nInstance, // M5util.js
		"call web service", // M5util.js
	    nID, // M5util.js
		bMultiChunks, // M5util.js
		"",	//		nCmdTimeout,	// dhz // M5util.js
		"",	//		nSvrTimeout, // M5util.js
		"",	//		sResponseFormat, // M5util.js
		sCommandAndParams ) // M5util.js
} // M5util.js
 // M5util.js
 // M5util.js
// TODO: Rename; also parses listCalls response // M5util.js
// TODO: only works if format is key/value // M5util.js
 // M5util.js
function // M5util.js
parseSubscribeResponse( // M5util.js
	sStatus ) // M5util.js
{ // M5util.js
	var	ao	= [] // M5util.js
	var	a	= [] // M5util.js
 // M5util.js
	// Get number of errors // M5util.js
	sStatus = sStatus.split( ";ErrorCount:" )[ 1 ] // M5util.js
	var	n	= +sStatus.split( ";" )[ 0 ] // M5util.js
 // M5util.js
	// Display any errors // M5util.js
	if ( n != 0 ) { // M5util.js
		a = ( ";Id:" + sStatus ).split( ";Id:" ) // M5util.js
		n = a.length - 1 // M5util.js
		for ( var i = 0; ++i < n; ) { // M5util.js
			var o	= objectifyKeyValuePairs( "XXX:" + a[ i ], ";", ":" ) // M5util.js
			ao.push( "    * " + o.MajorErrorCode + "." + o.MinorErrorCode + ": " + o.Message ) // M5util.js
		} // M5util.js
		popUpMessage( ao.join( "\n\n" ), ( ao.length == 1 ) ? goText.m5ErrorHeaderSing : goText.m5ErrorHeaderPlur ) // M5util.js
 // M5util.js
		return ( null ) // M5util.js
	} // M5util.js
 // M5util.js
	// No errors; parse status // M5util.js
	a = sStatus.split( ";Ani:" ) // M5util.js
	n = a.length // M5util.js
	for ( var i = 0; ++i < n; ) { // M5util.js
		var o	= objectifyKeyValuePairs( "Ani:" + a[ i ], ";", ":" ) // M5util.js
		ao.push( // M5util.js
			{ _			: null // M5util.js
			, ID    	: o.Id // M5util.js
			, call		: -1 // M5util.js
			, state 	: o.State // M5util.js
			, remote    : o.Ani // M5util.js
			, dir       : ( left( o.Originated, 1 ) == "f" ) ? goCallDirectionIndex.rx : goCallDirectionIndex.tx // M5util.js
			, duration	: o.Duration // M5util.js
			}) // M5util.js
	} // M5util.js
 // M5util.js
	return ( ao ) // M5util.js
} // M5util.js
 // M5util.js
 // M5util.js
function // M5util.js
xlate( // M5util.js
	s ) // M5util.js
{ // M5util.js
	switch ( s ) { // M5util.js
	 // M5util.js
	case "call_ID": // M5util.js
	case "endpoint": // M5util.js
	case "ex_tn": // M5util.js
	    s = "Arguments" // M5util.js
	    break // M5util.js
 // M5util.js
	case "DID": // M5util.js
	    s = "User" // M5util.js
	    break // M5util.js
 // M5util.js
	case "password": // M5util.js
	    s = "Password" // M5util.js
	    break // M5util.js
 // M5util.js
	default: // M5util.js
	    break // M5util.js
	} // M5util.js
 // M5util.js
    return ( s ) // M5util.js
} // M5util.js
 // M5util.js
 // M5util.js
function // M5util.js
logIfDebug( // M5util.js
	s ) // M5util.js
{ // M5util.js
	return ( logme( 1, s ))	 // M5util.js
} // M5util.js
 // M5util.js
 // M5util.js
function // M5util.js
tryCatchLog( // M5util.js
	sStatement ) // M5util.js
{ // M5util.js
	return ( tryCatch( sStatement, "logIfDebug" )) // M5util.js
} // M5util.js
	
// --- util.js ------------------------------------------------------------- 	
	
/** // util.js
 *	Coalesce various "empty" values. // util.js
 */ // util.js
 // util.js
function // util.js
nz( // util.js
	s, // util.js
	d ) // util.js
{ // util.js
	if ( arguments.length < 2 ) // util.js
		d = "" // util.js
 // util.js
	return (( s == null || s == "" ) ? d : s ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
nullif( // util.js
	v, // util.js
	c ) // util.js
{ // util.js
	return (( v == c ) ? null : v ) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Split a string, ensuring that we return an array of at least n entries. // util.js
 *	In the absence of this call, a string with insufficient delimiters yields // util.js
 *	a short array. // util.js
 */ // util.js
 // util.js
function // util.js
splitEnsure( // util.js
	sString, // util.js
	sDelim, // util.js
	n ) // util.js
{ // util.js
	var	sDelims	= "" // util.js
	while ( n-- ) // util.js
		sDelims += sDelim // util.js
 // util.js
	return (( sString + sDelims ).split( sDelim )) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Call the given function if it exists, passing it all our arguments. // util.js
 * // util.js
 *	If the function does not exist, do nothing. // util.js
 * // util.js
 *	@param f // util.js
 *	@return // util.js
 */ // util.js
 // util.js
function // util.js
callFuncIfExists( // util.js
	f /*, // util.js
	... */ ) // util.js
{ // util.js
	if ( typeof( f ) == "undefined" ) // util.js
		return // util.js
 // util.js
	// Capture our arguments, minus "callFuncIfExists" // util.js
	//  (arguments is not an array, so it doesn't support the slice() method) // util.js
	var	avArg	= Array.prototype.slice.call( arguments ) // util.js
	avArg.shift() // util.js
	 // util.js
	return ( f.apply( this, avArg )) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
element( // util.js
	nInstance, // util.js
	sType ) // util.js
{ // util.js
	return ( findElementByID( elementName( nInstance, sType ))) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
elementName( // util.js
	nInstance, // util.js
	sType ) // util.js
{ // util.js
	return ( sType + "." + nInstance ) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Is the value in the list (case-sensitive)? // util.js
 * // util.js
 *	The first character in the list is the separator character; e.g., ",apple,bear,car". // util.js
 *	If the list consists entirely of single-character values, then the // util.js
 *	separator can be absent; e.g., "abc" = ",a,b,c". // util.js
 * // util.js
 *	@return	bool // util.js
 *		True iff the value is in the list // util.js
 *  // util.js
 *	@param	string			sValue // util.js
 *		Value to search for // util.js
 *	@param	string			sList // util.js
 *		List of possible values // util.js
 */ // util.js
	 // util.js
function // util.js
isOneOf( // util.js
	sValue, // util.js
	sList ) // util.js
{ // util.js
	var	sSep	= sList.charAt( 0 ) // util.js
	 // util.js
	if ( sList.lastIndexOf( sSep ) == 0 ) // util.js
		sSep = "" // util.js
 // util.js
	return (( sList + sSep ).indexOf( sSep + sValue + sSep ) >= 0 ) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Trim a string. // util.js
 * // util.js
 *	@return	string // util.js
 *		The input string, with leading and trailing spaces removed // util.js
 *  // util.js
 *	@param	string			s // util.js
 *		String to trim // util.js
 */ // util.js
	 // util.js
function // util.js
trim( // util.js
	s ) // util.js
{ // util.js
	return ( s.replace( /^\s+|\s+$/g, "" )) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Is the value numeric? // util.js
 * // util.js
 *	@return	boolean // util.js
 *		True if the value is numeric // util.js
 * // util.js
 *	@param	mixed			v // util.js
 *		Value to test // util.js
 */ // util.js
 // util.js
function // util.js
isNumeric( // util.js
	v ) // util.js
{ // util.js
	return ( typeof( v ) == "number" ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
isObject( // util.js
	v ) // util.js
{ // util.js
	return ( v && typeof( v ) == "object" ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
isArray( // util.js
	v ) // util.js
{  // util.js
	return ( isObject( v ) && v instanceof Array ) // util.js
} // util.js
 // util.js
 // util.js
//dhz This doesn't work properly with radio buttons. have I fixed it? // util.js
 // util.js
function // util.js
selected( // util.js
	o,	// The object // util.js
	s )	// (optional) Value to select (if missing, returns current selection) // util.js
{ // util.js
	// If this is a radio button, make sure we know the total number in the group // util.js
	if ( typeof( o.length ) == "undefined" ) { // util.js
		var	p	= o.ownerDocument.getElementsByName( o.name ) // util.js
		if ( typeof( p.length ) != "undefined" ) // util.js
			o = p // util.js
	} // util.js
 // util.js
	// If second parameter is present, do a set before the get // util.js
	if ( arguments.length > 1 ) { // util.js
		s = "" + nz( s ) // util.js
		if ( o.type == "select-one" ) { // util.js
			var i // util.js
			for ( i = o.length; i--; ) // util.js
				if ( unescape( o[ i ].value ) == s ) // util.js
					break // util.js
			o.selectedIndex = i // util.js
		} // util.js
		else // util.js
			for ( var i = o.length; i--; ) // util.js
				o[ i ].checked = ( unescape( o[ i ].value ) == s ) // util.js
	} // util.js
 // util.js
	if ( o.type == "select-one" ) // util.js
		return (( o.selectedIndex < 0 ) ? null : unescape( o[ o.selectedIndex ].value )) // util.js
 // util.js
	var s = "" // util.js
	for ( var i = o.length; i--; ) // util.js
		if ( o[ i ].checked ) // util.js
			s = s + "\t" + o[ i ].value // util.js
 // util.js
	return (( s == "" ) ? null : s.substr( 1 )) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Include a JavaScript file.  // util.js
 */ // util.js
 // util.js
function // util.js
include( // util.js
	sFile ) // util.js
{ // util.js
	document.write( '<script type="text/javascript" src="' + sFile + '"><\/script' ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
formatDuration( // util.js
	iDuration,		// Duration (sec) // util.js
	sFormat )		// Format // util.js
{ // util.js
	if ( typeof( sFormat ) == "undefined" ) // util.js
		sFormat = "hh:mm:ss" // util.js
 // util.js
	// Interpret a missing value as 0 // util.js
	if ( iDuration == null || iDuration == "" ) // util.js
		iDuration = "0" // util.js
 // util.js
	iDuration = parseInt( iDuration ) // util.js
 // util.js
	var sSec	= ( 100 + 			iDuration				% 60 + "" ).substr( 1 ) // util.js
	var sMin	= ( 100 + parseInt( iDuration /   60     )	% 60 + "" ).substr( 1 ) // util.js
	var sHr		= ( 100 + parseInt( iDuration / ( 60*60 ))		 + "" ).substr( 1 ) // util.js
 // util.js
	sDuration = sHr + ":" + sMin + ":" + sSec // util.js
 // util.js
	switch ( sFormat ) { // util.js
 // util.js
	case "hh:mm:ss": // util.js
		break // util.js
 // util.js
	case "mm:ss": // util.js
		sDuration = sDuration.replace( /^00:/, "" ) // util.js
		break // util.js
 // util.js
	case "m:ss": // util.js
		sDuration = sDuration.replace( /^00:/, "" ) // util.js
		if ( sDuration.length == 5 ) // util.js
			sDuration = sDuration.replace( /^0/, "" ) // util.js
		break // util.js
 // util.js
	default: // util.js
		logme( 1, 'ERROR: unknown format "' + sFormat + '" passed to formatDuration' ) // util.js
		break // util.js
	} // util.js
 // util.js
	return ( sDuration ) // util.js
} // util.js
 // util.js
 // util.js
// yyyy = 4-digit year // util.js
// yy	= 2-digit year // util.js
// mmmm	= month name // util.js
// mmm	= 3-letter month abbreviation // util.js
// mm	= 2-digit month // util.js
// m	= 1- or 2-digit month // util.js
// dd	= 2-digit date // util.js
// d	= 1- or 2-digit date // util.js
// wwww	= weekday name // util.js
// www	= 3-letter weekday abbreviation // util.js
// ww	= 2-letter weekday abbreviation // util.js
// w	= 1-letter weekday abbreviation (R = Thursday, U = Sunday) // util.js
// HH	= 2-digit hour (24-hour) // util.js
// H	= 1- or 2-digit hour (24-hour) // util.js
// hh	= 2-digit hour (12-hour) // util.js
// h	= 1- or 2-digit hour (12-hour) // util.js
// nn	= 2-digit minute // util.js
// n	= 1- or 2-digit minute // util.js
// ss	= 2-digit second // util.js
// s	= 1- or 2-digit second // util.js
// AA	= 2-letter AM/PM indicator // util.js
// A	= 1-letter AM/PM indicator // util.js
// aa	= 2-letter am/pm indicator // util.js
// a	= 1-letter am/pm indicator // util.js
// zzz	= 3-letter time zone // util.js
// zz	= 2-letter time zone (1-letter abbreviation plus "T") // util.js
// z	= 1-letter time zone // util.js
// all else	= literal // util.js
 // util.js
function // util.js
formatDateTime( // util.js
	dDate, // util.js
	sFormat ) // util.js
{ // util.js
	if ( arguments.length < 2 || sFormat == null ) // util.js
		sFormat = "www m/d/yy h:nn:ss AA zzz" // util.js
 // util.js
	var	nYear		= dDate.getFullYear()	// 4 digits // util.js
	var	nMonth		= dDate.getMonth() + 1	// 1..12 // util.js
	var	nDate		= dDate.getDate()		// 1..31 // util.js
	var	nWeekday	= dDate.getDay()		// 0..6 // util.js
	var	nHour24		= dDate.getHours()		// 0..23 // util.js
	var	nMinute		= dDate.getMinutes()	// 0..59 // util.js
	var	nSecond		= dDate.getSeconds()	// 0..59 // util.js
	var	sTimeZone	= left( dDate.toString().replace( /.*\(/, "" ), 3 ) // util.js
 // util.js
	var	sMonth		= [ "", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ][ nMonth ] // util.js
	var	sWeekday	= [ "Sun", "Mon", "Tues", "Wednes", "Thurs", "Fri", "Satur" ][ nWeekday ] + "day" // util.js
	var	sWeekday1	= mid( "UMTWRFS", nWeekday, 1 ) // util.js
	var	nHour12		= ( nHour24 + 11 ) % 12 + 1 // util.js
	var	sAP			= mid( "AP", ( nHour24 < 12 ) ? 0 : 1, 1 ) // util.js
	var	sAMPM		= sAP + "M" // util.js
	var	sTimeZone1	= left( sTimeZone, 1 ) // util.js
	var	sTimeZone2	= sTimeZone1 + "T" // util.js
 // util.js
	return ( // util.js
		sFormat // util.js
			.replace( /`/g, "`0" ) // util.js
			.replace( /</g, "`1" ) // util.js
			.replace( />/g, "`2" ) // util.js
			.replace( /[a-z]*/g, "<$&>" ) // util.js
			.replace( /></g, "" ) // util.js
			.replace( /<yyyy*>/g, nYear ) // util.js
			.replace( /<yy*>/g, right( nYear, 2 )) // util.js
			.replace( /<mmmm>/g, sMonth ) // util.js
			.replace( /<mmm>/g, left( sMonth, 3 )) // util.js
			.replace( /<mm>/g, right( 100 + nMonth, 2 )) // util.js
			.replace( /<m>/g, nMonth ) // util.js
			.replace( /<dd>/g, right( 100 + nDate, 2 )) // util.js
			.replace( /<d>/g, nDate ) // util.js
			.replace( /<wwww>/g, sWeekday ) // util.js
			.replace( /<www>/g, left( sWeekday, 3 )) // util.js
			.replace( /<ww>/g, left( sWeekday, 2 )) // util.js
			.replace( /<w>/g, sWeekday1 ) // util.js
			.replace( /<HH>/g, right( 100 + nHour24, 2 )) // util.js
			.replace( /<H>/g, nHour24 ) // util.js
			.replace( /<hh>/g, right( 100 + nHour12, 2 )) // util.js
			.replace( /<h>/g, nHour12 ) // util.js
			.replace( /<nn>/g, right( 100 + nMinute, 2 )) // util.js
			.replace( /<n>/g, nMinute ) // util.js
			.replace( /<ss>/g, right( 100 + nSecond, 2 )) // util.js
			.replace( /<s>/g, nSecond ) // util.js
			.replace( /<AA>/g, sAMPM ) // util.js
			.replace( /<A>/g, sAP ) // util.js
			.replace( /<aa>/g, sAMPM.toLowerCase() ) // util.js
			.replace( /<a>/g, sAP.toLowerCase() ) // util.js
			.replace( /<zzz>/g, sTimeZone ) // util.js
			.replace( /<zz>/g, sTimeZone2 ) // util.js
			.replace( /<z>/g, sTimeZone1 ) // util.js
			.replace( /[<>]/g, "" ) // util.js
			.replace( /`2/g, ">" ) // util.js
			.replace( /`1/g, "<" ) // util.js
			.replace( /`0/g, "`" ) // util.js
		) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
getPhoneDigits( // util.js
	sPhone ) // util.js
{ // util.js
	var	s	= "" // util.js
 // util.js
	sPhone = nz( sPhone ).replace( /[^0-9]/g, "" ) // util.js
 // util.js
	if ( sPhone.length == 11 ) { // util.js
//		s = sPhone.charAt( 0 ) + ""-"	// TODO: Or would we rather just not see the country prefix? // util.js
		sPhone = sPhone.substr( 1 ) // util.js
	} // util.js
 // util.js
	return ( sPhone ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
formatPhone( // util.js
	sPhone ) // util.js
{ // util.js
	sPhone = getPhoneDigits( sPhone ) // util.js
	if ( sPhone.length >= 10 ) // util.js
		sPhone = sPhone.substr( 0, 3 ) + "-" + sPhone.substr( 3, 3 ) + "-" + sPhone.substr( 6 ) // util.js
	else if ( sPhone.length >= 7 ) // util.js
		sPhone = sPhone.substr( 0, 3 ) + "-" + sPhone.substr( 3 ) // util.js
 // util.js
	return ( sPhone ) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Convert an arbitrary string to a string that can be used as an identifier. // util.js
 *	Case is preserved. // util.js
 * // util.js
 * @param s // util.js
 * @return // util.js
 */ // util.js
 // util.js
function // util.js
toIdentifier( // util.js
	s ) // util.js
{ // util.js
	return ( String( s ).replace( /[^a-z0-9_]/gi, "_" )) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
objectifyKeyValuePairs( // util.js
	sStr,		// String of key/value pairs // util.js
	sVEnd,		// String that separates one key/value pair from the next (e.g., newline) // util.js
	sKEnd )		// String that separates a key from its value (e.g., equals sign) // util.js
{ // util.js
	var	nKEndLen	= sKEnd.length // util.js
	var	o			= {} // util.js
	var	a			= sStr.split( sVEnd ) // util.js
 // util.js
	for ( var i in a ) { // util.js
		var	s	= a[ i ] // util.js
		var	j	= s.indexOf( sKEnd ) // util.js
		if ( j > 0 ) // util.js
			o[ s.substr( 0, j )] = s.substr( j + nKEndLen ) // util.js
	} // util.js
 // util.js
	return ( o ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
left( // util.js
	sStr,		// String // util.js
	nChars )	// Number of characters to extract from left end of string // util.js
{ // util.js
	return ( String( sStr ).substr( 0, nChars )) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
mid( // util.js
	sStr,		// String // util.js
	nStart,		// Position to start at (0-based) // util.js
	nChars )	// Number of characters to extract from middle of string (opt.) // util.js
{ // util.js
	if ( arguments.length < 3 ) // util.js
		return ( String( sStr ).substr( nStart )) // util.js
 // util.js
	return ( String( sStr ).substr( nStart, nChars )) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
right( // util.js
	sStr,		// String // util.js
	nChars )	// Number of characters to extract from right end of string // util.js
{ // util.js
	sStr = String( sStr ) // util.js
	nChars = sStr.length - nChars // util.js
 // util.js
	return (( nChars < 0 ) ? sStr : sStr.substr( nChars )) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Get the dimensions of the window's client area (the area bordered by the chrome). // util.js
 *	The client area includes any scroll bars. // util.js
 * // util.js
 * @return // util.js
 */ // util.js
 // util.js
/** // util.js
 * @author Garret Smith // util.js
 */ // util.js
 // util.js
 // util.js
IS_BODY_ACTING_ROOT = ( typeof( document ) != "undefined" && document.documentElement && document.documentElement.clientHeight === 0 ) // util.js
 // util.js
// Used to feature test Opera returning wrong values  // util.js
// for documentElement.clientHeight.  // util.js
function // util.js
isDocumentElementHeightOff( // util.js
	) // util.js
{  // util.js
    var d	= document // util.js
	  ,	div	= d.createElement( "div" ) // util.js
    div.style.height = "2500px" // util.js
    d.body.insertBefore( div, d.body.firstChild ) // util.js
    var b = ( d.documentElement.clientHeight > 2400 ) // util.js
    d.body.removeChild( div ) // util.js
 // util.js
    // Cache result // util.js
    isDocumentElementHeightOff = // util.js
    	function // util.js
    	( // util.js
    		) // util.js
    	{ // util.js
    		return ( b ) // util.js
    	} // util.js
 // util.js
    return ( isDocumentElementHeightOff() ) // util.js
} // util.js
 // util.js
var DOCUMENT_ELEMENT = "documentElement" // util.js
 // util.js
    /** @memberOf APE.dom // util.js
     * @name getScrollOffsets // util.js
     * @function // util.js
     * @return an object with <code>width</code> and <code>height</code>. // util.js
     * This will exhibit a bug in Mozilla, which is often 5-7 pixels off. // util.js
     */ // util.js
function // util.js
getScrollOffsets( // util.js
	win ) // util.js
{ // util.js
    win = win || window // util.js
    getScrollOffsets = // util.js
      	( "pageXOffset" in win ) // util.js
       	? // util.js
       		function // util.js
       		( // util.js
       			win ) // util.js
       		{ // util.js
               	win = win || window // util.js
 // util.js
               	return { left : win.pageXOffset, top : win.pageYOffset } // util.js
       		} // util.js
       	: // util.js
       		function // util.js
       		( // util.js
       			win ) // util.js
       		{ // util.js
               	win = win || window // util.js
               	var node = win.document[ IS_BODY_ACTING_ROOT ? "body" : DOCUMENT_ELEMENT ] // util.js
 // util.js
               	return { left : node.scrollLeft, top : node.scrollTop } // util.js
       		} // util.js
 // util.js
    return ( getScrollOffsets( win )) // util.js
} // util.js
 // util.js
    /** @memberOf APE.dom // util.js
     * @name getViewportDimensions // util.js
     * @function // util.js
     * @return an object with <code>width</code> and <code>height</code>. // util.js
     */ // util.js
function // util.js
getViewportDimensions( // util.js
	win ) // util.js
{ // util.js
	win = win || window // util.js
	var baseName = "document" // util.js
	  , nodeName = baseName // util.js
	  , d = win[ baseName ] // util.js
	  , propPrefix = "client" // util.js
	  , wName // util.js
	  , hName // util.js
 // util.js
	  // TODO: Merge this big "if" with the following one // util.js
	// Safari 2 uses document.clientWidth (default). // util.js
	if( typeof( document.clientWidth ) == "number" ) { // util.js
           // use document.clientHeight/Width. // util.js
	} // util.js
    else if(IS_BODY_ACTING_ROOT || isDocumentElementHeightOff() ) { // util.js
            // use document.body.clientHeight/Width. // util.js
	} else { // util.js
            // use document.documentElement.clientHeight/Width. // util.js
	} // util.js
 // util.js
    // Safari 2 uses document.clientWidth (default). // util.js
    if ( typeof ( d.clientWidth ) == "number" ){ // util.js
            baseName = "window" // util.js
    } // util.js
 // util.js
    // Opera < 9.5, or IE in quirks mode. // util.js
    else if ( IS_BODY_ACTING_ROOT ) { // util.js
    	baseName = DOCUMENT_ELEMENT // util.js
    	nodeName = "body" // util.js
 // util.js
    // Modern Webkit, Firefox, IE. // util.js
    // Might be undefined. 0 in older mozilla. // util.js
    } else if ( d[ DOCUMENT_ELEMENT ].clientHeight > 0 ) { // util.js
    	nodeName = DOCUMENT_ELEMENT; // util.js
    } // util.js
    wName = propPrefix + "Width" // util.js
    hName = propPrefix + "Height" // util.js
 // util.js
    getViewportDimensions = // util.js
       	function // util.js
    	( // util.js
    		win ) // util.js
    	{ // util.js
            var node = ( win || window )[ baseName ][ nodeName ] // util.js
 // util.js
            return [ node[ wName ], node[ hName ]] // util.js
//            return { width : node[ wName ], height : node[ hName ]} // util.js
        } // util.js
 // util.js
    return ( getViewportDimensions( win )) // util.js
} // util.js
 // util.js
function // util.js
getClientAreaSize( // util.js
	) // util.js
{ // util.js
	return ( getViewportDimensions() ) // util.js
	if ( isNumeric( window.innerWidth )) { // util.js
		popUpDebug( "1: " + [ window.innerWidth, window.innerHeight ]) // util.js
	} // util.js
 // util.js
	// IE 6+ in "standards compliant mode" // util.js
	if ( document.documentElement ) // util.js
		with ( document.documentElement ) // util.js
			if ( clientWidth || clientHeight ) { // util.js
				popUpDebug( "2: " + [ clientWidth, clientHeight ]) // util.js
			} // util.js
 // util.js
	// IE 4 compatible // util.js
	if ( document.body ) // util.js
		with ( document.body ) // util.js
			if ( clientWidth || clientHeight ) { // util.js
				popUpDebug( "3: " + [ clientWidth, clientHeight ]) // util.js
			} // util.js
 // util.js
	// Non-IE // util.js
	if ( isNumeric( window.innerWidth )) // util.js
		return ([ window.innerWidth, window.innerHeight ]) // util.js
 // util.js
	// IE 6+ in "standards compliant mode" // util.js
	if ( document.documentElement ) // util.js
		with ( document.documentElement ) // util.js
			if ( clientWidth || clientHeight ) // util.js
				return ([ clientWidth, clientHeight ]) // util.js
 // util.js
	// IE 4 compatible // util.js
	if ( document.body ) // util.js
		with ( document.body ) // util.js
			if ( clientWidth || clientHeight ) // util.js
				return ([ clientWidth, clientHeight ]) // util.js
 // util.js
	return ([ 0, 0 ]) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
addStyleSheetRules( // util.js
	) // util.js
{ // util.js
	for ( var i in gaoStyleSheetRule ) { // util.js
		var	o	= gaoStyleSheetRule[ i ] // util.js
		if ( o != null && typeof( o._ ) != "undefined" ) // util.js
			with ( addCSSRule( o._ ).style ) // util.js
				for ( var e in o ) // util.js
					if ( e != "_" ) // util.js
						eval( e + ' = "' + o[ e ] + '"' ) // util.js
	} // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Return the current timestamp, to the most recent second. // util.js
 * // util.js
 *	@return // util.js
 */ // util.js
 // util.js
function // util.js
nowSec( // util.js
	) // util.js
{ // util.js
	return ( timeSec( new Date() )) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
timeSec( // util.js
	dDate ) // util.js
{ // util.js
	return ( parseInt( dDate.getTime() / 1000 )) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Generic try/catch block. // util.js
 */ // util.js
 // util.js
function // util.js
tryCatch( // util.js
	sStatement, // util.js
	sCatchFn ) // util.js
{ // util.js
	if ( arguments.length < 2 ) // util.js
		sCatchFn = null // util.js
 // util.js
	var	vRV	= null // util.js
 // util.js
	try { // util.js
		vRV = eval( sStatement ) // util.js
	} catch ( oException ) { // util.js
		if ( sCatchFn != null ) { // util.js
			var	sRV	= "Exception in {" + sStatement + "}:\n--------" // util.js
			for ( var e in oException ) { // util.js
				var	sE	= oException[ e ] // util.js
				if ( typeof( sE ) == "function" ) // util.js
					sE = left( sE, ( String( sE ) + "{" ).indexOf( "{" )) // util.js
				sRV += String( "\n    ." + e + ": " + (( String( sE ).indexOf( "\n" ) > 0 ) ? "\n" : "" ) + sE ).replace( /\n*$/, "" ) // util.js
			} // util.js
			sRV += "\n--------" // util.js
			eval( sCatchFn + '("' + sRV.replace( /\\/g, "\\\\" ).replace( /\n/g, "\\n" ).replace( /"/g, '\\"' ) + '")' )	// TODO: This is basically stringJavaToJavaScript // util.js
		} // util.js
	} // util.js
 // util.js
	return ( vRV ) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
findElementByID( // util.js
	id ) // util.js
{ // util.js
	findElementByID = // util.js
	// Standardised method first // util.js
		( document.getElementById ) // util.js
		? // util.js
			function // util.js
			( // util.js
				id ) // util.js
			{ // util.js
				return ( document.getElementById( id )) // util.js
			} // util.js
		: ( document.all ) // util.js
		? // util.js
			function // util.js
			( // util.js
				id ) // util.js
			{ // util.js
				return ( document.all[ id ]) // util.js
			} // util.js
		: ( document.layers ) // util.js
		? // util.js
			function // util.js
			( // util.js
				id ) // util.js
			{ // util.js
				return ( document.layers[ id ]) // util.js
			} // util.js
		: // util.js
			function // util.js
			( // util.js
				id ) // util.js
			{ // util.js
				popUpDebug( "ERROR: Browser does not support find by ID" ) // util.js
 // util.js
				return ( null ) // util.js
			} // util.js
 // util.js
	return ( findElementByID( id )) // util.js
} // util.js
 // util.js
 // util.js
function // util.js
hideEverything( // util.js
	bHide ) // util.js
{ // util.js
	if ( arguments.length < 1 ) // util.js
		bHide = true // util.js
 // util.js
	if ( bHide ) { // util.js
		document.body.style.opacity = 0 // util.js
		document.body.style.filter = "alpha(opacity=0)"		// IE doesn't follow the W3C standard // util.js
	} // util.js
	else { // util.js
		document.body.style.opacity = 1 // util.js
		document.body.style.filter = "alpha(opacity=100)"	// IE doesn't follow the W3C standard // util.js
	} // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 * // util.js
 *	To simplify the math, we approximate the sine curve with a triangle function. // util.js
 * // util.js
 *	Phase is in units of cycles (i.e., phase = 1 <-> 2*pi radians). // util.js
 * // util.js
 *	A duration of zero means stop any existing bouncing. // util.js
 *	A negative duration means bounce forever. // util.js
 * // util.js
 *	Caution:  Not all elements can be made to bounce.  For instance, in Firefox, a <td> will not bounce; // util.js
 *	enclose its data in a <span> and bounce the <span>. // util.js
 *  // util.js
 * @param sScreenElementName // util.js
 * @param nAmplitude // util.js
 *		Amplitude (1/2 peak-to-peak distance) // util.js
 * // util.js
 * @param nHz // util.js
 * @param nMsecDuration // util.js
 * @return // util.js
 */ // util.js
 // util.js
var	gnBounceUpdateHz	= 60 // util.js
var	goBounceConst		= null // util.js
var	gaoBouncer			= null // util.js
 // util.js
function // util.js
bounce( // util.js
	sScreenElementName, // util.js
	nMsecDuration, // util.js
	nAmplitude, // util.js
	nHz, // util.js
	nPhaseInit ) // util.js
{ // util.js
	// Initialize constants // util.js
	if ( goBounceConst == null ) { // util.js
		var i   = 1 / gnBounceUpdateHz // util.js
		// TODO: Math appears to be slightly wrong here; amplitude gets too high // util.js
		goBounceConst = // util.js
			{ _					: null // util.js
			, nHzMax			: gnBounceUpdateHz / 2 - 1		// The amount we subtract can be anything greater than zero // util.js
			, nSecPerUpdate		: i // util.js
			, nMsecPerUpdate    : 1000 * i // util.js
			, nDAmpFactor		: 4 * i // util.js
			} // util.js
 // util.js
		gaoBouncer = {} // util.js
	} // util.js
 // util.js
	var	oB	= gaoBouncer[ sScreenElementName ] // util.js
 // util.js
	// If we're being called to (re)start an animation // util.js
	if ( arguments.length > 1 ) { // util.js
 // util.js
		// Set defaults // util.js
		if ( arguments.length < 3 ) // util.js
			nAmplitude = 0 // util.js
		if ( arguments.length < 4 ) // util.js
			nHz = 0 // util.js
		if ( arguments.length < 5 ) // util.js
			nPhaseInit = 0 // util.js
		 // util.js
		// Duration of zero means "stop bouncing" // util.js
		if ( nMsecDuration == 0 ) { // util.js
			if ( oB != null ) { // util.js
				clearInterval( oB.oTimer ) // util.js
				var	oS	= oB.oStyle // util.js
				oS.top = oB.nTopOrig // util.js
				oS.position = oB.nPositionOrig // util.js
				gaoBouncer[ sScreenElementName ] = null // util.js
			} // util.js
 // util.js
			return // util.js
		} // util.js
 // util.js
		// Frequencies at or above half the sampling rate will cause aliasing, // util.js
		//  so clamp them // util.js
		if ( nHz > goBounceConst.nHzMax ) // util.js
			nHz = goBounceConst.nHzMax // util.js
 // util.js
		// Convert initial phase to a pixel offset // util.js
		while ( nPhaseInit < 0 ) // util.js
			nPhaseInit += 1 // util.js
		var	i	= 4 * nPhaseInit + 1 // util.js
		if ( i >= 4 ) // util.js
			i -= 4 // util.js
		if ( i > 2 ) // util.js
			i = 4 - i // util.js
		i = ( 1 - i ) * nAmplitude // util.js
 // util.js
		// Capture the data we'll need while bouncing // util.js
		var	oS	= findElementByID( sScreenElementName ).style // util.js
		oB = // util.js
			{ _					: null // util.js
			, oStyle			: oS // util.js
			, nOffset			: i // util.js
			, nMsecRemaining	: nMsecDuration // util.js
			, nPhase			: nPhaseInit // util.js
			, nAbsDAmplitude	: nAmplitude * nHz * goBounceConst.nDAmpFactor // util.js
			, nDPhase			: nHz * goBounceConst.nSecPerUpdate // util.js
			, nTopOrig			: oS.top // util.js
			, nPositionOrig		: oS.position // util.js
			} // util.js
		gaoBouncer[ sScreenElementName ] = oB // util.js
 // util.js
		// We'll tweak the position relative to its "proper" location // util.js
		oS.position = "relative" // util.js
		oS.top = 0 // util.js
 // util.js
		// Now start up the interval timer // util.js
		oB.oTimer = // util.js
			setInterval( 'bounce( "' + sScreenElementName + '" )', goBounceConst.nMsecPerUpdate ) // util.js
 // util.js
		return // util.js
	} // util.js
 // util.js
	// Else we're being called during an animation // util.js
 // util.js
	// If we're counting down, count down some more; clamp at zero // util.js
	if ( oB.nMsecRemaining > 0 ) { // util.js
		oB.nMsecRemaining -= goBounceConst.nMsecPerUpdate // util.js
		if ( oB.nMsecRemaining < 0 ) // util.js
			oB.nMsecRemaining = 0 // util.js
	} // util.js
 // util.js
	// If time's up, stop bouncing // util.js
	if ( oB.nMsecRemaining == 0 ) { // util.js
		bounce( sScreenElementName, 0 ) // util.js
 // util.js
		return // util.js
	} // util.js
 // util.js
	// Advance the bounce // util.js
	oB.nPhase += oB.nDPhase // util.js
 // util.js
	// If we haven't gone full circle, take another step along the triangle wave // util.js
	if ( oB.nPhase < 1 ) { // util.js
		var	dy	= oB.nAbsDAmplitude // util.js
		if ( !( 0.25 <= oB.nPhase && oB.nPhase < 0.75 )) // util.js
			dy = -dy // util.js
		oB.nOffset += dy // util.js
	} // util.js
	// Else restart at zero (so errors don't accumulate) // util.js
	else { // util.js
		oB.nPhase = 0 // util.js
		oB.nOffset = 0 // util.js
	} // util.js
 // util.js
	// Move the screen element // util.js
	oB.oStyle.top = oB.nOffset // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Advance an animation of a windmill rotating clockwise. // util.js
 * // util.js
 * @param s // util.js
 * @return // util.js
 */ // util.js
 // util.js
var	asAnimation	= // util.js
	[ "" // util.js
	, "\\-/|" // util.js
	, " *O08:." // util.js
	] // util.js
 // util.js
function // util.js
rotator( // util.js
	sChar, // util.js
	nStyle ) // util.js
{ // util.js
	if ( arguments.length < 2 || nStyle > asAnimation.length || nStyle <= 0 ) // util.js
		nStyle = 1 // util.js
 // util.js
	var	sAnimation	= asAnimation[ nStyle ] // util.js
	var	i			= sAnimation.indexOf(( String( sChar ) + " " ).charAt( 0 )) // util.js
	if ( i <= 0 ) // util.js
		i = sAnimation.length // util.js
 // util.js
	return ( sAnimation.charAt( i - 1 )) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Display a message dialog. // util.js
 * // util.js
 */ // util.js
 // util.js
function // util.js
popUpMessage( // util.js
	sMessage,	// Message (null or empty string: no-op) // util.js
	sHeader,	// Header (null: show standard header; empty string: none) // util.js
	sFooter )	// Footer (null: show standard footer; empty string: none) // util.js
{ // util.js
	sHeader = sHeader || goText.popupStdHeader  // util.js
	if ( sHeader != "" ) // util.js
		sHeader = sHeader + "\n\n" // util.js
 // util.js
	sFooter = sFooter || goText.popupStdFooter // util.js
	if ( sFooter != "" ) // util.js
		sFooter = "\n\n" + sFooter // util.js
 // util.js
	sMessage = sMessage || "" // util.js
	if ( sMessage == "" ) // util.js
		return // util.js
 // util.js
	alert( sHeader + sMessage + sFooter ) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Display a debugging dialog. // util.js
 */ // util.js
 // util.js
function // util.js
popUpDebug( // util.js
	sMsg ) // util.js
{ // util.js
	if ( gbShowDebugDialogs ) // util.js
		alert( sMsg ) // util.js
} // util.js
 // util.js
 // util.js
/** // util.js
 *	Dump an object into a string. // util.js
 * // util.js
 *	@param o // util.js
 *	@return // util.js
 */ // util.js
 // util.js
function // util.js
dumpobj( // util.js
	o )		// The object // util.js
{ // util.js
	var s = "" // util.js
	for ( var e in o ) // util.js
		s += "\n" + typeof( o[ e ]) + " " + e + (( typeof( o [ e ]) != "function" ) ? " {" + o[ e ] + "}" : "()" ) // util.js
 // util.js
	return ( s.substr( 1 )) // util.js
} // util.js
	
// --- hookFunc.js ------------------------------------------------------------- 	
	
/** // hookFunc.js
 *	Hook a JavaScript function, so that when it is called, our // hookFunc.js
 *	own function gets executed instead.  If desired, we can // hookFunc.js
 *	still call the hooked function on our own. // hookFunc.js
 */ // hookFunc.js
 // hookFunc.js
var	gasHookedFunction	= []	// Name of hooked function, given the name of the handler that hooked it // hookFunc.js
var	gafHookedFunction	= []	// Body of hooked function, given the function's name // hookFunc.js
 // hookFunc.js
   	                 	    // hookFunc.js
/** // hookFunc.js
 *	Hook a JavaScript function. // hookFunc.js
 * // hookFunc.js
 *	Return false on error. // hookFunc.js
 *	TODO: Can we hook a function that is already hooked? // hookFunc.js
 */ // hookFunc.js
 // hookFunc.js
function // hookFunc.js
hookFunction( // hookFunc.js
	sHookedFunction,	// Name of the function to hook // hookFunc.js
	sHookingHandler )	// Name of the function that's replacing the hooked function // hookFunc.js
{ // hookFunc.js
	// Do nothing if the hooked function does not exist // hookFunc.js
	if ( typeof( eval( sHookedFunction )) != "function" ) // hookFunc.js
		return ( false ) // hookFunc.js
 // hookFunc.js
	// Do nothing if the hooked function is already hooked // hookFunc.js
	if ( typeof( gafHookedFunction[ sHookedFunction ]) != "undefined" ) // hookFunc.js
		return ( false ) // hookFunc.js
 // hookFunc.js
	// Keep track of which function is being hooked, and by whom // hookFunc.js
	gasHookedFunction[ sHookingHandler ] = sHookedFunction // hookFunc.js
	gafHookedFunction[ sHookedFunction ] = eval( sHookedFunction ) // hookFunc.js
 // hookFunc.js
	// Insert the hooking handler in place of the hooked function // hookFunc.js
	eval( sHookedFunction + " = " + sHookingHandler ) // hookFunc.js
 // hookFunc.js
	return ( true ) // hookFunc.js
} // hookFunc.js
 // hookFunc.js
 // hookFunc.js
/** // hookFunc.js
 *	Call a function that was hooked.  We can't simply call it by // hookFunc.js
 *	name, because that would execute the function that hooked it. // hookFunc.js
 * // hookFunc.js
 *	Notes: // hookFunc.js
 * // hookFunc.js
 *	"him" = the function our caller hooked -- if none, error // hookFunc.js
 *	Any changes we've made to our args will be passed to the hooked function // hookFunc.js
chf() (call him, with our args) // hookFunc.js
chf( null ) (call him, with our args) // hookFunc.js
chf( "" ) (call him, with our args) // hookFunc.js
chf( "()" ) call him, with no args // hookFunc.js
chf( "other") call other, with our args // hookFunc.js
chf( "other()") call other, with no args	  // hookFunc.js
chf( null, "blah") call him, with other args // hookFunc.js
chf( "", "blah") call him, with other args // hookFunc.js
chf( "()", "blah") call him, with other args // hookFunc.js
chf( "other", "blah") call other, with other args	 // hookFunc.js
chf( "other()", "blah") call other, with other args	 // hookFunc.js
If sFunction ends in "()" and there's no argument following, that means "call with empty arg list"; otherwise, ignore "()" // hookFunc.js
*/ // hookFunc.js
 // hookFunc.js
function // hookFunc.js
chainHookedFunction( // hookFunc.js
	oCaller,		// Our caller (pass as "arguments.callee") // hookFunc.js
	sFunction		// Name of function to call (default: the function we hooked) // hookFunc.js
	/*, ...*/ )		// Arguments (default: current values of our caller's argument list) // hookFunc.js
{ // hookFunc.js
	// Number of arguments our caller passed us // hookFunc.js
	var	nArgs			= arguments.length // hookFunc.js
 // hookFunc.js
	// Our caller's name // hookFunc.js
	//  (can't use arguments.callee.caller, because IE doesn't support it) // hookFunc.js
	var	sCallersName	= oCaller.toString() // hookFunc.js
							.replace( /\/\/[^\n]*\n/g, " " ) // hookFunc.js
							.replace( /\n/g, " " ) // hookFunc.js
							.replace( / *\(.*/, "" ) // hookFunc.js
							.replace( /^.* ([^ ]*)$/, "$1" ) // hookFunc.js
 // hookFunc.js
	// The arguments passed to our caller by ITS caller (arguments.callee.caller isn't supported in IE) // hookFunc.js
	//  TODO: This is not implemented // hookFunc.js
	var	aCallersArgs	= []	// arguments.callee.caller.arguments // hookFunc.js
 // hookFunc.js
	// Pass current values of caller's arguments as parameters (else our caller passed us arguments) // hookFunc.js
	var	bUseCallersArgs	= ( nArgs < 3 ) // hookFunc.js
 // hookFunc.js
	// If function name ends with empty parentheses, that means pass no arguments // hookFunc.js
	if ( nArgs > 1 && right( sFunction, 2 ) == "()" ) { // hookFunc.js
		bUseCallersArgs = false // hookFunc.js
		sFunction = left( sFunction, sFunction.length - 2 ) // hookFunc.js
	} // hookFunc.js
 // hookFunc.js
	// dhzdhz Infinite loop when we pass sFunction // hookFunc.js
	// If we are called with no function name, we'll call the function our caller hooked // hookFunc.js
	if ( nArgs < 2 || sFunction == "" ) // hookFunc.js
		sFunction = null // hookFunc.js
 // hookFunc.js
	// Get appropriate arguments list // hookFunc.js
	//  (arguments is not an array, so it doesn't support the slice() method) // hookFunc.js
	var	avArg // hookFunc.js
	// Caller's arguments // hookFunc.js
	if ( bUseCallersArgs ) // hookFunc.js
		avArg = Array.prototype.slice.call( aCallersArgs ) // hookFunc.js
	// Our own arguments, minus our caller and name of hooked function // hookFunc.js
	else { // hookFunc.js
		avArg = Array.prototype.slice.call( arguments ) // hookFunc.js
		avArg.shift() // hookFunc.js
		avArg.shift() // hookFunc.js
	} // hookFunc.js
 // hookFunc.js
	// Call the appropriate function, passing it the appropriate arguments // hookFunc.js
	try { // hookFunc.js
		// Replace a missing or empty function name with the name of the function that we hooked // hookFunc.js
		if ( sFunction == null ) // hookFunc.js
			sFunction = gasHookedFunction[ sCallersName ] // hookFunc.js
 // hookFunc.js
		// Although we now have a function name, someone else may have hooked it and usurped that name; // hookFunc.js
		//  if so, assume he wants us to call the original function that had that name // hookFunc.js
		// TODO: If we allow multiple hooking, this jumps all the way back to the original hooked function // hookFunc.js
		var	fFunction	= gafHookedFunction[ sFunction ] // hookFunc.js
		if ( fFunction == null ) // hookFunc.js
			fFunction = eval( sFunction ) // hookFunc.js
		if ( typeof( fFunction ) != "function" ) { // hookFunc.js
			if ( gbShowErrorHooked ) // hookFunc.js
				popUpDebug( "Error: chainHookedFunction: caller " + sCallersName + " unable to hook function " + sFunction ) // hookFunc.js
			return // hookFunc.js
		} // hookFunc.js
 // hookFunc.js
		// Call the named function // hookFunc.js
		fFunction.apply( this, avArg ) // hookFunc.js
	} // hookFunc.js
	catch ( err ) { // hookFunc.js
		if ( gbShowErrorHooked ) // hookFunc.js
			popUpDebug( "Error in hooked function " + sFunction + ": " + err ) // hookFunc.js
	} // hookFunc.js
} // hookFunc.js
	
// --- styleSheet.js ------------------------------------------------------------- 	
	
/** // styleSheet.js
 *	styleSheet.js // styleSheet.js
 * // styleSheet.js
 *	Control a style sheet. // styleSheet.js
 * // styleSheet.js
 *	Borrowed with modifications from http://www.hunlock.com/blogs/Totally_Pwn_CSS_with_Javascript // styleSheet.js
 */ // styleSheet.js
 // styleSheet.js
 // styleSheet.js
/** // styleSheet.js
 *	Get a CSS rule, if it exists.  If the delete flag is given, delete the rule. // styleSheet.js
 * // styleSheet.js
 *	@return	Object|bool // styleSheet.js
 *		The rule, or false if not found // styleSheet.js
 * // styleSheet.js
 *	@param	string			ruleName // styleSheet.js
 *		Name of the rule // styleSheet.js
 *	@param	string			deleteFlag // styleSheet.js
 *		Absent or "delete" // styleSheet.js
 */ // styleSheet.js
 // styleSheet.js
function getCSSRule(ruleName, deleteFlag) {               // Return requested style obejct // styleSheet.js
	ruleName=ruleName.toLowerCase();                       // Convert test string to lower case. // styleSheet.js
	if (document.styleSheets) {                            // If browser can play with stylesheets // styleSheet.js
		for (var i=0; i<document.styleSheets.length; i++) { // For each stylesheet // styleSheet.js
			var styleSheet=document.styleSheets[i];          // Get the current Stylesheet // styleSheet.js
			var ii=0;                                        // Initialize subCounter. // styleSheet.js
			var cssRule=false;                               // Initialize cssRule.  // styleSheet.js
			do {                                             // For each rule in stylesheet // styleSheet.js
				if (styleSheet.cssRules) {                    // Browser uses cssRules? // styleSheet.js
					cssRule = styleSheet.cssRules[ii];         // Yes --Mozilla Style // styleSheet.js
				} else {                                      // Browser usses rules? // styleSheet.js
					cssRule = styleSheet.rules[ii];            // Yes IE style.  // styleSheet.js
				}                                             // End IE check. // styleSheet.js
				if (cssRule)  {                               // If we found a rule... // styleSheet.js
					if ( // styleSheet.js
							  								  // {dzobel} Some rules have no selector text // styleSheet.js
							typeof(  cssRule.selectorText ) != "undefined" && cssRule.selectorText != null && // styleSheet.js
							cssRule.selectorText.toLowerCase()==ruleName) { //  match ruleName? // styleSheet.js
						if (deleteFlag=='delete') {             // Yes.  Are we deleteing? // styleSheet.js
							if (styleSheet.cssRules) {           // Yes, deleting... // styleSheet.js
								styleSheet.deleteRule(ii);        // Delete rule, Moz Style // styleSheet.js
							} else {                             // Still deleting. // styleSheet.js
								styleSheet.removeRule(ii);        // Delete rule IE style. // styleSheet.js
							}                                    // End IE check. // styleSheet.js
							return true;                         // return true, class deleted. // styleSheet.js
						} else {                                // found and not deleting. // styleSheet.js
							return cssRule;                      // return the style object. // styleSheet.js
						}                                       // End delete Check // styleSheet.js
					}                                          // End found rule name // styleSheet.js
				}                                             // end found cssRule // styleSheet.js
				ii++;                                         // Increment sub-counter // styleSheet.js
			} while (cssRule)                                // end While loop // styleSheet.js
		}                                                   // end For loop // styleSheet.js
	}                                                      // end styleSheet ability check // styleSheet.js
	return false;                                          // we found NOTHING! // styleSheet.js
}                                                         // end getCSSRule  // styleSheet.js
 // styleSheet.js
 // styleSheet.js
/** // styleSheet.js
 *	Delete a CSS rule, if it exists. // styleSheet.js
 * // styleSheet.js
 *	@return	bool // styleSheet.js
 *		Always false // styleSheet.js
 * // styleSheet.js
 *	@param	string			ruleName // styleSheet.js
 *		Name of the rule // styleSheet.js
 */ // styleSheet.js
 // styleSheet.js
function killCSSRule(ruleName) {                          // Delete a CSS rule    // styleSheet.js
	return getCSSRule(ruleName,'delete');                  // just call getCSSRule w/delete flag. // styleSheet.js
}                                                         // end killCSSRule // styleSheet.js
 // styleSheet.js
 // styleSheet.js
/** // styleSheet.js
 *	Create a CSS rule, or find it if it already exists. // styleSheet.js
 * // styleSheet.js
 *	@return	Object|bool // styleSheet.js
 *		The rule, or false if unable to create // styleSheet.js
 * // styleSheet.js
 *	@param	string			ruleName // styleSheet.js
 *		Name of the rule // styleSheet.js
 */ // styleSheet.js
 // styleSheet.js
function addCSSRule(ruleName) {                           // Create a new css rule // styleSheet.js
	if (document.styleSheets) {                            // Can browser do styleSheets? // styleSheet.js
		if (!getCSSRule(ruleName)) {                        // if rule doesn't exist... // styleSheet.js
			if (document.styleSheets[0].addRule) {           // Browser is IE? // styleSheet.js
				document.styleSheets[0].addRule(ruleName, null,0);      // Yes, add IE style // styleSheet.js
			} else {                                         // Browser is Moz? // styleSheet.js
				document.styleSheets[0].insertRule(ruleName+' { }', 0); // Yes, add Moz style. // styleSheet.js
			}                                                // End browser check // styleSheet.js
		}                                                   // End already exist check. // styleSheet.js
	}                                                      // End browser ability check. // styleSheet.js
	return getCSSRule(ruleName);                           // return rule we just created. // styleSheet.js
}  // styleSheet.js
	
// --- embedApplet.js ------------------------------------------------------------- 	
	
// TODO: Get rid of this if unused // embedApplet.js
var xapplet_fu = { // embedApplet.js
s : "", // embedApplet.js
  run: function(attributes, parameters, minimumVersion, fallbackContent){     // embedApplet.js
	this.s = "" // embedApplet.js
    if (this.isIE()){ // embedApplet.js
      this.openTagIE(attributes) // embedApplet.js
    } // embedApplet.js
    else{ // embedApplet.js
      this.openTagStandard(minimumVersion || '1.4.2'); // embedApplet.js
    } // embedApplet.js
     // embedApplet.js
    this.writeAttributes(attributes); // embedApplet.js
    this.writeParameters(parameters); // embedApplet.js
    this.documentwrite(fallbackContent || 'This content requires Java.'); // embedApplet.js
    this.documentwrite('</object>'); // embedApplet.js
     // embedApplet.js
    var ss = this.s // embedApplet.js
    this.s = "" // embedApplet.js
    	 // embedApplet.js
    return ( ss ) // embedApplet.js
  }, // embedApplet.js
   // embedApplet.js
  /* // embedApplet.js
   * Creates the opening object tag for standards-compliant browsers. Requests the minumum JRE version // embedApplet.js
   * specified with minimumVersion. // embedApplet.js
   */ // embedApplet.js
  openTagStandard: function(minimumVersion){ // embedApplet.js
    this.documentwrite('<object type="application/x-java-applet;version=' + minimumVersion + '"'); // embedApplet.js
  }, // embedApplet.js
   // embedApplet.js
  /* // embedApplet.js
   * Creates the opening object tag for IE using classid and codebase attributes. // embedApplet.js
   * If these attributes are not set, EasyApplet will request that the applet be run // embedApplet.js
   * with the latest installed JRE, or JDK 1.4, whichever is higher. For more information, see: // embedApplet.js
   * // embedApplet.js
   * http://java.sun.com/javase/6/webnotes/family-clsid.html // embedApplet.js
   * http://java.sun.com/javase/6/docs/technotes/guides/deployment/deployment-guide/autodl-files.html // embedApplet.js
   */ // embedApplet.js
  openTagIE: function(attributes){ // embedApplet.js
    var classid = attributes['classid'] || "clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"; //use latest installed JRE;  // embedApplet.js
    var codebase = attributes['codebase'] || "http://java.sun.com/products/plugin/autodl/jinstall-1_4-windows-i586.cab#Version=1,4,0,0"; //download JRE 1.4 if suitable JRE not found; // embedApplet.js
     // embedApplet.js
    this.documentwrite('<object classid="' + classid + '" codebase=' + codebase + '"'); // embedApplet.js
  }, // embedApplet.js
   // embedApplet.js
  writeAttributes: function(attributes){ // embedApplet.js
    for (attribute in attributes){ // embedApplet.js
      this.documentwrite(" "); // embedApplet.js
      this.documentwrite(attribute + "='" + attributes[attribute] + "'"); // embedApplet.js
    } // embedApplet.js
     // embedApplet.js
    this.documentwrite('>'); // embedApplet.js
  }, // embedApplet.js
   // embedApplet.js
  writeParameters: function(parameters){ // embedApplet.js
    for (parameter in parameters){ // embedApplet.js
      this.documentwrite("<param name=" + parameter + " value='" + parameters[parameter] + "'>"); // embedApplet.js
    } // embedApplet.js
  }, // embedApplet.js
   // embedApplet.js
  isIE: function(){ // embedApplet.js
    if (navigator == null) return false; // embedApplet.js
     // embedApplet.js
    return navigator.userAgent.match(/MSIE/) != null; // embedApplet.js
  } // embedApplet.js
 // embedApplet.js
  , // embedApplet.js
  documentwrite: function( s ) { this.s += s } // embedApplet.js
} // embedApplet.js
 // embedApplet.js
 // embedApplet.js
function // embedApplet.js
getHtmlToEmbedApplet( // embedApplet.js
	nInstance, // embedApplet.js
	sArchive, // embedApplet.js
	sRootClass, // embedApplet.js
	bIsIE ) // embedApplet.js
{ // embedApplet.js
	if ( arguments.length < 4 ) // embedApplet.js
		bIsIE = xapplet_fu.isIE() // embedApplet.js
 // embedApplet.js
	var	sJavaVersion	= "1.6" // embedApplet.js
	var	sJavaClassId	= "clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" // embedApplet.js
	var	sJavaPluginDir	= "//java.sun.com/products/plugin/" + sJavaVersion	// Don't specify protocol (http:); just use whatever protocol we're being run under // embedApplet.js
	// TODO: Why do width and height appear in three separate places here? // embedApplet.js
	var	sDims			= '' // embedApplet.js
						+ '\n' + '  width="1"' // embedApplet.js
						+ '\n' + '  height="1"' // embedApplet.js
	var	oAppletAttribs	= // embedApplet.js
		{ _					: null // embedApplet.js
			// TODO: Probably don't need to have separate IDs for IE/non-IE // embedApplet.js
		, id				: elementName( nInstance, "applet" )// ( xapplet_fu.isIE() ) ? "object" : "embed" ) // embedApplet.js
		, width				: 1		// TODO: This is the dim that actually matters // embedApplet.js
		, height			: 1 // embedApplet.js
		// Applet type // embedApplet.js
		, type				: "application/x-java-applet;version=" + sJavaVersion // embedApplet.js
		, classid			: sJavaClassId // embedApplet.js
		, codebase			: sJavaPluginDir + '/jinstall-' + sJavaVersion.replace( /\./, "" ) + '-win32.cab#Version=' + sJavaVersion.replace( /\./, "," ) + ",0,0" // embedApplet.js
		} // embedApplet.js
 // embedApplet.js
	var	oAppletParams	= // embedApplet.js
		{ _					: null // embedApplet.js
		, archive			: sArchive						// Applet file/URL // embedApplet.js
		, code				: sRootClass					// Applet root class // embedApplet.js
		, MAYSCRIPT			: true							// Let applet access the enclosing page's JavaScript (via JSObject)? // embedApplet.js
		, InterfaceControl	: "javaCallsInToJavaScript"		// JavaScript function for the applet to call // embedApplet.js
		, instance			: nInstance						// Instance of the applet on the page (0-based) // embedApplet.js
		} // embedApplet.js
 // embedApplet.js
	// TODO: Don't need? // embedApplet.js
	// TODO: Fix alternate message // embedApplet.js
	var	s = xapplet_fu.run( { width: 1, height: 1 }, oAppletParams, sJavaVersion, "Requires Java." ) // embedApplet.js
	// TODO: Probably don't need to have separate IDs for IE/non-IE // embedApplet.js
	var	sID = 'id="' + elementName( nInstance, "applet" )// ( xapplet_fu.isIE() ) ? "object" : "embed" ) + '"' // embedApplet.js
	s = s.replace( /object/, "object " + sID ) // embedApplet.js
//	return (s ) // embedApplet.js
 // embedApplet.js
/* // embedApplet.js
	var	sParamsObject	= '' // embedApplet.js
	var	sParamsEmbed	= '' // embedApplet.js
 // embedApplet.js
	for ( var e in oAppletParams ) // embedApplet.js
		if ( e != "_" ) { // embedApplet.js
			var	s		= '="' + oAppletParams[ e ] + '"' // embedApplet.js
			sParamsObject += '\n' + ' <param name="' + e + '" value' + s + '>' // embedApplet.js
			sParamsEmbed  += '\n' + '  ' + e + s // embedApplet.js
		} // embedApplet.js
// */ // embedApplet.js
 // embedApplet.js
/*	// We don't use deployJava.runApplet(), because it creates an <applet> tag, which is deprecated // embedApplet.js
    var oAttributesDeploy	= // embedApplet.js
    	{ // embedApplet.js
		  codebase	: sJavaPluginDir + '/jinstall-' + sJavaVersion.replace( /\./, "" ) + '-win32.cab#Version=' + sJavaVersion.replace( /\./, "," ) + ',0,0' // embedApplet.js
		, code		: sRootClass // embedApplet.js
        , archive	: sArchive // embedApplet.js
        , width		: 1 // embedApplet.js
        , height	: 1 // embedApplet.js
        } // embedApplet.js
 // embedApplet.js
	deployJava.runApplet( oAttributesDeploy, oAppletParams, sJavaVersion ) // embedApplet.js
// */ // embedApplet.js
	 // embedApplet.js
	if ( bIsIE ) { // embedApplet.js
		oAppletParams.type = oAppletAttribs.type // embedApplet.js
		oAppletAttribs.type = null // embedApplet.js
	} // embedApplet.js
	else { // embedApplet.js
		oAppletAttribs.classid = null // embedApplet.js
		oAppletAttribs.codebase = null // embedApplet.js
	} // embedApplet.js
 // embedApplet.js
	var	s	= "<object" // embedApplet.js
	for ( var e in oAppletAttribs ) // embedApplet.js
		if ( oAppletAttribs[ e ] != null ) // embedApplet.js
			s += " " + e + '="' + oAppletAttribs[ e ] + '"' // embedApplet.js
	s += ">" // embedApplet.js
	for ( var e in oAppletParams ) // embedApplet.js
		if ( oAppletParams[ e ] != null ) // embedApplet.js
			s += "\n " + '<param name="' + e + '" value="' + oAppletParams[ e ] + '">' // embedApplet.js
	s += "\n" + "ERROR: Unable to embed applet" // embedApplet.js
	s += "\n" + "</object>" // embedApplet.js
 // embedApplet.js
	return ( s ) // embedApplet.js
/* // embedApplet.js
	return ( '' // embedApplet.js
		+ '\n' + 	'<object' // embedApplet.js
		+ '\n' + 	' id="' + elementName( nInstance, "object" ) + '"' // embedApplet.js
		+ '\n' + 	' classid="' + sJavaClassId + '"' // embedApplet.js
		+ '\n' + 	' codebase="' + sJavaPluginDir + '/jinstall-' + sJavaVersion.replace( /\./, "" ) + '-win32.cab#Version=' + sJavaVersion.replace( /\./, "," ) + ',0,0"' // embedApplet.js
		+ sDims // embedApplet.js
		+ '\n' + 	' >' // embedApplet.js
		+ sParamsObject // embedApplet.js
		+ '\n' + 	' <embed' // embedApplet.js
		+ '\n' + 	'  id="' + elementName( nInstance, "embed" ) + '"' // embedApplet.js
		+ '\n' + 	'  pluginspage="' + sJavaPluginDir + '/plugin-install.html"' // embedApplet.js
		+ '\n' + 	'  hidden="true"' // embedApplet.js
		+ sDims // embedApplet.js
		+ sParamsEmbed // embedApplet.js
		+ '\n' + 	'  >' // embedApplet.js
		+ '\n' + 	'  <noembed>' // embedApplet.js
		+ '\n' + 	'  ERROR: Unable to embed applet' // embedApplet.js
		+ '\n' + 	'  </noembed>' // embedApplet.js
		+ '\n' + 	' </embed>' // embedApplet.js
		+ '\n' +	'</object>' // embedApplet.js
		) // embedApplet.js
// */ // embedApplet.js
} // embedApplet.js
 // embedApplet.js
 // embedApplet.js
/** // embedApplet.js
 * 	Get/set the answer to whether the JavaScript is initialized. // embedApplet.js
 */ // embedApplet.js
 // embedApplet.js
var	bJavaScriptInitialized	= false // embedApplet.js
 // embedApplet.js
function // embedApplet.js
javaScriptInitialized( // embedApplet.js
	bInited ) // embedApplet.js
{ // embedApplet.js
	if ( arguments.length > 0 ) // embedApplet.js
		bJavaScriptInitialized = bInited // embedApplet.js
 // embedApplet.js
	return ( typeof( bJavaScriptInitialized ) != "undefined" && bJavaScriptInitialized ) // embedApplet.js
} // embedApplet.js
	
// --- appletIF.js ------------------------------------------------------------- 	
	
/** // appletIF.js
 *	Interface to the M5 integration applet. // appletIF.js
 */ // appletIF.js
 // appletIF.js
/** // appletIF.js
 *  List of callbacks for applet to call when it gets a response to a request // appletIF.js
 *  it has sent on our behalf. // appletIF.js
 */ // appletIF.js
 // appletIF.js
// var asfnResponse = [] // appletIF.js
 // appletIF.js
 // appletIF.js
var gnAppletInstances   = 1 // appletIF.js
 // appletIF.js
var gjReqInfo        	= [] // appletIF.js
 // appletIF.js
 // appletIF.js
// TODO: Do as actual object // appletIF.js
 // appletIF.js
function // appletIF.js
jReqInfo_constructor( // appletIF.js
	sDescr, // appletIF.js
	sParam, // appletIF.js
	bMultiChunks ) // appletIF.js
{ // appletIF.js
	if ( arguments.length < 2 ) // appletIF.js
	    sParam = "" // appletIF.js
 // appletIF.js
	return ( // appletIF.js
		{ _				: null // appletIF.js
		, sDescr		: sDescr // appletIF.js
		, sParam		: sParam // appletIF.js
		, bMultiChunks	: bMultiChunks // appletIF.js
		}) // appletIF.js
} // appletIF.js
 // appletIF.js
 // appletIF.js
/** // appletIF.js
 *  Can have ri = null to clear out entry. // appletIF.js
 */ // appletIF.js
 // appletIF.js
function // appletIF.js
jReqInfo_push( // appletIF.js
	nInstance, // appletIF.js
	nID, // appletIF.js
	ri ) // appletIF.js
{ // appletIF.js
	if ( gjReqInfo[ nInstance ] == null ) // appletIF.js
	    gjReqInfo[ nInstance ] = {} // appletIF.js
	gjReqInfo[ nInstance ][ nID ] = ri // appletIF.js
} // appletIF.js
 // appletIF.js
 // appletIF.js
function // appletIF.js
jReqInfo_peek( // appletIF.js
	nInstance, // appletIF.js
	nID ) // appletIF.js
{ // appletIF.js
	if ( gjReqInfo[ nInstance ] == null ) // appletIF.js
	    return ( null ) // appletIF.js
	var	ri	= gjReqInfo[ nInstance ][ nID ] // appletIF.js
 // appletIF.js
	return ( ri ) // appletIF.js
} // appletIF.js
 // appletIF.js
 // appletIF.js
function // appletIF.js
jReqInfo_pop( // appletIF.js
	nInstance, // appletIF.js
	nID ) // appletIF.js
{ // appletIF.js
	var	ri	= jReqInfo_peek( nInstance, nID ) // appletIF.js
	jReqInfo_push( nInstance, nID, null ) // appletIF.js
 // appletIF.js
	return ( ri ) // appletIF.js
} // appletIF.js
 // appletIF.js
 // appletIF.js
/* // appletIF.js
 *	Java applet control function table.  Entry #i gives the name of the control // appletIF.js
 *	function inside instance #i of the Java applet. // appletIF.js
 */ // appletIF.js
 // appletIF.js
var javaControlFn = [] // appletIF.js
 // appletIF.js
 // appletIF.js
/** // appletIF.js
 *  Java interface.  The web page calls this whenever it wants the // appletIF.js
 *  applet to perform a function. // appletIF.js
 * // appletIF.js
 *  @return anyType // appletIF.js
 *      The value, if any, returned by the applet // appletIF.js
 */ // appletIF.js
 // appletIF.js
function // appletIF.js
javaScriptCallsOutToJava( // appletIF.js
	nInstance,				// Instance of the Java applet // appletIF.js
	sCommand,				// Command name // appletIF.js
	sParam1					// First parameter to the command (if any) // appletIF.js
	// , ...                // Additional command parameters (if any) // appletIF.js
	) // appletIF.js
{ // appletIF.js
	var javaCF  = javaControlFn[ nInstance ] // appletIF.js
	                              // appletIF.js
	if ( javaCF == null || typeof( javaCF ) == "undefined" ) { // appletIF.js
	// dhz This might happen when we're faking clicks during init(), which is not really an error // appletIF.js
//	    popUpDebug( "No Java control function for instance #" + nInstance ) // appletIF.js
		return ( null ) // appletIF.js
	} // appletIF.js
 // appletIF.js
	// Concatenate all the parameters into a comma-separated string // appletIF.js
	var	sParams	= "" // appletIF.js
	var args = Array.prototype.slice.call( arguments ) // appletIF.js
	args.shift() // appletIF.js
	args.shift() // appletIF.js
	while ( args.length ) { // appletIF.js
	    var sParam  = args[ 0 ]   // TODO: will this work with null? // appletIF.js
//	    if ( !isNumeric( sParam ) && ",true,false,null,".indexOf( "," + sParam + "," ) < 0 ) // appletIF.js
//	        sParam = '"' + sParam + '"' // appletIF.js
		// Separate parameters with a single comma only; no spaces // appletIF.js
	    sParams += "," + sParam // appletIF.js
	    args.shift() // appletIF.js
	} // appletIF.js
	sParams = sParams.substr( 1 )   // Delete initial comma, if any // appletIF.js
 // appletIF.js
	// TODO: Convert the command and the parameter to Java strings? // appletIF.js
 // appletIF.js
	logme( 10, "tell applet " + nInstance + ': "' + sCommand + '" ' + sParams.replace( /,/g, " " )) // appletIF.js
	// TODO: We sometimes get an error here: "element( nInstance, gsAppletPrefix )[ javaCF ] is not a function" // appletIF.js
	//  This appears to be caused by a Mozilla bug:  When using getElementById(), Firefox incorrectly // appletIF.js
	//  interprets an htmlEmbedElement as a function (see http://bytes.com/topic/javascript/answers/762818-shortcut-class-method-fails-firefox-works-ie ) // appletIF.js
 // appletIF.js
	var	sRetVal	= null // appletIF.js
/* // appletIF.js
	if ( typeof( element( nInstance, gsAppletPrefix )[ javaCF ]) != "function" ) // appletIF.js
		logme( 1, "ERROR: element( " + nInstance + ', "' + gsAppletPrefix + '" )[ "' + javaCF + '" ] is ' + typeof( element( nInstance, gsAppletPrefix )[ javaCF ]) // appletIF.js
			+ " and element( " + nInstance + ', "' + gsAppletPrefix + '" ) is ' + typeof( element( nInstance, gsAppletPrefix )) // appletIF.js
			+ " i.e. " + element( nInstance, gsAppletPrefix )) // appletIF.js
	else // appletIF.js
		sRetVal = element( nInstance, gsAppletPrefix )[ javaCF ]( sCommand, sParams ) // appletIF.js
// */ // appletIF.js
/* // appletIF.js
	var	oApplet	= element( nInstance, gsAppletPrefix ) // appletIF.js
	if ( typeof( oApplet ) == "function" ) // appletIF.js
		logme( 1, "ERROR: Mozilla browser has incorrectly interpreted an htmlEmbedElement as a function" ) // appletIF.js
	var	oFn		= oApplet[ javaCF ] // appletIF.js
 // appletIF.js
	if ( typeof( oFn ) != "function" ) // appletIF.js
		logme( 1, "ERROR: element( " + nInstance + ', "' + gsAppletPrefix + '" )[ "' + javaCF + '" ] is ' + typeof( element( nInstance, gsAppletPrefix )[ javaCF ]) // appletIF.js
			+ " and element( " + nInstance + ', "' + gsAppletPrefix + '" ) is ' + typeof( element( nInstance, gsAppletPrefix )) // appletIF.js
			+ " i.e. " + element( nInstance, gsAppletPrefix )) // appletIF.js
	else // appletIF.js
		sRetVal = oFn( sCommand, sParams ) // appletIF.js
// */ // appletIF.js
    // dhzdhz Workaround for "NPMethod called on non-NPObject wrapped JSObject!" bug (bug #27) // appletIF.js
	var	oApplet		= element( nInstance, "applet" ) // appletIF.js
	for ( var bOK = false; !bOK; ) { // appletIF.js
	// Keep trying until JavaScript has a usable handle to the applet's interface function // appletIF.js
	//  (no idea why it sometimes takes a few tries -- evidently related to Mozilla's inability to distinguish between an htmlEmbedElement and a function) // appletIF.js
//	setTimeout( "dhz9blah()", 5000 ); return ('') // appletIF.js
		// IE refuses to give us a pointer to this API; "oFn = oApplet.javaScriptCallInToJava" always throws a "not found" exception, // appletIF.js
		// although if ( "javaScriptCallsInToJava" in oApplet ) returns true and oApplet.javaScriptCallsInToJava( ... ) succeeds // appletIF.js
 // appletIF.js
		try { // appletIF.js
			// This may not succeed in FF for a while // appletIF.js
			// TODO: We've hard-wired the applet method name rather than using the variable javaCF // appletIF.js
			sRetVal = oApplet.javaScriptCallsInToJava( sCommand, sParams ) // appletIF.js
			bOK = true // appletIF.js
		} // appletIF.js
		catch ( e ) { // appletIF.js
			try { // appletIF.js
				// Firefox won't let us call the method until we've constructed a pointer to it, even though we don't use that pointer // appletIF.js
				var	oFn	= oApplet.javaScriptCallsInToJava // appletIF.js
			} // appletIF.js
			catch ( e ) { // appletIF.js
				// IE never lets us construct a pointer to the function // appletIF.js
			} // appletIF.js
		} // appletIF.js
	} // appletIF.js
 // appletIF.js
	logme( 10, "applet " + nInstance + " returns {" + (( sRetVal == null ) ? "" : sRetVal ) + "}" ) // appletIF.js
 // appletIF.js
	return ( sRetVal ) // appletIF.js
} // appletIF.js
 // appletIF.js
 // appletIF.js
function // appletIF.js
waitdhz9() // appletIF.js
{ // appletIF.js
	var	oFn // appletIF.js
	var nInstance = 0 // appletIF.js
	var	sParam = "javaScriptCallsInToJava" // appletIF.js
	oApplet = element( nInstance, "applet" ) // appletIF.js
 // appletIF.js
	try { // appletIF.js
		popUpDebug( 'gimme that ' + oApplet[ sParam ]( "get version", "" )) // appletIF.js
	} // appletIF.js
	catch ( e ) { // appletIF.js
		popUpDebug('no no no ' + dumpobj( e )) // appletIF.js
		setTimeout( "waitdhz9()", 1000) // appletIF.js
		return // appletIF.js
	} // appletIF.js
	try { // appletIF.js
		oFn = oApplet[ sParam ] // appletIF.js
	} // appletIF.js
	catch ( e ) { // appletIF.js
		popUpDebug('not ready yet ' + dumpobj( e )) // appletIF.js
		setTimeout( "waitdhz9()", 1000) // appletIF.js
		return // appletIF.js
	} // appletIF.js
    // Now that we know it's alive, initialize it, if necessary // appletIF.js
	popUpDebug("finally alive!") // appletIF.js
	javaControlFn[ nInstance ] = sParam // appletIF.js
    eval( "init_" + gsDocType )( nInstance ) // appletIF.js
	return "" // appletIF.js
} // appletIF.js
 // appletIF.js
function // appletIF.js
dhz9blah() // appletIF.js
{ // appletIF.js
	var oFn // appletIF.js
	var oApplet // appletIF.js
	do { // appletIF.js
		oApplet = element( 0, "applet" ) // appletIF.js
		// dhz99 Error here: can't see this API in IE // appletIF.js
		popUpDebug('dhz9b does fn exist?') // appletIF.js
		popUpDebug("javaScriptCallsInToJava" in oApplet ) // appletIF.js
		oFn = null // appletIF.js
		try { // appletIF.js
			oApplet.javaScriptCallsInToJava( "get version" ) // appletIF.js
		} // appletIF.js
		catch ( e ) { // appletIF.js
			popUpDebug("blah eek") // appletIF.js
		} // appletIF.js
		try { // appletIF.js
			oFn = oApplet.javaScriptCallsInToJava // appletIF.js
		} // appletIF.js
		catch ( e ) { // appletIF.js
			popUpDebug("blah eck") // appletIF.js
		} // appletIF.js
 // appletIF.js
		popUpDebug('dhz9b gives ' + oFn + '!') // appletIF.js
	} while ( typeof( oFn ) != "function" ) // appletIF.js
		popUpDebug('dhz9 leaving blah') // appletIF.js
} // appletIF.js
 // appletIF.js
/** // appletIF.js
 *  Interface control function.  The Java applet calls out to this (via win.eval) // appletIF.js
 *  when it wants the web page that hosts it to perform a function. // appletIF.js
 */ // appletIF.js
 // appletIF.js
function // appletIF.js
javaCallsInToJavaScript( // appletIF.js
	nInstance,      // Instance of the Java applet // appletIF.js
	sCommand,       // The request command // appletIF.js
	sParam )        // [opt.] Parameters for the command, comma-separated // appletIF.js
{ // appletIF.js
	return ( tryCatchLog( "javaCallsInToJavaScript_2(" + nInstance + ',"' + sCommand + '","' + sParam + '")' )) // appletIF.js
} // appletIF.js
 // appletIF.js
 // appletIF.js
function // appletIF.js
javaCallsInToJavaScript_2( // appletIF.js
	nInstance,      // Instance of the Java applet // appletIF.js
	sCommand,       // The request command // appletIF.js
	sParam )        // [opt.] Parameters for the command, comma-separated // appletIF.js
{ // appletIF.js
	var sRV = ""	// Return value // appletIF.js
 // appletIF.js
	logme( 10, "applet " + nInstance + ' says: "' + sCommand + '" ' + sParam.replace( /[,;]/g, " " )) // appletIF.js
 // appletIF.js
	switch ( sCommand ) { // appletIF.js
 // appletIF.js
	// The applet is telling us that it's alive and how it wants us to call it // appletIF.js
	case "set control function": // appletIF.js
	    javaControlFn[ nInstance ] = sParam // appletIF.js
	    eval( "init_" + gsDocType )( nInstance ) // appletIF.js
	    break // appletIF.js
 // appletIF.js
	case "get request": // appletIF.js
		sRV = getHttpRequest( nInstance ) // appletIF.js
		break // appletIF.js
 // appletIF.js
	case "show request": // appletIF.js
		showHttpRequest( nInstance, sParam ) // appletIF.js
		break // appletIF.js
 // appletIF.js
	case "show response": // appletIF.js
		showHttpResponse( nInstance, 0, sParam )		// TODO: nStatus = 0? // appletIF.js
		break // appletIF.js
 // appletIF.js
	case "got web response": // appletIF.js
	    var i					= sParam.indexOf( "," ) // appletIF.js
	    var nID					= sParam.substr( 0, i ) // appletIF.js
	    sParam					= sParam.substr( i + 1 ) // appletIF.js
	    i						= sParam.indexOf( "," ) // appletIF.js
	    var bTimedOut			= ( sParam.substr( 0, i ) == "true" ) // appletIF.js
	    sParam					= sParam.substr( i + 1 ) // appletIF.js
	    i						= sParam.indexOf( "," ) // appletIF.js
	    var bLastChunk			= ( sParam.substr( 0, i ) == "true" ) // appletIF.js
	    var sSerializedResponse = sParam.substr( i + 1 ) // appletIF.js
	    var	ri = jReqInfo_peek( nInstance, nID ) // appletIF.js
	    if ( ri == null ) { // appletIF.js
//	    	popUpDebug('dhz throw away ' + nInstance + ',' + nID) // appletIF.js
	        ; // discard response // appletIF.js
	        break // appletIF.js
		} // appletIF.js
		 // appletIF.js
		if ( bTimedOut ) { // appletIF.js
			;	    //TODO what if timed out? // appletIF.js
			break // appletIF.js
		} // appletIF.js
 // appletIF.js
		switch ( gsDocType ) { // appletIF.js
 // appletIF.js
		case "harness": // appletIF.js
			showSerializedResponse( nInstance, nID, ri.sDescr + ri.sParam, sSerializedResponse ) // appletIF.js
			break // appletIF.js
 // appletIF.js
		case "panel": // appletIF.js
			switch ( ri.sDescr ) { // appletIF.js
 // appletIF.js
			case "subscribe": // appletIF.js
				processSubscribeChunk( sSerializedResponse ) // appletIF.js
				break // appletIF.js
 // appletIF.js
			case "listCalls": // appletIF.js
				processCallsInfo( sSerializedResponse ) // appletIF.js
				break // appletIF.js
 // appletIF.js
			default: // appletIF.js
				// Parse, just in case it's an error // appletIF.js
				parseSubscribeResponse( sSerializedResponse ) // appletIF.js
				break // appletIF.js
			} // appletIF.js
			break // appletIF.js
 // appletIF.js
		default: // appletIF.js
			break				 // appletIF.js
		} // appletIF.js
		if ( !ri.bMultiChunks ) // appletIF.js
		    jReqInfo_pop( nInstance, nID ) // appletIF.js
		break // appletIF.js
 // appletIF.js
	case "alert": // appletIF.js
		popUpMessage( "--- Message from Java applet #" + nInstance // appletIF.js
			+ " ---\n\n" + sParam ) // appletIF.js
		break // appletIF.js
 // appletIF.js
	default: // appletIF.js
	    popUpDebug( "Unknown command from Java applet #" + nInstance // appletIF.js
			+ ": \"" + sCommand + "\" sParam=\"" + sParam + "\"" ) // appletIF.js
	    break // appletIF.js
	} // appletIF.js
 // appletIF.js
	return ( sRV ) // appletIF.js
} // appletIF.js
	
// --- main.js ------------------------------------------------------------- 	
	
/** // main.js
 *	Now that the page is loaded and all other in-line JavaScript commands have // main.js
 *	executed, do any page-specific initializations. // main.js
 */ // main.js
 // main.js
eval( "init_" + gsDocType )( -1 ) // main.js
